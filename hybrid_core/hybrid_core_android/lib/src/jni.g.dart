// ignore_for_file: use_super_parameters
// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

// Auto-generated initialization code.

final ffi.Pointer<T> Function<T extends ffi.NativeType>(String sym) jniLookup =
    ProtectedJniExtensions.initGeneratedLibrary("hybrid_core_android");

/// from: android.os.Build$Partition
class Build_Partition extends jni.JObject {
  @override
  late final jni.JObjType<Build_Partition> $type = type;

  Build_Partition.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Build_PartitionType();

  /// from: static public final java.lang.String PARTITION_NAME_SYSTEM
  static const PARTITION_NAME_SYSTEM = r"""system""";

  static final _getName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Build_Partition__getName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getName() {
    return const jni.JStringType().fromRef(_getName(reference).object);
  }

  static final _getFingerprint = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Build_Partition__getFingerprint")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getFingerprint()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFingerprint() {
    return const jni.JStringType().fromRef(_getFingerprint(reference).object);
  }

  static final _getBuildTimeMillis = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Build_Partition__getBuildTimeMillis")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public long getBuildTimeMillis()
  int getBuildTimeMillis() {
    return _getBuildTimeMillis(reference).long;
  }

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Build_Partition__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return _equals1(reference, object.reference).boolean;
  }

  static final _hashCode1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Build_Partition__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference).integer;
  }
}

final class $Build_PartitionType extends jni.JObjType<Build_Partition> {
  const $Build_PartitionType();

  @override
  String get signature => r"Landroid/os/Build$Partition;";

  @override
  Build_Partition fromRef(jni.JObjectPtr ref) => Build_Partition.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Build_PartitionType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_PartitionType) &&
        other is $Build_PartitionType;
  }
}

/// from: android.os.Build$VERSION
class Build_VERSION extends jni.JObject {
  @override
  late final jni.JObjType<Build_VERSION> $type = type;

  Build_VERSION.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Build_VERSIONType();
  static final _get_BASE_OS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__BASE_OS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String BASE_OS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BASE_OS =>
      const jni.JStringType().fromRef(_get_BASE_OS().object);

  static final _get_CODENAME =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__CODENAME")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String CODENAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CODENAME =>
      const jni.JStringType().fromRef(_get_CODENAME().object);

  static final _get_INCREMENTAL =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__INCREMENTAL")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String INCREMENTAL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get INCREMENTAL =>
      const jni.JStringType().fromRef(_get_INCREMENTAL().object);

  static final _get_MEDIA_PERFORMANCE_CLASS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__MEDIA_PERFORMANCE_CLASS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final int MEDIA_PERFORMANCE_CLASS
  static int get MEDIA_PERFORMANCE_CLASS =>
      _get_MEDIA_PERFORMANCE_CLASS().integer;

  static final _get_PREVIEW_SDK_INT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__PREVIEW_SDK_INT")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final int PREVIEW_SDK_INT
  static int get PREVIEW_SDK_INT => _get_PREVIEW_SDK_INT().integer;

  static final _get_RELEASE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__RELEASE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String RELEASE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RELEASE =>
      const jni.JStringType().fromRef(_get_RELEASE().object);

  static final _get_RELEASE_OR_CODENAME =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__RELEASE_OR_CODENAME")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String RELEASE_OR_CODENAME
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RELEASE_OR_CODENAME =>
      const jni.JStringType().fromRef(_get_RELEASE_OR_CODENAME().object);

  static final _get_RELEASE_OR_PREVIEW_DISPLAY =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__RELEASE_OR_PREVIEW_DISPLAY")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String RELEASE_OR_PREVIEW_DISPLAY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RELEASE_OR_PREVIEW_DISPLAY =>
      const jni.JStringType().fromRef(_get_RELEASE_OR_PREVIEW_DISPLAY().object);

  static final _get_SDK =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__SDK")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String SDK
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SDK =>
      const jni.JStringType().fromRef(_get_SDK().object);

  static final _get_SDK_INT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__SDK_INT")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final int SDK_INT
  static int get SDK_INT => _get_SDK_INT().integer;

  static final _get_SECURITY_PATCH =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build_VERSION__SECURITY_PATCH")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String SECURITY_PATCH
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SECURITY_PATCH =>
      const jni.JStringType().fromRef(_get_SECURITY_PATCH().object);

  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Build_VERSION__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Build_VERSION() {
    return Build_VERSION.fromRef(_new0().object);
  }
}

final class $Build_VERSIONType extends jni.JObjType<Build_VERSION> {
  const $Build_VERSIONType();

  @override
  String get signature => r"Landroid/os/Build$VERSION;";

  @override
  Build_VERSION fromRef(jni.JObjectPtr ref) => Build_VERSION.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Build_VERSIONType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_VERSIONType) &&
        other is $Build_VERSIONType;
  }
}

/// from: android.os.Build$VERSION_CODES
class Build_VERSION_CODES extends jni.JObject {
  @override
  late final jni.JObjType<Build_VERSION_CODES> $type = type;

  Build_VERSION_CODES.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Build_VERSION_CODESType();

  /// from: static public final int BASE
  static const BASE = 1;

  /// from: static public final int BASE_1_1
  static const BASE_1_1 = 2;

  /// from: static public final int CUPCAKE
  static const CUPCAKE = 3;

  /// from: static public final int CUR_DEVELOPMENT
  static const CUR_DEVELOPMENT = 10000;

  /// from: static public final int DONUT
  static const DONUT = 4;

  /// from: static public final int ECLAIR
  static const ECLAIR = 5;

  /// from: static public final int ECLAIR_0_1
  static const ECLAIR_0_1 = 6;

  /// from: static public final int ECLAIR_MR1
  static const ECLAIR_MR1 = 7;

  /// from: static public final int FROYO
  static const FROYO = 8;

  /// from: static public final int GINGERBREAD
  static const GINGERBREAD = 9;

  /// from: static public final int GINGERBREAD_MR1
  static const GINGERBREAD_MR1 = 10;

  /// from: static public final int HONEYCOMB
  static const HONEYCOMB = 11;

  /// from: static public final int HONEYCOMB_MR1
  static const HONEYCOMB_MR1 = 12;

  /// from: static public final int HONEYCOMB_MR2
  static const HONEYCOMB_MR2 = 13;

  /// from: static public final int ICE_CREAM_SANDWICH
  static const ICE_CREAM_SANDWICH = 14;

  /// from: static public final int ICE_CREAM_SANDWICH_MR1
  static const ICE_CREAM_SANDWICH_MR1 = 15;

  /// from: static public final int JELLY_BEAN
  static const JELLY_BEAN = 16;

  /// from: static public final int JELLY_BEAN_MR1
  static const JELLY_BEAN_MR1 = 17;

  /// from: static public final int JELLY_BEAN_MR2
  static const JELLY_BEAN_MR2 = 18;

  /// from: static public final int KITKAT
  static const KITKAT = 19;

  /// from: static public final int KITKAT_WATCH
  static const KITKAT_WATCH = 20;

  /// from: static public final int LOLLIPOP
  static const LOLLIPOP = 21;

  /// from: static public final int LOLLIPOP_MR1
  static const LOLLIPOP_MR1 = 22;

  /// from: static public final int M
  static const M = 23;

  /// from: static public final int N
  static const N = 24;

  /// from: static public final int N_MR1
  static const N_MR1 = 25;

  /// from: static public final int O
  static const O = 26;

  /// from: static public final int O_MR1
  static const O_MR1 = 27;

  /// from: static public final int P
  static const P = 28;

  /// from: static public final int Q
  static const Q = 29;

  /// from: static public final int R
  static const R = 30;

  /// from: static public final int S
  static const S = 31;

  /// from: static public final int S_V2
  static const S_V2 = 32;

  /// from: static public final int TIRAMISU
  static const TIRAMISU = 33;

  /// from: static public final int UPSIDE_DOWN_CAKE
  static const UPSIDE_DOWN_CAKE = 34;

  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Build_VERSION_CODES__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Build_VERSION_CODES() {
    return Build_VERSION_CODES.fromRef(_new0().object);
  }
}

final class $Build_VERSION_CODESType extends jni.JObjType<Build_VERSION_CODES> {
  const $Build_VERSION_CODESType();

  @override
  String get signature => r"Landroid/os/Build$VERSION_CODES;";

  @override
  Build_VERSION_CODES fromRef(jni.JObjectPtr ref) =>
      Build_VERSION_CODES.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Build_VERSION_CODESType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Build_VERSION_CODESType) &&
        other is $Build_VERSION_CODESType;
  }
}

/// from: android.os.Build
class Build extends jni.JObject {
  @override
  late final jni.JObjType<Build> $type = type;

  Build.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $BuildType();
  static final _get_BOARD =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__BOARD")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String BOARD
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BOARD =>
      const jni.JStringType().fromRef(_get_BOARD().object);

  static final _get_BOOTLOADER =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__BOOTLOADER")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String BOOTLOADER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BOOTLOADER =>
      const jni.JStringType().fromRef(_get_BOOTLOADER().object);

  static final _get_BRAND =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__BRAND")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String BRAND
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get BRAND =>
      const jni.JStringType().fromRef(_get_BRAND().object);

  static final _get_CPU_ABI =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__CPU_ABI")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String CPU_ABI
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CPU_ABI =>
      const jni.JStringType().fromRef(_get_CPU_ABI().object);

  static final _get_CPU_ABI2 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__CPU_ABI2")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String CPU_ABI2
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get CPU_ABI2 =>
      const jni.JStringType().fromRef(_get_CPU_ABI2().object);

  static final _get_DEVICE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__DEVICE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String DEVICE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DEVICE =>
      const jni.JStringType().fromRef(_get_DEVICE().object);

  static final _get_DISPLAY =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__DISPLAY")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String DISPLAY
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get DISPLAY =>
      const jni.JStringType().fromRef(_get_DISPLAY().object);

  static final _get_FINGERPRINT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__FINGERPRINT")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String FINGERPRINT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get FINGERPRINT =>
      const jni.JStringType().fromRef(_get_FINGERPRINT().object);

  static final _get_HARDWARE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__HARDWARE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String HARDWARE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HARDWARE =>
      const jni.JStringType().fromRef(_get_HARDWARE().object);

  static final _get_HOST =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__HOST")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String HOST
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get HOST =>
      const jni.JStringType().fromRef(_get_HOST().object);

  static final _get_ID =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__ID")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String ID
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ID =>
      const jni.JStringType().fromRef(_get_ID().object);

  static final _get_MANUFACTURER =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__MANUFACTURER")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String MANUFACTURER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MANUFACTURER =>
      const jni.JStringType().fromRef(_get_MANUFACTURER().object);

  static final _get_MODEL =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__MODEL")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String MODEL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get MODEL =>
      const jni.JStringType().fromRef(_get_MODEL().object);

  static final _get_ODM_SKU =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__ODM_SKU")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String ODM_SKU
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get ODM_SKU =>
      const jni.JStringType().fromRef(_get_ODM_SKU().object);

  static final _get_PRODUCT =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__PRODUCT")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String PRODUCT
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get PRODUCT =>
      const jni.JStringType().fromRef(_get_PRODUCT().object);

  static final _get_RADIO =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__RADIO")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String RADIO
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get RADIO =>
      const jni.JStringType().fromRef(_get_RADIO().object);

  static final _get_SERIAL =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SERIAL")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String SERIAL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SERIAL =>
      const jni.JStringType().fromRef(_get_SERIAL().object);

  static final _get_SKU =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__SKU")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String SKU
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SKU =>
      const jni.JStringType().fromRef(_get_SKU().object);

  static final _get_SOC_MANUFACTURER =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SOC_MANUFACTURER")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String SOC_MANUFACTURER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SOC_MANUFACTURER =>
      const jni.JStringType().fromRef(_get_SOC_MANUFACTURER().object);

  static final _get_SOC_MODEL =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SOC_MODEL")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String SOC_MODEL
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get SOC_MODEL =>
      const jni.JStringType().fromRef(_get_SOC_MODEL().object);

  static final _get_SUPPORTED_32_BIT_ABIS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SUPPORTED_32_BIT_ABIS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String[] SUPPORTED_32_BIT_ABIS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JString> get SUPPORTED_32_BIT_ABIS =>
      const jni.JArrayType(jni.JStringType())
          .fromRef(_get_SUPPORTED_32_BIT_ABIS().object);

  static final _get_SUPPORTED_64_BIT_ABIS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SUPPORTED_64_BIT_ABIS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String[] SUPPORTED_64_BIT_ABIS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JString> get SUPPORTED_64_BIT_ABIS =>
      const jni.JArrayType(jni.JStringType())
          .fromRef(_get_SUPPORTED_64_BIT_ABIS().object);

  static final _get_SUPPORTED_ABIS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Build__SUPPORTED_ABIS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String[] SUPPORTED_ABIS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<jni.JString> get SUPPORTED_ABIS =>
      const jni.JArrayType(jni.JStringType())
          .fromRef(_get_SUPPORTED_ABIS().object);

  static final _get_TAGS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__TAGS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String TAGS
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TAGS =>
      const jni.JStringType().fromRef(_get_TAGS().object);

  static final _get_TIME =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__TIME")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final long TIME
  static int get TIME => _get_TIME().long;

  static final _get_TYPE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__TYPE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String TYPE
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get TYPE =>
      const jni.JStringType().fromRef(_get_TYPE().object);

  /// from: static public final java.lang.String UNKNOWN
  static const UNKNOWN = r"""unknown""";

  static final _get_USER =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Build__USER")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final java.lang.String USER
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString get USER =>
      const jni.JStringType().fromRef(_get_USER().object);

  static final _new0 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Build__new0")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Build() {
    return Build.fromRef(_new0().object);
  }

  static final _getSerial =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Build__getSerial")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String getSerial()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getSerial() {
    return const jni.JStringType().fromRef(_getSerial().object);
  }

  static final _getFingerprintedPartitions =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Build__getFingerprintedPartitions")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.List getFingerprintedPartitions()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JList<Build_Partition> getFingerprintedPartitions() {
    return const jni.JListType($Build_PartitionType())
        .fromRef(_getFingerprintedPartitions().object);
  }

  static final _getRadioVersion =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Build__getRadioVersion")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.lang.String getRadioVersion()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString getRadioVersion() {
    return const jni.JStringType().fromRef(_getRadioVersion().object);
  }
}

final class $BuildType extends jni.JObjType<Build> {
  const $BuildType();

  @override
  String get signature => r"Landroid/os/Build;";

  @override
  Build fromRef(jni.JObjectPtr ref) => Build.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BuildType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BuildType) && other is $BuildType;
  }
}
