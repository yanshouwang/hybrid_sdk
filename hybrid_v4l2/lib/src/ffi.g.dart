// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `v4l2`.
///
class LibV4L2 {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibV4L2(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibV4L2.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int fcntl(
    int __fd,
    int __cmd,
  ) {
    return _fcntl(
      __fd,
      __cmd,
    );
  }

  late final _fcntlPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('fcntl');
  late final _fcntl = _fcntlPtr.asFunction<int Function(int, int)>();

  int open(
    ffi.Pointer<ffi.Char> __file,
    int __oflag,
    int va,
  ) {
    return _open(
      __file,
      __oflag,
      va,
    );
  }

  late final _openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.VarArgs<(ffi.Int,)>)>>('open');
  late final _open =
      _openPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int openat(
    int __fd,
    ffi.Pointer<ffi.Char> __file,
    int __oflag,
    int va,
  ) {
    return _openat(
      __fd,
      __file,
      __oflag,
      va,
    );
  }

  late final _openatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.VarArgs<(ffi.Int,)>)>>('openat');
  late final _openat = _openatPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  int creat(
    ffi.Pointer<ffi.Char> __file,
    int __mode,
  ) {
    return _creat(
      __file,
      __mode,
    );
  }

  late final _creatPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, mode_t)>>(
      'creat');
  late final _creat =
      _creatPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int lockf(
    int __fd,
    int __cmd,
    int __len,
  ) {
    return _lockf(
      __fd,
      __cmd,
      __len,
    );
  }

  late final _lockfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, off_t)>>(
          'lockf');
  late final _lockf = _lockfPtr.asFunction<int Function(int, int, int)>();

  int posix_fadvise(
    int __fd,
    int __offset,
    int __len,
    int __advise,
  ) {
    return _posix_fadvise(
      __fd,
      __offset,
      __len,
      __advise,
    );
  }

  late final _posix_fadvisePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, off_t, off_t, ffi.Int)>>(
      'posix_fadvise');
  late final _posix_fadvise =
      _posix_fadvisePtr.asFunction<int Function(int, int, int, int)>();

  int posix_fallocate(
    int __fd,
    int __offset,
    int __len,
  ) {
    return _posix_fallocate(
      __fd,
      __offset,
      __len,
    );
  }

  late final _posix_fallocatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, off_t, off_t)>>(
          'posix_fallocate');
  late final _posix_fallocate =
      _posix_fallocatePtr.asFunction<int Function(int, int, int)>();

  /// Test for access to NAME using the real UID and real GID.
  int access(
    ffi.Pointer<ffi.Char> __name,
    int __type,
  ) {
    return _access(
      __name,
      __type,
    );
  }

  late final _accessPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'access');
  late final _access =
      _accessPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Test for access to FILE relative to the directory FD is open on.
  /// If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
  /// otherwise use real IDs like `access'.
  int faccessat(
    int __fd,
    ffi.Pointer<ffi.Char> __file,
    int __type,
    int __flag,
  ) {
    return _faccessat(
      __fd,
      __file,
      __type,
      __flag,
    );
  }

  late final _faccessatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int)>>('faccessat');
  late final _faccessat = _faccessatPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  int lseek(
    int __fd,
    int __offset,
    int __whence,
  ) {
    return _lseek(
      __fd,
      __offset,
      __whence,
    );
  }

  late final _lseekPtr =
      _lookup<ffi.NativeFunction<__off_t Function(ffi.Int, __off_t, ffi.Int)>>(
          'lseek');
  late final _lseek = _lseekPtr.asFunction<int Function(int, int, int)>();

  /// Close the file descriptor FD.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int close(
    int __fd,
  ) {
    return _close(
      __fd,
    );
  }

  late final _closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('close');
  late final _close = _closePtr.asFunction<int Function(int)>();

  /// Close all open file descriptors greater than or equal to LOWFD.
  /// Negative LOWFD is clamped to 0.
  void closefrom(
    int __lowfd,
  ) {
    return _closefrom(
      __lowfd,
    );
  }

  late final _closefromPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('closefrom');
  late final _closefrom = _closefromPtr.asFunction<void Function(int)>();

  /// Read NBYTES into BUF from FD.  Return the
  /// number read, -1 for errors or 0 for EOF.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int read(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _read(
      __fd,
      __buf,
      __nbytes,
    );
  }

  late final _readPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('read');
  late final _read =
      _readPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Write N bytes of BUF to FD.  Return the number written, or -1.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int write(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __n,
  ) {
    return _write(
      __fd,
      __buf,
      __n,
    );
  }

  late final _writePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('write');
  late final _write =
      _writePtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Read NBYTES into BUF from FD at the given position OFFSET without
  /// changing the file pointer.  Return the number read, -1 for errors
  /// or 0 for EOF.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int pread(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
    int __offset,
  ) {
    return _pread(
      __fd,
      __buf,
      __nbytes,
      __offset,
    );
  }

  late final _preadPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, __off_t)>>('pread');
  late final _pread = _preadPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// Write N bytes of BUF to FD at the given position OFFSET without
  /// changing the file pointer.  Return the number written, or -1.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int pwrite(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __n,
    int __offset,
  ) {
    return _pwrite(
      __fd,
      __buf,
      __n,
      __offset,
    );
  }

  late final _pwritePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, __off_t)>>('pwrite');
  late final _pwrite = _pwritePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// Create a one-way communication channel (pipe).
  /// If successful, two file descriptors are stored in PIPEDES;
  /// bytes written on PIPEDES[1] can be read from PIPEDES[0].
  /// Returns 0 if successful, -1 if not.
  int pipe(
    ffi.Pointer<ffi.Int> __pipedes,
  ) {
    return _pipe(
      __pipedes,
    );
  }

  late final _pipePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>)>>(
          'pipe');
  late final _pipe = _pipePtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  /// Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
  /// If SECONDS is zero, any currently scheduled alarm will be cancelled.
  /// The function returns the number of seconds remaining until the last
  /// alarm scheduled would have signaled, or zero if there wasn't one.
  /// There is no return value to indicate an error, but you can set `errno'
  /// to 0 and check its value after calling `alarm', and this might tell you.
  /// The signal may come late due to processor scheduling.
  int alarm(
    int __seconds,
  ) {
    return _alarm(
      __seconds,
    );
  }

  late final _alarmPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'alarm');
  late final _alarm = _alarmPtr.asFunction<int Function(int)>();

  /// Make the process sleep for SECONDS seconds, or until a signal arrives
  /// and is not ignored.  The function returns the number of seconds less
  /// than SECONDS which it actually slept (thus zero if it slept the full time).
  /// If a signal handler does a `longjmp' or modifies the handling of the
  /// SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
  /// signal afterwards is undefined.  There is no return value to indicate
  /// error, but if `sleep' returns SECONDS, it probably didn't work.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int sleep(
    int __seconds,
  ) {
    return _sleep(
      __seconds,
    );
  }

  late final _sleepPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'sleep');
  late final _sleep = _sleepPtr.asFunction<int Function(int)>();

  /// Set an alarm to go off (generating a SIGALRM signal) in VALUE
  /// microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
  /// timer is reset to go off every INTERVAL microseconds thereafter.
  /// Returns the number of microseconds remaining before the alarm.
  int ualarm(
    int __value,
    int __interval,
  ) {
    return _ualarm(
      __value,
      __interval,
    );
  }

  late final _ualarmPtr = _lookup<
      ffi.NativeFunction<
          __useconds_t Function(__useconds_t, __useconds_t)>>('ualarm');
  late final _ualarm = _ualarmPtr.asFunction<int Function(int, int)>();

  /// Sleep USECONDS microseconds, or until a signal arrives that is not blocked
  /// or ignored.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int usleep(
    int __useconds,
  ) {
    return _usleep(
      __useconds,
    );
  }

  late final _usleepPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__useconds_t)>>('usleep');
  late final _usleep = _usleepPtr.asFunction<int Function(int)>();

  /// Suspend the process until a signal arrives.
  /// This always returns -1 and sets `errno' to EINTR.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int pause() {
    return _pause();
  }

  late final _pausePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('pause');
  late final _pause = _pausePtr.asFunction<int Function()>();

  /// Change the owner and group of FILE.
  int chown(
    ffi.Pointer<ffi.Char> __file,
    int __owner,
    int __group,
  ) {
    return _chown(
      __file,
      __owner,
      __group,
    );
  }

  late final _chownPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, __uid_t, __gid_t)>>('chown');
  late final _chown =
      _chownPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// Change the owner and group of the file that FD is open on.
  int fchown(
    int __fd,
    int __owner,
    int __group,
  ) {
    return _fchown(
      __fd,
      __owner,
      __group,
    );
  }

  late final _fchownPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, __uid_t, __gid_t)>>(
          'fchown');
  late final _fchown = _fchownPtr.asFunction<int Function(int, int, int)>();

  /// Change owner and group of FILE, if it is a symbolic
  /// link the ownership of the symbolic link is changed.
  int lchown(
    ffi.Pointer<ffi.Char> __file,
    int __owner,
    int __group,
  ) {
    return _lchown(
      __file,
      __owner,
      __group,
    );
  }

  late final _lchownPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, __uid_t, __gid_t)>>('lchown');
  late final _lchown =
      _lchownPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// Change the owner and group of FILE relative to the directory FD is open
  /// on.
  int fchownat(
    int __fd,
    ffi.Pointer<ffi.Char> __file,
    int __owner,
    int __group,
    int __flag,
  ) {
    return _fchownat(
      __fd,
      __file,
      __owner,
      __group,
      __flag,
    );
  }

  late final _fchownatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, __uid_t, __gid_t,
              ffi.Int)>>('fchownat');
  late final _fchownat = _fchownatPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int, int)>();

  /// Change the process's working directory to PATH.
  int chdir(
    ffi.Pointer<ffi.Char> __path,
  ) {
    return _chdir(
      __path,
    );
  }

  late final _chdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'chdir');
  late final _chdir =
      _chdirPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Change the process's working directory to the one FD is open on.
  int fchdir(
    int __fd,
  ) {
    return _fchdir(
      __fd,
    );
  }

  late final _fchdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fchdir');
  late final _fchdir = _fchdirPtr.asFunction<int Function(int)>();

  /// Get the pathname of the current working directory,
  /// and put it in SIZE bytes of BUF.  Returns NULL if the
  /// directory couldn't be determined or SIZE was too small.
  /// If successful, returns BUF.  In GNU, if BUF is NULL,
  /// an array is allocated with `malloc'; the array is SIZE
  /// bytes long, unless SIZE == 0, in which case it is as
  /// big as necessary.
  ffi.Pointer<ffi.Char> getcwd(
    ffi.Pointer<ffi.Char> __buf,
    int __size,
  ) {
    return _getcwd(
      __buf,
      __size,
    );
  }

  late final _getcwdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('getcwd');
  late final _getcwd = _getcwdPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Put the absolute pathname of the current working directory in BUF.
  /// If successful, return BUF.  If not, put an error message in
  /// BUF and return NULL.  BUF should be at least PATH_MAX bytes long.
  ffi.Pointer<ffi.Char> getwd(
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _getwd(
      __buf,
    );
  }

  late final _getwdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getwd');
  late final _getwd = _getwdPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Duplicate FD, returning a new file descriptor on the same file.
  int dup(
    int __fd,
  ) {
    return _dup(
      __fd,
    );
  }

  late final _dupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('dup');
  late final _dup = _dupPtr.asFunction<int Function(int)>();

  /// Duplicate FD to FD2, closing FD2 and making it open on the same file.
  int dup2(
    int __fd,
    int __fd2,
  ) {
    return _dup2(
      __fd,
      __fd2,
    );
  }

  late final _dup2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('dup2');
  late final _dup2 = _dup2Ptr.asFunction<int Function(int, int)>();

  /// NULL-terminated array of "NAME=VALUE" environment variables.
  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> ___environ =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('__environ');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get __environ => ___environ.value;

  set __environ(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      ___environ.value = value;

  /// Replace the current process, executing PATH with arguments ARGV and
  /// environment ENVP.  ARGV and ENVP are terminated by NULL pointers.
  int execve(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __envp,
  ) {
    return _execve(
      __path,
      __argv,
      __envp,
    );
  }

  late final _execvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execve');
  late final _execve = _execvePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Execute the file FD refers to, overlaying the running program image.
  /// ARGV and ENVP are passed to the new program, as for `execve'.
  int fexecve(
    int __fd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __envp,
  ) {
    return _fexecve(
      __fd,
      __argv,
      __envp,
    );
  }

  late final _fexecvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('fexecve');
  late final _fexecve = _fexecvePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Execute PATH with arguments ARGV and environment from `environ'.
  int execv(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
  ) {
    return _execv(
      __path,
      __argv,
    );
  }

  late final _execvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execv');
  late final _execv = _execvPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Execute PATH with all arguments after PATH until a NULL pointer,
  /// and the argument after that for environment.
  int execle(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __arg,
  ) {
    return _execle(
      __path,
      __arg,
    );
  }

  late final _execlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execle');
  late final _execle = _execlePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Execute PATH with all arguments after PATH until
  /// a NULL pointer and environment from `environ'.
  int execl(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __arg,
  ) {
    return _execl(
      __path,
      __arg,
    );
  }

  late final _execlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execl');
  late final _execl = _execlPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Execute FILE, searching in the `PATH' environment variable if it contains
  /// no slashes, with arguments ARGV and environment from `environ'.
  int execvp(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
  ) {
    return _execvp(
      __file,
      __argv,
    );
  }

  late final _execvpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execvp');
  late final _execvp = _execvpPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Execute FILE, searching in the `PATH' environment variable if
  /// it contains no slashes, with all arguments after FILE until a
  /// NULL pointer and environment from `environ'.
  int execlp(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Char> __arg,
  ) {
    return _execlp(
      __file,
      __arg,
    );
  }

  late final _execlpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execlp');
  late final _execlp = _execlpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Add INC to priority of the current process.
  int nice(
    int __inc,
  ) {
    return _nice(
      __inc,
    );
  }

  late final _nicePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('nice');
  late final _nice = _nicePtr.asFunction<int Function(int)>();

  /// Terminate program execution with the low-order 8 bits of STATUS.
  void _exit(
    int __status,
  ) {
    return __exit(
      __status,
    );
  }

  late final __exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_exit');
  late final __exit = __exitPtr.asFunction<void Function(int)>();

  /// Get file-specific configuration information about PATH.
  int pathconf(
    ffi.Pointer<ffi.Char> __path,
    int __name,
  ) {
    return _pathconf(
      __path,
      __name,
    );
  }

  late final _pathconfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>, ffi.Int)>>('pathconf');
  late final _pathconf =
      _pathconfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Get file-specific configuration about descriptor FD.
  int fpathconf(
    int __fd,
    int __name,
  ) {
    return _fpathconf(
      __fd,
      __name,
    );
  }

  late final _fpathconfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Int, ffi.Int)>>(
          'fpathconf');
  late final _fpathconf = _fpathconfPtr.asFunction<int Function(int, int)>();

  /// Get the value of the system variable NAME.
  int sysconf(
    int __name,
  ) {
    return _sysconf(
      __name,
    );
  }

  late final _sysconfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Int)>>('sysconf');
  late final _sysconf = _sysconfPtr.asFunction<int Function(int)>();

  /// Get the value of the string-valued system variable NAME.
  int confstr(
    int __name,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _confstr(
      __name,
      __buf,
      __len,
    );
  }

  late final _confstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('confstr');
  late final _confstr =
      _confstrPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Get the process ID of the calling process.
  int getpid() {
    return _getpid();
  }

  late final _getpidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function()>>('getpid');
  late final _getpid = _getpidPtr.asFunction<int Function()>();

  /// Get the process ID of the calling process's parent.
  int getppid() {
    return _getppid();
  }

  late final _getppidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function()>>('getppid');
  late final _getppid = _getppidPtr.asFunction<int Function()>();

  /// Get the process group ID of the calling process.
  int getpgrp() {
    return _getpgrp();
  }

  late final _getpgrpPtr =
      _lookup<ffi.NativeFunction<__pid_t Function()>>('getpgrp');
  late final _getpgrp = _getpgrpPtr.asFunction<int Function()>();

  /// Get the process group ID of process PID.
  int __getpgid(
    int __pid,
  ) {
    return ___getpgid(
      __pid,
    );
  }

  late final ___getpgidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function(__pid_t)>>('__getpgid');
  late final ___getpgid = ___getpgidPtr.asFunction<int Function(int)>();

  int getpgid(
    int __pid,
  ) {
    return _getpgid(
      __pid,
    );
  }

  late final _getpgidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function(__pid_t)>>('getpgid');
  late final _getpgid = _getpgidPtr.asFunction<int Function(int)>();

  /// Set the process group ID of the process matching PID to PGID.
  /// If PID is zero, the current process's process group ID is set.
  /// If PGID is zero, the process ID of the process is used.
  int setpgid(
    int __pid,
    int __pgid,
  ) {
    return _setpgid(
      __pid,
      __pgid,
    );
  }

  late final _setpgidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__pid_t, __pid_t)>>(
          'setpgid');
  late final _setpgid = _setpgidPtr.asFunction<int Function(int, int)>();

  /// Set the process group ID of the calling process to its own PID.
  /// This is exactly the same as `setpgid (0, 0)'.
  int setpgrp() {
    return _setpgrp();
  }

  late final _setpgrpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('setpgrp');
  late final _setpgrp = _setpgrpPtr.asFunction<int Function()>();

  /// Create a new session with the calling process as its leader.
  /// The process group IDs of the session and the calling process
  /// are set to the process ID of the calling process, which is returned.
  int setsid() {
    return _setsid();
  }

  late final _setsidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function()>>('setsid');
  late final _setsid = _setsidPtr.asFunction<int Function()>();

  /// Return the session ID of the given process.
  int getsid(
    int __pid,
  ) {
    return _getsid(
      __pid,
    );
  }

  late final _getsidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function(__pid_t)>>('getsid');
  late final _getsid = _getsidPtr.asFunction<int Function(int)>();

  /// Get the real user ID of the calling process.
  int getuid() {
    return _getuid();
  }

  late final _getuidPtr =
      _lookup<ffi.NativeFunction<__uid_t Function()>>('getuid');
  late final _getuid = _getuidPtr.asFunction<int Function()>();

  /// Get the effective user ID of the calling process.
  int geteuid() {
    return _geteuid();
  }

  late final _geteuidPtr =
      _lookup<ffi.NativeFunction<__uid_t Function()>>('geteuid');
  late final _geteuid = _geteuidPtr.asFunction<int Function()>();

  /// Get the real group ID of the calling process.
  int getgid() {
    return _getgid();
  }

  late final _getgidPtr =
      _lookup<ffi.NativeFunction<__gid_t Function()>>('getgid');
  late final _getgid = _getgidPtr.asFunction<int Function()>();

  /// Get the effective group ID of the calling process.
  int getegid() {
    return _getegid();
  }

  late final _getegidPtr =
      _lookup<ffi.NativeFunction<__gid_t Function()>>('getegid');
  late final _getegid = _getegidPtr.asFunction<int Function()>();

  /// If SIZE is zero, return the number of supplementary groups
  /// the calling process is in.  Otherwise, fill in the group IDs
  /// of its supplementary groups in LIST and return the number written.
  int getgroups(
    int __size,
    ffi.Pointer<__gid_t> __list,
  ) {
    return _getgroups(
      __size,
      __list,
    );
  }

  late final _getgroupsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<__gid_t>)>>(
      'getgroups');
  late final _getgroups =
      _getgroupsPtr.asFunction<int Function(int, ffi.Pointer<__gid_t>)>();

  /// Set the user ID of the calling process to UID.
  /// If the calling process is the super-user, set the real
  /// and effective user IDs, and the saved set-user-ID to UID;
  /// if not, the effective user ID is set to UID.
  int setuid(
    int __uid,
  ) {
    return _setuid(
      __uid,
    );
  }

  late final _setuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__uid_t)>>('setuid');
  late final _setuid = _setuidPtr.asFunction<int Function(int)>();

  /// Set the real user ID of the calling process to RUID,
  /// and the effective user ID of the calling process to EUID.
  int setreuid(
    int __ruid,
    int __euid,
  ) {
    return _setreuid(
      __ruid,
      __euid,
    );
  }

  late final _setreuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__uid_t, __uid_t)>>(
          'setreuid');
  late final _setreuid = _setreuidPtr.asFunction<int Function(int, int)>();

  /// Set the effective user ID of the calling process to UID.
  int seteuid(
    int __uid,
  ) {
    return _seteuid(
      __uid,
    );
  }

  late final _seteuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__uid_t)>>('seteuid');
  late final _seteuid = _seteuidPtr.asFunction<int Function(int)>();

  /// Set the group ID of the calling process to GID.
  /// If the calling process is the super-user, set the real
  /// and effective group IDs, and the saved set-group-ID to GID;
  /// if not, the effective group ID is set to GID.
  int setgid(
    int __gid,
  ) {
    return _setgid(
      __gid,
    );
  }

  late final _setgidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__gid_t)>>('setgid');
  late final _setgid = _setgidPtr.asFunction<int Function(int)>();

  /// Set the real group ID of the calling process to RGID,
  /// and the effective group ID of the calling process to EGID.
  int setregid(
    int __rgid,
    int __egid,
  ) {
    return _setregid(
      __rgid,
      __egid,
    );
  }

  late final _setregidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__gid_t, __gid_t)>>(
          'setregid');
  late final _setregid = _setregidPtr.asFunction<int Function(int, int)>();

  /// Set the effective group ID of the calling process to GID.
  int setegid(
    int __gid,
  ) {
    return _setegid(
      __gid,
    );
  }

  late final _setegidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__gid_t)>>('setegid');
  late final _setegid = _setegidPtr.asFunction<int Function(int)>();

  /// Clone the calling process, creating an exact copy.
  /// Return -1 for errors, 0 to the new process,
  /// and the process ID of the new process to the old process.
  int fork() {
    return _fork();
  }

  late final _forkPtr = _lookup<ffi.NativeFunction<__pid_t Function()>>('fork');
  late final _fork = _forkPtr.asFunction<int Function()>();

  /// Clone the calling process, but without copying the whole address space.
  /// The calling process is suspended until the new process exits or is
  /// replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
  /// and the process ID of the new process to the old process.
  int vfork() {
    return _vfork();
  }

  late final _vforkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('vfork');
  late final _vfork = _vforkPtr.asFunction<int Function()>();

  /// Return the pathname of the terminal FD is open on, or NULL on errors.
  /// The returned storage is good only until the next call to this function.
  ffi.Pointer<ffi.Char> ttyname(
    int __fd,
  ) {
    return _ttyname(
      __fd,
    );
  }

  late final _ttynamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ttyname');
  late final _ttyname =
      _ttynamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Store at most BUFLEN characters of the pathname of the terminal FD is
  /// open on in BUF.  Return 0 on success, otherwise an error number.
  int ttyname_r(
    int __fd,
    ffi.Pointer<ffi.Char> __buf,
    int __buflen,
  ) {
    return _ttyname_r(
      __fd,
      __buf,
      __buflen,
    );
  }

  late final _ttyname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ttyname_r');
  late final _ttyname_r =
      _ttyname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Return 1 if FD is a valid descriptor associated
  /// with a terminal, zero if not.
  int isatty(
    int __fd,
  ) {
    return _isatty(
      __fd,
    );
  }

  late final _isattyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('isatty');
  late final _isatty = _isattyPtr.asFunction<int Function(int)>();

  /// Return the index into the active-logins file (utmp) for
  /// the controlling terminal.
  int ttyslot() {
    return _ttyslot();
  }

  late final _ttyslotPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('ttyslot');
  late final _ttyslot = _ttyslotPtr.asFunction<int Function()>();

  /// Make a link to FROM named TO.
  int link(
    ffi.Pointer<ffi.Char> __from,
    ffi.Pointer<ffi.Char> __to,
  ) {
    return _link(
      __from,
      __to,
    );
  }

  late final _linkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('link');
  late final _link = _linkPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Like link but relative paths in TO and FROM are interpreted relative
  /// to FROMFD and TOFD respectively.
  int linkat(
    int __fromfd,
    ffi.Pointer<ffi.Char> __from,
    int __tofd,
    ffi.Pointer<ffi.Char> __to,
    int __flags,
  ) {
    return _linkat(
      __fromfd,
      __from,
      __tofd,
      __to,
      __flags,
    );
  }

  late final _linkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('linkat');
  late final _linkat = _linkatPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  /// Make a symbolic link to FROM named TO.
  int symlink(
    ffi.Pointer<ffi.Char> __from,
    ffi.Pointer<ffi.Char> __to,
  ) {
    return _symlink(
      __from,
      __to,
    );
  }

  late final _symlinkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('symlink');
  late final _symlink = _symlinkPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Read the contents of the symbolic link PATH into no more than
  /// LEN bytes of BUF.  The contents are not null-terminated.
  /// Returns the number of characters read, or -1 for errors.
  int readlink(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _readlink(
      __path,
      __buf,
      __len,
    );
  }

  late final _readlinkPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('readlink');
  late final _readlink = _readlinkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Like symlink but a relative path in TO is interpreted relative to TOFD.
  int symlinkat(
    ffi.Pointer<ffi.Char> __from,
    int __tofd,
    ffi.Pointer<ffi.Char> __to,
  ) {
    return _symlinkat(
      __from,
      __tofd,
      __to,
    );
  }

  late final _symlinkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('symlinkat');
  late final _symlinkat = _symlinkatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Like readlink but a relative PATH is interpreted relative to FD.
  int readlinkat(
    int __fd,
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _readlinkat(
      __fd,
      __path,
      __buf,
      __len,
    );
  }

  late final _readlinkatPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('readlinkat');
  late final _readlinkat = _readlinkatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Remove the link NAME.
  int unlink(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _unlink(
      __name,
    );
  }

  late final _unlinkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unlink');
  late final _unlink =
      _unlinkPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Remove the link NAME relative to FD.
  int unlinkat(
    int __fd,
    ffi.Pointer<ffi.Char> __name,
    int __flag,
  ) {
    return _unlinkat(
      __fd,
      __name,
      __flag,
    );
  }

  late final _unlinkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('unlinkat');
  late final _unlinkat =
      _unlinkatPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Remove the directory PATH.
  int rmdir(
    ffi.Pointer<ffi.Char> __path,
  ) {
    return _rmdir(
      __path,
    );
  }

  late final _rmdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rmdir');
  late final _rmdir =
      _rmdirPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Return the foreground process group ID of FD.
  int tcgetpgrp(
    int __fd,
  ) {
    return _tcgetpgrp(
      __fd,
    );
  }

  late final _tcgetpgrpPtr =
      _lookup<ffi.NativeFunction<__pid_t Function(ffi.Int)>>('tcgetpgrp');
  late final _tcgetpgrp = _tcgetpgrpPtr.asFunction<int Function(int)>();

  /// Set the foreground process group ID of FD set PGRP_ID.
  int tcsetpgrp(
    int __fd,
    int __pgrp_id,
  ) {
    return _tcsetpgrp(
      __fd,
      __pgrp_id,
    );
  }

  late final _tcsetpgrpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, __pid_t)>>(
          'tcsetpgrp');
  late final _tcsetpgrp = _tcsetpgrpPtr.asFunction<int Function(int, int)>();

  /// Return the login name of the user.
  ///
  /// This function is a possible cancellation point and therefore not
  /// marked with __THROW.
  ffi.Pointer<ffi.Char> getlogin() {
    return _getlogin();
  }

  late final _getloginPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>('getlogin');
  late final _getlogin =
      _getloginPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return at most NAME_LEN characters of the login name of the user in NAME.
  /// If it cannot be determined or some other error occurred, return the error
  /// code.  Otherwise return 0.
  ///
  /// This function is a possible cancellation point and therefore not
  /// marked with __THROW.
  int getlogin_r(
    ffi.Pointer<ffi.Char> __name,
    int __name_len,
  ) {
    return _getlogin_r(
      __name,
      __name_len,
    );
  }

  late final _getlogin_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('getlogin_r');
  late final _getlogin_r =
      _getlogin_rPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Set the login name returned by `getlogin'.
  int setlogin(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _setlogin(
      __name,
    );
  }

  late final _setloginPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'setlogin');
  late final _setlogin =
      _setloginPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Put the name of the current host in no more than LEN bytes of NAME.
  /// The result is null-terminated if LEN is large enough for the full
  /// name and the terminator.
  int gethostname(
    ffi.Pointer<ffi.Char> __name,
    int __len,
  ) {
    return _gethostname(
      __name,
      __len,
    );
  }

  late final _gethostnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('gethostname');
  late final _gethostname =
      _gethostnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Set the name of the current host to NAME, which is LEN bytes long.
  /// This call is restricted to the super-user.
  int sethostname(
    ffi.Pointer<ffi.Char> __name,
    int __len,
  ) {
    return _sethostname(
      __name,
      __len,
    );
  }

  late final _sethostnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('sethostname');
  late final _sethostname =
      _sethostnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Set the current machine's Internet number to ID.
  /// This call is restricted to the super-user.
  int sethostid(
    int __id,
  ) {
    return _sethostid(
      __id,
    );
  }

  late final _sethostidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('sethostid');
  late final _sethostid = _sethostidPtr.asFunction<int Function(int)>();

  /// Get and set the NIS (aka YP) domain name, if any.
  /// Called just like `gethostname' and `sethostname'.
  /// The NIS domain name is usually the empty string when not using NIS.
  int getdomainname(
    ffi.Pointer<ffi.Char> __name,
    int __len,
  ) {
    return _getdomainname(
      __name,
      __len,
    );
  }

  late final _getdomainnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('getdomainname');
  late final _getdomainname =
      _getdomainnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int setdomainname(
    ffi.Pointer<ffi.Char> __name,
    int __len,
  ) {
    return _setdomainname(
      __name,
      __len,
    );
  }

  late final _setdomainnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('setdomainname');
  late final _setdomainname =
      _setdomainnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Revoke access permissions to all processes currently communicating
  /// with the control terminal, and then send a SIGHUP signal to the process
  /// group of the control terminal.
  int vhangup() {
    return _vhangup();
  }

  late final _vhangupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('vhangup');
  late final _vhangup = _vhangupPtr.asFunction<int Function()>();

  /// Revoke the access of all descriptors currently open on FILE.
  int revoke(
    ffi.Pointer<ffi.Char> __file,
  ) {
    return _revoke(
      __file,
    );
  }

  late final _revokePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'revoke');
  late final _revoke =
      _revokePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Enable statistical profiling, writing samples of the PC into at most
  /// SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
  /// is enabled, the system examines the user PC and increments
  /// SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
  /// disable profiling.  Returns zero on success, -1 on error.
  int profil(
    ffi.Pointer<ffi.UnsignedShort> __sample_buffer,
    int __size,
    int __offset,
    int __scale,
  ) {
    return _profil(
      __sample_buffer,
      __size,
      __offset,
      __scale,
    );
  }

  late final _profilPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Size, ffi.Size,
              ffi.UnsignedInt)>>('profil');
  late final _profil = _profilPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, int, int, int)>();

  /// Turn accounting on if NAME is an existing file.  The system will then write
  /// a record for each process as it terminates, to this file.  If NAME is NULL,
  /// turn accounting off.  This call is restricted to the super-user.
  int acct(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _acct(
      __name,
    );
  }

  late final _acctPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'acct');
  late final _acct = _acctPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Successive calls return the shells listed in `/etc/shells'.
  ffi.Pointer<ffi.Char> getusershell() {
    return _getusershell();
  }

  late final _getusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getusershell');
  late final _getusershell =
      _getusershellPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void endusershell() {
    return _endusershell();
  }

  late final _endusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('endusershell');
  late final _endusershell = _endusershellPtr.asFunction<void Function()>();

  void setusershell() {
    return _setusershell();
  }

  late final _setusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('setusershell');
  late final _setusershell = _setusershellPtr.asFunction<void Function()>();

  /// Put the program in the background, and dissociate from the controlling
  /// terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
  /// redirects stdin, stdout, and stderr to /dev/null.
  int daemon(
    int __nochdir,
    int __noclose,
  ) {
    return _daemon(
      __nochdir,
      __noclose,
    );
  }

  late final _daemonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('daemon');
  late final _daemon = _daemonPtr.asFunction<int Function(int, int)>();

  /// Make PATH be the root directory (the starting point for absolute paths).
  /// This call is restricted to the super-user.
  int chroot(
    ffi.Pointer<ffi.Char> __path,
  ) {
    return _chroot(
      __path,
    );
  }

  late final _chrootPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'chroot');
  late final _chroot =
      _chrootPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Prompt with PROMPT and read a string from the terminal without echoing.
  /// Uses /dev/tty if possible; otherwise stderr and stdin.
  ffi.Pointer<ffi.Char> getpass(
    ffi.Pointer<ffi.Char> __prompt,
  ) {
    return _getpass(
      __prompt,
    );
  }

  late final _getpassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getpass');
  late final _getpass = _getpassPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Make all changes done to FD actually appear on disk.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int fsync(
    int __fd,
  ) {
    return _fsync(
      __fd,
    );
  }

  late final _fsyncPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fsync');
  late final _fsync = _fsyncPtr.asFunction<int Function(int)>();

  /// Return identifier for the current host.
  int gethostid() {
    return _gethostid();
  }

  late final _gethostidPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('gethostid');
  late final _gethostid = _gethostidPtr.asFunction<int Function()>();

  /// Make all changes done to all files actually appear on disk.
  void sync1() {
    return _sync1();
  }

  late final _sync1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sync');
  late final _sync1 = _sync1Ptr.asFunction<void Function()>();

  /// Return the number of bytes in a page.  This is the system's page size,
  /// which is not necessarily the same as the hardware page size.
  int getpagesize() {
    return _getpagesize();
  }

  late final _getpagesizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getpagesize');
  late final _getpagesize = _getpagesizePtr.asFunction<int Function()>();

  /// Return the maximum number of file descriptors
  /// the current process could possibly have.
  int getdtablesize() {
    return _getdtablesize();
  }

  late final _getdtablesizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getdtablesize');
  late final _getdtablesize = _getdtablesizePtr.asFunction<int Function()>();

  int truncate(
    ffi.Pointer<ffi.Char> __file,
    int __length,
  ) {
    return _truncate(
      __file,
      __length,
    );
  }

  late final _truncatePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, __off_t)>>(
      'truncate');
  late final _truncate =
      _truncatePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int ftruncate(
    int __fd,
    int __length,
  ) {
    return _ftruncate(
      __fd,
      __length,
    );
  }

  late final _ftruncatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, __off_t)>>(
          'ftruncate');
  late final _ftruncate = _ftruncatePtr.asFunction<int Function(int, int)>();

  /// Set the end of accessible data space (aka "the break") to ADDR.
  /// Returns zero on success and -1 for errors (with errno set).
  int brk(
    ffi.Pointer<ffi.Void> __addr,
  ) {
    return _brk(
      __addr,
    );
  }

  late final _brkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>(
          'brk');
  late final _brk = _brkPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// Increase or decrease the end of accessible data space by DELTA bytes.
  /// If successful, returns the address the previous end of data space
  /// (i.e. the beginning of the new space, if DELTA > 0);
  /// returns (void *) -1 for errors (with errno set).
  ffi.Pointer<ffi.Void> sbrk(
    int __delta,
  ) {
    return _sbrk(
      __delta,
    );
  }

  late final _sbrkPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.IntPtr)>>(
          'sbrk');
  late final _sbrk = _sbrkPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Invoke `system call' number SYSNO, passing it the remaining arguments.
  /// This is completely system-dependent, and not often useful.
  ///
  /// In Unix, `syscall' sets `errno' for all errors and most calls return -1
  /// for errors; in many systems you cannot pass arguments or get return
  /// values for all system calls (`pipe', `fork', and `getppid' typically
  /// among them).
  ///
  /// In Mach, all system calls take normal arguments and always return an
  /// error code (zero for success).
  int syscall(
    int __sysno,
  ) {
    return _syscall(
      __sysno,
    );
  }

  late final _syscallPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('syscall');
  late final _syscall = _syscallPtr.asFunction<int Function(int)>();

  /// Synchronize at least the data part of a file with the underlying
  /// media.
  int fdatasync(
    int __fildes,
  ) {
    return _fdatasync(
      __fildes,
    );
  }

  late final _fdatasyncPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fdatasync');
  late final _fdatasync = _fdatasyncPtr.asFunction<int Function(int)>();

  /// One-way hash PHRASE, returning a string suitable for storage in the
  /// user database.  SALT selects the one-way function to use, and
  /// ensures that no two users' hashes are the same, even if they use
  /// the same passphrase.  The return value points to static storage
  /// which will be overwritten by the next call to crypt.
  ///
  /// This declaration is deprecated; applications should include
  /// <crypt.h> instead.
  ffi.Pointer<ffi.Char> crypt(
    ffi.Pointer<ffi.Char> __key,
    ffi.Pointer<ffi.Char> __salt,
  ) {
    return _crypt(
      __key,
      __salt,
    );
  }

  late final _cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('crypt');
  late final _crypt = _cryptPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on
  /// success or -1 on error.
  int getentropy(
    ffi.Pointer<ffi.Void> __buffer,
    int __length,
  ) {
    return _getentropy(
      __buffer,
      __length,
    );
  }

  late final _getentropyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Size)>>('getentropy');
  late final _getentropy =
      _getentropyPtr.asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  int ioctl(
    int __fd,
    int __request,
    ffi.Pointer<v4l2_capability> va,
  ) {
    return _ioctl(
      __fd,
      __request,
      va,
    );
  }

  late final _ioctlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.UnsignedLong,
              ffi.VarArgs<(ffi.Pointer<v4l2_capability>,)>)>>('ioctl');
  late final _ioctl = _ioctlPtr
      .asFunction<int Function(int, int, ffi.Pointer<v4l2_capability>)>();
}

typedef mode_t = __mode_t;
typedef __mode_t = ffi.UnsignedInt;
typedef Dart__mode_t = int;
typedef off_t = __off_t;
typedef __off_t = ffi.Long;
typedef Dart__off_t = int;
typedef ssize_t = __ssize_t;
typedef __ssize_t = ffi.Long;
typedef Dart__ssize_t = int;
typedef __useconds_t = ffi.UnsignedInt;
typedef Dart__useconds_t = int;
typedef __uid_t = ffi.UnsignedInt;
typedef Dart__uid_t = int;
typedef __gid_t = ffi.UnsignedInt;
typedef Dart__gid_t = int;
typedef __pid_t = ffi.Int;
typedef Dart__pid_t = int;

final class f_owner_ex extends ffi.Struct {
  @ffi.Int()
  external int type;

  @__kernel_pid_t()
  external int pid;
}

typedef __kernel_pid_t = ffi.Int;
typedef Dart__kernel_pid_t = int;

final class flock extends ffi.Struct {
  @ffi.Short()
  external int l_type;

  @ffi.Short()
  external int l_whence;

  @__kernel_off_t()
  external int l_start;

  @__kernel_off_t()
  external int l_len;

  @__kernel_pid_t()
  external int l_pid;
}

typedef __kernel_off_t = __kernel_long_t;
typedef __kernel_long_t = ffi.Long;
typedef Dart__kernel_long_t = int;

final class flock64 extends ffi.Struct {
  @ffi.Short()
  external int l_type;

  @ffi.Short()
  external int l_whence;

  @__kernel_loff_t()
  external int l_start;

  @__kernel_loff_t()
  external int l_len;

  @__kernel_pid_t()
  external int l_pid;
}

typedef __kernel_loff_t = ffi.LongLong;
typedef Dart__kernel_loff_t = int;

/// E N U M S
enum v4l2_field {
  /// driver can choose from none,
  /// top, bottom, interlaced
  /// depending on whatever it thinks
  /// is approximate ...
  V4L2_FIELD_ANY(0),

  /// this device has no fields ...
  V4L2_FIELD_NONE(1),

  /// top field only
  V4L2_FIELD_TOP(2),

  /// bottom field only
  V4L2_FIELD_BOTTOM(3),

  /// both fields interlaced
  V4L2_FIELD_INTERLACED(4),

  /// both fields sequential into one
  /// buffer, top-bottom order
  V4L2_FIELD_SEQ_TB(5),

  /// same as above + bottom-top order
  V4L2_FIELD_SEQ_BT(6),

  /// both fields alternating into
  /// separate buffers
  V4L2_FIELD_ALTERNATE(7),

  /// both fields interlaced, top field
  /// first and the top field is
  /// transmitted first
  V4L2_FIELD_INTERLACED_TB(8),

  /// both fields interlaced, top field
  /// first and the bottom field is
  /// transmitted first
  V4L2_FIELD_INTERLACED_BT(9);

  final int value;
  const v4l2_field(this.value);

  static v4l2_field fromValue(int value) => switch (value) {
        0 => V4L2_FIELD_ANY,
        1 => V4L2_FIELD_NONE,
        2 => V4L2_FIELD_TOP,
        3 => V4L2_FIELD_BOTTOM,
        4 => V4L2_FIELD_INTERLACED,
        5 => V4L2_FIELD_SEQ_TB,
        6 => V4L2_FIELD_SEQ_BT,
        7 => V4L2_FIELD_ALTERNATE,
        8 => V4L2_FIELD_INTERLACED_TB,
        9 => V4L2_FIELD_INTERLACED_BT,
        _ => throw ArgumentError("Unknown value for v4l2_field: $value"),
      };
}

enum v4l2_buf_type {
  V4L2_BUF_TYPE_VIDEO_CAPTURE(1),
  V4L2_BUF_TYPE_VIDEO_OUTPUT(2),
  V4L2_BUF_TYPE_VIDEO_OVERLAY(3),
  V4L2_BUF_TYPE_VBI_CAPTURE(4),
  V4L2_BUF_TYPE_VBI_OUTPUT(5),
  V4L2_BUF_TYPE_SLICED_VBI_CAPTURE(6),
  V4L2_BUF_TYPE_SLICED_VBI_OUTPUT(7),
  V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY(8),
  V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE(9),
  V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE(10),
  V4L2_BUF_TYPE_SDR_CAPTURE(11),
  V4L2_BUF_TYPE_SDR_OUTPUT(12),
  V4L2_BUF_TYPE_META_CAPTURE(13),
  V4L2_BUF_TYPE_META_OUTPUT(14),

  /// Deprecated, do not use
  V4L2_BUF_TYPE_PRIVATE(128);

  final int value;
  const v4l2_buf_type(this.value);

  static v4l2_buf_type fromValue(int value) => switch (value) {
        1 => V4L2_BUF_TYPE_VIDEO_CAPTURE,
        2 => V4L2_BUF_TYPE_VIDEO_OUTPUT,
        3 => V4L2_BUF_TYPE_VIDEO_OVERLAY,
        4 => V4L2_BUF_TYPE_VBI_CAPTURE,
        5 => V4L2_BUF_TYPE_VBI_OUTPUT,
        6 => V4L2_BUF_TYPE_SLICED_VBI_CAPTURE,
        7 => V4L2_BUF_TYPE_SLICED_VBI_OUTPUT,
        8 => V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY,
        9 => V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
        10 => V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
        11 => V4L2_BUF_TYPE_SDR_CAPTURE,
        12 => V4L2_BUF_TYPE_SDR_OUTPUT,
        13 => V4L2_BUF_TYPE_META_CAPTURE,
        14 => V4L2_BUF_TYPE_META_OUTPUT,
        128 => V4L2_BUF_TYPE_PRIVATE,
        _ => throw ArgumentError("Unknown value for v4l2_buf_type: $value"),
      };
}

enum v4l2_tuner_type {
  V4L2_TUNER_RADIO(1),
  V4L2_TUNER_ANALOG_TV(2),
  V4L2_TUNER_DIGITAL_TV(3),
  V4L2_TUNER_SDR(4),
  V4L2_TUNER_RF(5);

  final int value;
  const v4l2_tuner_type(this.value);

  static v4l2_tuner_type fromValue(int value) => switch (value) {
        1 => V4L2_TUNER_RADIO,
        2 => V4L2_TUNER_ANALOG_TV,
        3 => V4L2_TUNER_DIGITAL_TV,
        4 => V4L2_TUNER_SDR,
        5 => V4L2_TUNER_RF,
        _ => throw ArgumentError("Unknown value for v4l2_tuner_type: $value"),
      };
}

enum v4l2_memory {
  V4L2_MEMORY_MMAP(1),
  V4L2_MEMORY_USERPTR(2),
  V4L2_MEMORY_OVERLAY(3),
  V4L2_MEMORY_DMABUF(4);

  final int value;
  const v4l2_memory(this.value);

  static v4l2_memory fromValue(int value) => switch (value) {
        1 => V4L2_MEMORY_MMAP,
        2 => V4L2_MEMORY_USERPTR,
        3 => V4L2_MEMORY_OVERLAY,
        4 => V4L2_MEMORY_DMABUF,
        _ => throw ArgumentError("Unknown value for v4l2_memory: $value"),
      };
}

/// see also http://vektor.theorem.ca/graphics/ycbcr/
enum v4l2_colorspace {
  /// Default colorspace, i.e. let the driver figure it out.
  /// Can only be used with video capture.
  V4L2_COLORSPACE_DEFAULT(0),

  /// SMPTE 170M: used for broadcast NTSC/PAL SDTV
  V4L2_COLORSPACE_SMPTE170M(1),

  /// Obsolete pre-1998 SMPTE 240M HDTV standard, superseded by Rec 709
  V4L2_COLORSPACE_SMPTE240M(2),

  /// Rec.709: used for HDTV
  V4L2_COLORSPACE_REC709(3),

  /// Deprecated, do not use. No driver will ever return this. This was
  /// based on a misunderstanding of the bt878 datasheet.
  V4L2_COLORSPACE_BT878(4),

  /// NTSC 1953 colorspace. This only makes sense when dealing with
  /// really, really old NTSC recordings. Superseded by SMPTE 170M.
  V4L2_COLORSPACE_470_SYSTEM_M(5),

  /// EBU Tech 3213 PAL/SECAM colorspace.
  V4L2_COLORSPACE_470_SYSTEM_BG(6),

  /// Effectively shorthand for V4L2_COLORSPACE_SRGB, V4L2_YCBCR_ENC_601
  /// and V4L2_QUANTIZATION_FULL_RANGE. To be used for (Motion-)JPEG.
  V4L2_COLORSPACE_JPEG(7),

  /// For RGB colorspaces such as produces by most webcams.
  V4L2_COLORSPACE_SRGB(8),

  /// opRGB colorspace
  V4L2_COLORSPACE_OPRGB(9),

  /// BT.2020 colorspace, used for UHDTV.
  V4L2_COLORSPACE_BT2020(10),

  /// Raw colorspace: for RAW unprocessed images
  V4L2_COLORSPACE_RAW(11),

  /// DCI-P3 colorspace, used by cinema projectors
  V4L2_COLORSPACE_DCI_P3(12);

  final int value;
  const v4l2_colorspace(this.value);

  static v4l2_colorspace fromValue(int value) => switch (value) {
        0 => V4L2_COLORSPACE_DEFAULT,
        1 => V4L2_COLORSPACE_SMPTE170M,
        2 => V4L2_COLORSPACE_SMPTE240M,
        3 => V4L2_COLORSPACE_REC709,
        4 => V4L2_COLORSPACE_BT878,
        5 => V4L2_COLORSPACE_470_SYSTEM_M,
        6 => V4L2_COLORSPACE_470_SYSTEM_BG,
        7 => V4L2_COLORSPACE_JPEG,
        8 => V4L2_COLORSPACE_SRGB,
        9 => V4L2_COLORSPACE_OPRGB,
        10 => V4L2_COLORSPACE_BT2020,
        11 => V4L2_COLORSPACE_RAW,
        12 => V4L2_COLORSPACE_DCI_P3,
        _ => throw ArgumentError("Unknown value for v4l2_colorspace: $value"),
      };
}

enum v4l2_xfer_func {
  /// Mapping of V4L2_XFER_FUNC_DEFAULT to actual transfer functions
  /// for the various colorspaces:
  ///
  /// V4L2_COLORSPACE_SMPTE170M, V4L2_COLORSPACE_470_SYSTEM_M,
  /// V4L2_COLORSPACE_470_SYSTEM_BG, V4L2_COLORSPACE_REC709 and
  /// V4L2_COLORSPACE_BT2020: V4L2_XFER_FUNC_709
  ///
  /// V4L2_COLORSPACE_SRGB, V4L2_COLORSPACE_JPEG: V4L2_XFER_FUNC_SRGB
  ///
  /// V4L2_COLORSPACE_OPRGB: V4L2_XFER_FUNC_OPRGB
  ///
  /// V4L2_COLORSPACE_SMPTE240M: V4L2_XFER_FUNC_SMPTE240M
  ///
  /// V4L2_COLORSPACE_RAW: V4L2_XFER_FUNC_NONE
  ///
  /// V4L2_COLORSPACE_DCI_P3: V4L2_XFER_FUNC_DCI_P3
  V4L2_XFER_FUNC_DEFAULT(0),
  V4L2_XFER_FUNC_709(1),
  V4L2_XFER_FUNC_SRGB(2),
  V4L2_XFER_FUNC_OPRGB(3),
  V4L2_XFER_FUNC_SMPTE240M(4),
  V4L2_XFER_FUNC_NONE(5),
  V4L2_XFER_FUNC_DCI_P3(6),
  V4L2_XFER_FUNC_SMPTE2084(7);

  final int value;
  const v4l2_xfer_func(this.value);

  static v4l2_xfer_func fromValue(int value) => switch (value) {
        0 => V4L2_XFER_FUNC_DEFAULT,
        1 => V4L2_XFER_FUNC_709,
        2 => V4L2_XFER_FUNC_SRGB,
        3 => V4L2_XFER_FUNC_OPRGB,
        4 => V4L2_XFER_FUNC_SMPTE240M,
        5 => V4L2_XFER_FUNC_NONE,
        6 => V4L2_XFER_FUNC_DCI_P3,
        7 => V4L2_XFER_FUNC_SMPTE2084,
        _ => throw ArgumentError("Unknown value for v4l2_xfer_func: $value"),
      };
}

enum v4l2_ycbcr_encoding {
  /// Mapping of V4L2_YCBCR_ENC_DEFAULT to actual encodings for the
  /// various colorspaces:
  ///
  /// V4L2_COLORSPACE_SMPTE170M, V4L2_COLORSPACE_470_SYSTEM_M,
  /// V4L2_COLORSPACE_470_SYSTEM_BG, V4L2_COLORSPACE_SRGB,
  /// V4L2_COLORSPACE_OPRGB and V4L2_COLORSPACE_JPEG: V4L2_YCBCR_ENC_601
  ///
  /// V4L2_COLORSPACE_REC709 and V4L2_COLORSPACE_DCI_P3: V4L2_YCBCR_ENC_709
  ///
  /// V4L2_COLORSPACE_BT2020: V4L2_YCBCR_ENC_BT2020
  ///
  /// V4L2_COLORSPACE_SMPTE240M: V4L2_YCBCR_ENC_SMPTE240M
  V4L2_YCBCR_ENC_DEFAULT(0),

  /// ITU-R 601 -- SDTV
  V4L2_YCBCR_ENC_601(1),

  /// Rec. 709 -- HDTV
  V4L2_YCBCR_ENC_709(2),

  /// ITU-R 601/EN 61966-2-4 Extended Gamut -- SDTV
  V4L2_YCBCR_ENC_XV601(3),

  /// Rec. 709/EN 61966-2-4 Extended Gamut -- HDTV
  V4L2_YCBCR_ENC_XV709(4),

  /// sYCC (Y'CbCr encoding of sRGB), identical to ENC_601. It was added
  /// originally due to a misunderstanding of the sYCC standard. It should
  /// not be used, instead use V4L2_YCBCR_ENC_601.
  V4L2_YCBCR_ENC_SYCC(5),

  /// BT.2020 Non-constant Luminance Y'CbCr
  V4L2_YCBCR_ENC_BT2020(6),

  /// BT.2020 Constant Luminance Y'CbcCrc
  V4L2_YCBCR_ENC_BT2020_CONST_LUM(7),

  /// SMPTE 240M -- Obsolete HDTV
  V4L2_YCBCR_ENC_SMPTE240M(8);

  final int value;
  const v4l2_ycbcr_encoding(this.value);

  static v4l2_ycbcr_encoding fromValue(int value) => switch (value) {
        0 => V4L2_YCBCR_ENC_DEFAULT,
        1 => V4L2_YCBCR_ENC_601,
        2 => V4L2_YCBCR_ENC_709,
        3 => V4L2_YCBCR_ENC_XV601,
        4 => V4L2_YCBCR_ENC_XV709,
        5 => V4L2_YCBCR_ENC_SYCC,
        6 => V4L2_YCBCR_ENC_BT2020,
        7 => V4L2_YCBCR_ENC_BT2020_CONST_LUM,
        8 => V4L2_YCBCR_ENC_SMPTE240M,
        _ =>
          throw ArgumentError("Unknown value for v4l2_ycbcr_encoding: $value"),
      };
}

/// enum v4l2_hsv_encoding values should not collide with the ones from
/// enum v4l2_ycbcr_encoding.
enum v4l2_hsv_encoding {
  /// Hue mapped to 0 - 179
  V4L2_HSV_ENC_180(128),

  /// Hue mapped to 0-255
  V4L2_HSV_ENC_256(129);

  final int value;
  const v4l2_hsv_encoding(this.value);

  static v4l2_hsv_encoding fromValue(int value) => switch (value) {
        128 => V4L2_HSV_ENC_180,
        129 => V4L2_HSV_ENC_256,
        _ => throw ArgumentError("Unknown value for v4l2_hsv_encoding: $value"),
      };
}

enum v4l2_quantization {
  /// The default for R'G'B' quantization is always full range.
  /// For Y'CbCr the quantization is always limited range, except
  /// for COLORSPACE_JPEG: this is full range.
  V4L2_QUANTIZATION_DEFAULT(0),
  V4L2_QUANTIZATION_FULL_RANGE(1),
  V4L2_QUANTIZATION_LIM_RANGE(2);

  final int value;
  const v4l2_quantization(this.value);

  static v4l2_quantization fromValue(int value) => switch (value) {
        0 => V4L2_QUANTIZATION_DEFAULT,
        1 => V4L2_QUANTIZATION_FULL_RANGE,
        2 => V4L2_QUANTIZATION_LIM_RANGE,
        _ => throw ArgumentError("Unknown value for v4l2_quantization: $value"),
      };
}

enum v4l2_priority {
  /// not initialized
  V4L2_PRIORITY_UNSET(0),
  V4L2_PRIORITY_BACKGROUND(1),
  V4L2_PRIORITY_INTERACTIVE(2),
  V4L2_PRIORITY_RECORD(3);

  static const V4L2_PRIORITY_DEFAULT = V4L2_PRIORITY_INTERACTIVE;

  final int value;
  const v4l2_priority(this.value);

  static v4l2_priority fromValue(int value) => switch (value) {
        0 => V4L2_PRIORITY_UNSET,
        1 => V4L2_PRIORITY_BACKGROUND,
        2 => V4L2_PRIORITY_INTERACTIVE,
        3 => V4L2_PRIORITY_RECORD,
        _ => throw ArgumentError("Unknown value for v4l2_priority: $value"),
      };

  @override
  String toString() {
    if (this == V4L2_PRIORITY_INTERACTIVE)
      return "v4l2_priority.V4L2_PRIORITY_INTERACTIVE, v4l2_priority.V4L2_PRIORITY_DEFAULT";
    return super.toString();
  }
}

final class v4l2_rect extends ffi.Struct {
  @__s32()
  external int left;

  @__s32()
  external int top;

  @__u32()
  external int width;

  @__u32()
  external int height;
}

typedef __s32 = ffi.Int;
typedef Dart__s32 = int;
typedef __u32 = ffi.UnsignedInt;
typedef Dart__u32 = int;

final class v4l2_fract extends ffi.Struct {
  @__u32()
  external int numerator;

  @__u32()
  external int denominator;
}

final class v4l2_area extends ffi.Struct {
  @__u32()
  external int width;

  @__u32()
  external int height;
}

/// struct v4l2_capability - Describes V4L2 device caps returned by VIDIOC_QUERYCAP
///
/// @driver:	   name of the driver module (e.g. "bttv")
/// @card:	   name of the card (e.g. "Hauppauge WinTV")
/// @bus_info:	   name of the bus (e.g. "PCI:" + pci_name(pci_dev) )
/// @version:	   KERNEL_VERSION
/// @capabilities: capabilities of the physical device as a whole
/// @device_caps:  capabilities accessed via this particular device (node)
/// @reserved:	   reserved fields for future extensions
final class v4l2_capability extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__u8> driver;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> card;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> bus_info;

  @__u32()
  external int version;

  @__u32()
  external int capabilities;

  @__u32()
  external int device_caps;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

typedef __u8 = ffi.UnsignedChar;
typedef Dart__u8 = int;

/// V I D E O   I M A G E   F O R M A T
final class v4l2_pix_format extends ffi.Struct {
  @__u32()
  external int width;

  @__u32()
  external int height;

  @__u32()
  external int pixelformat;

  /// enum v4l2_field
  @__u32()
  external int field;

  /// for padding, zero if unused
  @__u32()
  external int bytesperline;

  @__u32()
  external int sizeimage;

  /// enum v4l2_colorspace
  @__u32()
  external int colorspace;

  /// private data, depends on pixelformat
  @__u32()
  external int priv;

  /// format flags (V4L2_PIX_FMT_FLAG_*)
  @__u32()
  external int flags;

  external UnnamedUnion1 unnamed;

  /// enum v4l2_quantization
  @__u32()
  external int quantization;

  /// enum v4l2_xfer_func
  @__u32()
  external int xfer_func;
}

final class UnnamedUnion1 extends ffi.Union {
  /// enum v4l2_ycbcr_encoding
  @__u32()
  external int ycbcr_enc;

  /// enum v4l2_hsv_encoding
  @__u32()
  external int hsv_enc;
}

/// F O R M A T   E N U M E R A T I O N
final class v4l2_fmtdesc extends ffi.Struct {
  /// Format number
  @__u32()
  external int index;

  /// enum v4l2_buf_type
  @__u32()
  external int type;

  @__u32()
  external int flags;

  /// Description string
  @ffi.Array.multi([32])
  external ffi.Array<__u8> description;

  /// Format fourcc
  @__u32()
  external int pixelformat;

  /// Media bus code
  @__u32()
  external int mbus_code;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

/// Frame Size and frame rate enumeration */
/// /*
/// F R A M E   S I Z E   E N U M E R A T I O N
enum v4l2_frmsizetypes {
  V4L2_FRMSIZE_TYPE_DISCRETE(1),
  V4L2_FRMSIZE_TYPE_CONTINUOUS(2),
  V4L2_FRMSIZE_TYPE_STEPWISE(3);

  final int value;
  const v4l2_frmsizetypes(this.value);

  static v4l2_frmsizetypes fromValue(int value) => switch (value) {
        1 => V4L2_FRMSIZE_TYPE_DISCRETE,
        2 => V4L2_FRMSIZE_TYPE_CONTINUOUS,
        3 => V4L2_FRMSIZE_TYPE_STEPWISE,
        _ => throw ArgumentError("Unknown value for v4l2_frmsizetypes: $value"),
      };
}

final class v4l2_frmsize_discrete extends ffi.Struct {
  /// Frame width [pixel]
  @__u32()
  external int width;

  /// Frame height [pixel]
  @__u32()
  external int height;
}

final class v4l2_frmsize_stepwise extends ffi.Struct {
  /// Minimum frame width [pixel]
  @__u32()
  external int min_width;

  /// Maximum frame width [pixel]
  @__u32()
  external int max_width;

  /// Frame width step size [pixel]
  @__u32()
  external int step_width;

  /// Minimum frame height [pixel]
  @__u32()
  external int min_height;

  /// Maximum frame height [pixel]
  @__u32()
  external int max_height;

  /// Frame height step size [pixel]
  @__u32()
  external int step_height;
}

final class v4l2_frmsizeenum extends ffi.Struct {
  /// Frame size number
  @__u32()
  external int index;

  /// Pixel format
  @__u32()
  external int pixel_format;

  /// Frame size type the device supports.
  @__u32()
  external int type;

  external UnnamedUnion2 unnamed;

  /// Reserved space for future use
  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class UnnamedUnion2 extends ffi.Union {
  external v4l2_frmsize_discrete discrete;

  external v4l2_frmsize_stepwise stepwise;
}

/// F R A M E   R A T E   E N U M E R A T I O N
enum v4l2_frmivaltypes {
  V4L2_FRMIVAL_TYPE_DISCRETE(1),
  V4L2_FRMIVAL_TYPE_CONTINUOUS(2),
  V4L2_FRMIVAL_TYPE_STEPWISE(3);

  final int value;
  const v4l2_frmivaltypes(this.value);

  static v4l2_frmivaltypes fromValue(int value) => switch (value) {
        1 => V4L2_FRMIVAL_TYPE_DISCRETE,
        2 => V4L2_FRMIVAL_TYPE_CONTINUOUS,
        3 => V4L2_FRMIVAL_TYPE_STEPWISE,
        _ => throw ArgumentError("Unknown value for v4l2_frmivaltypes: $value"),
      };
}

final class v4l2_frmival_stepwise extends ffi.Struct {
  /// Minimum frame interval [s]
  external v4l2_fract min;

  /// Maximum frame interval [s]
  external v4l2_fract max;

  /// Frame interval step size [s]
  external v4l2_fract step;
}

final class v4l2_frmivalenum extends ffi.Struct {
  /// Frame format index
  @__u32()
  external int index;

  /// Pixel format
  @__u32()
  external int pixel_format;

  /// Frame width
  @__u32()
  external int width;

  /// Frame height
  @__u32()
  external int height;

  /// Frame interval type the device supports.
  @__u32()
  external int type;

  external UnnamedUnion3 unnamed;

  /// Reserved space for future use
  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class UnnamedUnion3 extends ffi.Union {
  external v4l2_fract discrete;

  external v4l2_frmival_stepwise stepwise;
}

/// T I M E C O D E
final class v4l2_timecode extends ffi.Struct {
  @__u32()
  external int type;

  @__u32()
  external int flags;

  @__u8()
  external int frames;

  @__u8()
  external int seconds;

  @__u8()
  external int minutes;

  @__u8()
  external int hours;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> userbits;
}

/// The above is based on SMPTE timecodes
final class v4l2_jpegcompression extends ffi.Struct {
  @ffi.Int()
  external int quality;

  /// Number of APP segment to be written,
  /// must be 0..15
  @ffi.Int()
  external int APPn;

  /// Length of data in JPEG APPn segment
  @ffi.Int()
  external int APP_len;

  /// Data in the JPEG APPn segment.
  @ffi.Array.multi([60])
  external ffi.Array<ffi.Char> APP_data;

  /// Length of data in JPEG COM segment
  @ffi.Int()
  external int COM_len;

  /// Data in JPEG COM segment
  @ffi.Array.multi([60])
  external ffi.Array<ffi.Char> COM_data;

  /// Which markers should go into the JPEG
  /// output. Unless you exactly know what
  /// you do, leave them untouched.
  /// Including less markers will make the
  /// resulting code smaller, but there will
  /// be fewer applications which can read it.
  /// The presence of the APP and COM marker
  /// is influenced by APP_len and COM_len
  /// ONLY, not by this property!
  @__u32()
  external int jpeg_markers;
}

/// M E M O R Y - M A P P I N G   B U F F E R S
final class v4l2_requestbuffers extends ffi.Struct {
  @__u32()
  external int count;

  /// enum v4l2_buf_type
  @__u32()
  external int type;

  /// enum v4l2_memory
  @__u32()
  external int memory;

  @__u32()
  external int capabilities;

  @__u8()
  external int flags;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> reserved;
}

/// struct v4l2_plane - plane info for multi-planar buffers
/// @bytesused:		number of bytes occupied by data in the plane (payload)
/// @length:		size of this plane (NOT the payload) in bytes
/// @mem_offset:		when memory in the associated struct v4l2_buffer is
/// V4L2_MEMORY_MMAP, equals the offset from the start of
/// the device memory for this plane (or is a "cookie" that
/// should be passed to mmap() called on the video node)
/// @userptr:		when memory is V4L2_MEMORY_USERPTR, a userspace pointer
/// pointing to this plane
/// @fd:			when memory is V4L2_MEMORY_DMABUF, a userspace file
/// descriptor associated with this plane
/// @m:			union of @mem_offset, @userptr and @fd
/// @data_offset:	offset in the plane to the start of data; usually 0,
/// unless there is a header in front of the data
/// @reserved:		drivers and applications must zero this array
///
/// Multi-planar buffers consist of one or more planes, e.g. an YCbCr buffer
/// with two planes can have one plane for Y, and another for interleaved CbCr
/// components. Each plane can reside in a separate memory buffer, or even in
/// a completely separate memory node (e.g. in embedded devices).
final class v4l2_plane extends ffi.Struct {
  @__u32()
  external int bytesused;

  @__u32()
  external int length;

  external UnnamedUnion4 m;

  @__u32()
  external int data_offset;

  @ffi.Array.multi([11])
  external ffi.Array<__u32> reserved;
}

final class UnnamedUnion4 extends ffi.Union {
  @__u32()
  external int mem_offset;

  @ffi.UnsignedLong()
  external int userptr;

  @__s32()
  external int fd;
}

/// struct v4l2_buffer - video buffer info
/// @index:	id number of the buffer
/// @type:	enum v4l2_buf_type; buffer type (type == *_MPLANE for
/// multiplanar buffers);
/// @bytesused:	number of bytes occupied by data in the buffer (payload);
/// unused (set to 0) for multiplanar buffers
/// @flags:	buffer informational flags
/// @field:	enum v4l2_field; field order of the image in the buffer
/// @timestamp:	frame timestamp
/// @timecode:	frame timecode
/// @sequence:	sequence count of this frame
/// @memory:	enum v4l2_memory; the method, in which the actual video data is
/// passed
/// @offset:	for non-multiplanar buffers with memory == V4L2_MEMORY_MMAP;
/// offset from the start of the device memory for this plane,
/// (or a "cookie" that should be passed to mmap() as offset)
/// @userptr:	for non-multiplanar buffers with memory == V4L2_MEMORY_USERPTR;
/// a userspace pointer pointing to this buffer
/// @fd:		for non-multiplanar buffers with memory == V4L2_MEMORY_DMABUF;
/// a userspace file descriptor associated with this buffer
/// @planes:	for multiplanar buffers; userspace pointer to the array of plane
/// info structs for this buffer
/// @m:		union of @offset, @userptr, @planes and @fd
/// @length:	size in bytes of the buffer (NOT its payload) for single-plane
/// buffers (when type != *_MPLANE); number of elements in the
/// planes array for multi-plane buffers
/// @reserved2:	drivers and applications must zero this field
/// @request_fd: fd of the request that this buffer should use
/// @reserved:	for backwards compatibility with applications that do not know
/// about @request_fd
///
/// Contains data exchanged by application and driver using one of the Streaming
/// I/O methods.
final class v4l2_buffer extends ffi.Struct {
  @__u32()
  external int index;

  @__u32()
  external int type;

  @__u32()
  external int bytesused;

  @__u32()
  external int flags;

  @__u32()
  external int field;

  external timeval timestamp;

  external v4l2_timecode timecode;

  @__u32()
  external int sequence;

  /// memory location
  @__u32()
  external int memory;

  external UnnamedUnion5 m;

  @__u32()
  external int length;

  @__u32()
  external int reserved2;

  external UnnamedUnion6 unnamed;
}

final class timeval extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__suseconds_t()
  external int tv_usec;
}

typedef __time_t = ffi.Long;
typedef Dart__time_t = int;
typedef __suseconds_t = ffi.Long;
typedef Dart__suseconds_t = int;

final class UnnamedUnion5 extends ffi.Union {
  @__u32()
  external int offset;

  @ffi.UnsignedLong()
  external int userptr;

  external ffi.Pointer<v4l2_plane> planes;

  @__s32()
  external int fd;
}

final class UnnamedUnion6 extends ffi.Union {
  @__s32()
  external int request_fd;

  @__u32()
  external int reserved;
}

/// struct v4l2_exportbuffer - export of video buffer as DMABUF file descriptor
///
/// @index:	id number of the buffer
/// @type:	enum v4l2_buf_type; buffer type (type == *_MPLANE for
/// multiplanar buffers);
/// @plane:	index of the plane to be exported, 0 for single plane queues
/// @flags:	flags for newly created file, currently only O_CLOEXEC is
/// supported, refer to manual of open syscall for more details
/// @fd:		file descriptor associated with DMABUF (set by driver)
/// @reserved:	drivers and applications must zero this array
///
/// Contains data used for exporting a video buffer as DMABUF file descriptor.
/// The buffer is identified by a 'cookie' returned by VIDIOC_QUERYBUF
/// (identical to the cookie used to mmap() the buffer to userspace). All
/// reserved fields must be set to zero. The field reserved0 is expected to
/// become a structure 'type' allowing an alternative layout of the structure
/// content. Therefore this field should not be used for any other extensions.
final class v4l2_exportbuffer extends ffi.Struct {
  /// enum v4l2_buf_type
  @__u32()
  external int type;

  @__u32()
  external int index;

  @__u32()
  external int plane;

  @__u32()
  external int flags;

  @__s32()
  external int fd;

  @ffi.Array.multi([11])
  external ffi.Array<__u32> reserved;
}

/// O V E R L A Y   P R E V I E W
final class v4l2_framebuffer extends ffi.Struct {
  @__u32()
  external int capability;

  @__u32()
  external int flags;

  /// FIXME: in theory we should pass something like PCI device + memory
  /// region + offset instead of some physical address
  external ffi.Pointer<ffi.Void> base;

  external UnnamedStruct1 fmt;
}

final class UnnamedStruct1 extends ffi.Struct {
  @__u32()
  external int width;

  @__u32()
  external int height;

  @__u32()
  external int pixelformat;

  /// enum v4l2_field
  @__u32()
  external int field;

  /// for padding, zero if unused
  @__u32()
  external int bytesperline;

  @__u32()
  external int sizeimage;

  /// enum v4l2_colorspace
  @__u32()
  external int colorspace;

  /// reserved field, set to 0
  @__u32()
  external int priv;
}

final class v4l2_clip extends ffi.Struct {
  external v4l2_rect c;

  external ffi.Pointer<v4l2_clip> next;
}

final class v4l2_window extends ffi.Struct {
  external v4l2_rect w;

  /// enum v4l2_field
  @__u32()
  external int field;

  @__u32()
  external int chromakey;

  external ffi.Pointer<v4l2_clip> clips;

  @__u32()
  external int clipcount;

  external ffi.Pointer<ffi.Void> bitmap;

  @__u8()
  external int global_alpha;
}

/// C A P T U R E   P A R A M E T E R S
final class v4l2_captureparm extends ffi.Struct {
  /// Supported modes
  @__u32()
  external int capability;

  /// Current mode
  @__u32()
  external int capturemode;

  /// Time per frame in seconds
  external v4l2_fract timeperframe;

  /// Driver-specific extensions
  @__u32()
  external int extendedmode;

  /// # of buffers for read
  @__u32()
  external int readbuffers;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> reserved;
}

final class v4l2_outputparm extends ffi.Struct {
  /// Supported modes
  @__u32()
  external int capability;

  /// Current mode
  @__u32()
  external int outputmode;

  /// Time per frame in seconds
  external v4l2_fract timeperframe;

  /// Driver-specific extensions
  @__u32()
  external int extendedmode;

  /// # of buffers for write
  @__u32()
  external int writebuffers;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> reserved;
}

/// I N P U T   I M A G E   C R O P P I N G
final class v4l2_cropcap extends ffi.Struct {
  /// enum v4l2_buf_type
  @__u32()
  external int type;

  external v4l2_rect bounds;

  external v4l2_rect defrect;

  external v4l2_fract pixelaspect;
}

final class v4l2_crop extends ffi.Struct {
  /// enum v4l2_buf_type
  @__u32()
  external int type;

  external v4l2_rect c;
}

/// struct v4l2_selection - selection info
/// @type:	buffer type (do not use *_MPLANE types)
/// @target:	Selection target, used to choose one of possible rectangles;
/// defined in v4l2-common.h; V4L2_SEL_TGT_* .
/// @flags:	constraints flags, defined in v4l2-common.h; V4L2_SEL_FLAG_*.
/// @r:		coordinates of selection window
/// @reserved:	for future use, rounds structure size to 64 bytes, set to zero
///
/// Hardware may use multiple helper windows to process a video stream.
/// The structure is used to exchange this selection areas between
/// an application and a driver.
final class v4l2_selection extends ffi.Struct {
  @__u32()
  external int type;

  @__u32()
  external int target;

  @__u32()
  external int flags;

  external v4l2_rect r;

  @ffi.Array.multi([9])
  external ffi.Array<__u32> reserved;
}

final class v4l2_standard extends ffi.Struct {
  @__u32()
  external int index;

  @v4l2_std_id()
  external int id;

  @ffi.Array.multi([24])
  external ffi.Array<__u8> name;

  /// Frames, not fields
  external v4l2_fract frameperiod;

  @__u32()
  external int framelines;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> reserved;
}

/// A N A L O G   V I D E O   S T A N D A R D
typedef v4l2_std_id = __u64;
typedef __u64 = ffi.UnsignedLongLong;
typedef Dart__u64 = int;

/// struct v4l2_bt_timings - BT.656/BT.1120 timing data
/// @width:	total width of the active video in pixels
/// @height:	total height of the active video in lines
/// @interlaced:	Interlaced or progressive
/// @polarities:	Positive or negative polarities
/// @pixelclock:	Pixel clock in HZ. Ex. 74.25MHz->74250000
/// @hfrontporch:Horizontal front porch in pixels
/// @hsync:	Horizontal Sync length in pixels
/// @hbackporch:	Horizontal back porch in pixels
/// @vfrontporch:Vertical front porch in lines
/// @vsync:	Vertical Sync length in lines
/// @vbackporch:	Vertical back porch in lines
/// @il_vfrontporch:Vertical front porch for the even field
/// (aka field 2) of interlaced field formats
/// @il_vsync:	Vertical Sync length for the even field
/// (aka field 2) of interlaced field formats
/// @il_vbackporch:Vertical back porch for the even field
/// (aka field 2) of interlaced field formats
/// @standards:	Standards the timing belongs to
/// @flags:	Flags
/// @picture_aspect: The picture aspect ratio (hor/vert).
/// @cea861_vic:	VIC code as per the CEA-861 standard.
/// @hdmi_vic:	VIC code as per the HDMI standard.
/// @reserved:	Reserved fields, must be zeroed.
///
/// A note regarding vertical interlaced timings: height refers to the total
/// height of the active video frame (= two fields). The blanking timings refer
/// to the blanking of each field. So the height of the total frame is
/// calculated as follows:
///
/// tot_height = height + vfrontporch + vsync + vbackporch +
/// il_vfrontporch + il_vsync + il_vbackporch
///
/// The active height of each field is height / 2.
@ffi.Packed(1)
final class v4l2_bt_timings extends ffi.Struct {
  @__u32()
  external int width;

  @__u32()
  external int height;

  @__u32()
  external int interlaced;

  @__u32()
  external int polarities;

  @__u64()
  external int pixelclock;

  @__u32()
  external int hfrontporch;

  @__u32()
  external int hsync;

  @__u32()
  external int hbackporch;

  @__u32()
  external int vfrontporch;

  @__u32()
  external int vsync;

  @__u32()
  external int vbackporch;

  @__u32()
  external int il_vfrontporch;

  @__u32()
  external int il_vsync;

  @__u32()
  external int il_vbackporch;

  @__u32()
  external int standards;

  @__u32()
  external int flags;

  external v4l2_fract picture_aspect;

  @__u8()
  external int cea861_vic;

  @__u8()
  external int hdmi_vic;

  @ffi.Array.multi([46])
  external ffi.Array<__u8> reserved;
}

/// struct v4l2_dv_timings - DV timings
/// @type:	the type of the timings
/// @bt:	BT656/1120 timings
@ffi.Packed(1)
final class v4l2_dv_timings extends ffi.Struct {
  @__u32()
  external int type;

  external UnnamedUnion7 unnamed;
}

final class UnnamedUnion7 extends ffi.Union {
  external v4l2_bt_timings bt;

  @ffi.Array.multi([32])
  external ffi.Array<__u32> reserved;
}

/// struct v4l2_enum_dv_timings - DV timings enumeration
/// @index:	enumeration index
/// @pad:	the pad number for which to enumerate timings (used with
/// v4l-subdev nodes only)
/// @reserved:	must be zeroed
/// @timings:	the timings for the given index
final class v4l2_enum_dv_timings extends ffi.Struct {
  @__u32()
  external int index;

  @__u32()
  external int pad;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;

  external v4l2_dv_timings timings;
}

/// struct v4l2_bt_timings_cap - BT.656/BT.1120 timing capabilities
/// @min_width:		width in pixels
/// @max_width:		width in pixels
/// @min_height:		height in lines
/// @max_height:		height in lines
/// @min_pixelclock:	Pixel clock in HZ. Ex. 74.25MHz->74250000
/// @max_pixelclock:	Pixel clock in HZ. Ex. 74.25MHz->74250000
/// @standards:		Supported standards
/// @capabilities:	Supported capabilities
/// @reserved:		Must be zeroed
@ffi.Packed(1)
final class v4l2_bt_timings_cap extends ffi.Struct {
  @__u32()
  external int min_width;

  @__u32()
  external int max_width;

  @__u32()
  external int min_height;

  @__u32()
  external int max_height;

  @__u64()
  external int min_pixelclock;

  @__u64()
  external int max_pixelclock;

  @__u32()
  external int standards;

  @__u32()
  external int capabilities;

  @ffi.Array.multi([16])
  external ffi.Array<__u32> reserved;
}

/// struct v4l2_dv_timings_cap - DV timings capabilities
/// @type:	the type of the timings (same as in struct v4l2_dv_timings)
/// @pad:	the pad number for which to query capabilities (used with
/// v4l-subdev nodes only)
/// @bt:		the BT656/1120 timings capabilities
final class v4l2_dv_timings_cap extends ffi.Struct {
  @__u32()
  external int type;

  @__u32()
  external int pad;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;

  external UnnamedUnion8 unnamed;
}

final class UnnamedUnion8 extends ffi.Union {
  external v4l2_bt_timings_cap bt;

  @ffi.Array.multi([32])
  external ffi.Array<__u32> raw_data;
}

/// V I D E O   I N P U T S
final class v4l2_input extends ffi.Struct {
  /// Which input
  @__u32()
  external int index;

  /// Label
  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  /// Type of input
  @__u32()
  external int type;

  /// Associated audios (bitfield)
  @__u32()
  external int audioset;

  /// Tuner index
  @__u32()
  external int tuner;

  @v4l2_std_id()
  external int std;

  @__u32()
  external int status;

  @__u32()
  external int capabilities;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

/// V I D E O   O U T P U T S
final class v4l2_output extends ffi.Struct {
  /// Which output
  @__u32()
  external int index;

  /// Label
  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  /// Type of output
  @__u32()
  external int type;

  /// Associated audios (bitfield)
  @__u32()
  external int audioset;

  /// Associated modulator
  @__u32()
  external int modulator;

  @v4l2_std_id()
  external int std;

  @__u32()
  external int capabilities;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

/// C O N T R O L S
final class v4l2_control extends ffi.Struct {
  @__u32()
  external int id;

  @__s32()
  external int value;
}

@ffi.Packed(1)
final class v4l2_ext_control extends ffi.Struct {
  @__u32()
  external int id;

  @__u32()
  external int size;

  @ffi.Array.multi([1])
  external ffi.Array<__u32> reserved2;

  external UnnamedUnion9 unnamed;
}

final class UnnamedUnion9 extends ffi.Union {
  @__s32()
  external int value;

  @__s64()
  external int value64;

  external ffi.Pointer<ffi.Char> string;

  external ffi.Pointer<__u8> p_u8;

  external ffi.Pointer<__u16> p_u16;

  external ffi.Pointer<__u32> p_u32;

  external ffi.Pointer<__s32> p_s32;

  external ffi.Pointer<__s64> p_s64;

  external ffi.Pointer<v4l2_area> p_area;

  external ffi.Pointer<v4l2_ctrl_h264_sps> p_h264_sps;

  external ffi.Pointer<v4l2_ctrl_h264_pps> p_h264_pps;

  external ffi.Pointer<v4l2_ctrl_h264_scaling_matrix> p_h264_scaling_matrix;

  external ffi.Pointer<v4l2_ctrl_h264_pred_weights> p_h264_pred_weights;

  external ffi.Pointer<v4l2_ctrl_h264_slice_params> p_h264_slice_params;

  external ffi.Pointer<v4l2_ctrl_h264_decode_params> p_h264_decode_params;

  external ffi.Pointer<v4l2_ctrl_fwht_params> p_fwht_params;

  external ffi.Pointer<v4l2_ctrl_vp8_frame> p_vp8_frame;

  external ffi.Pointer<v4l2_ctrl_mpeg2_sequence> p_mpeg2_sequence;

  external ffi.Pointer<v4l2_ctrl_mpeg2_picture> p_mpeg2_picture;

  external ffi.Pointer<v4l2_ctrl_mpeg2_quantisation> p_mpeg2_quantisation;

  external ffi.Pointer<v4l2_ctrl_vp9_compressed_hdr> p_vp9_compressed_hdr_probs;

  external ffi.Pointer<v4l2_ctrl_vp9_frame> p_vp9_frame;

  external ffi.Pointer<v4l2_ctrl_hevc_sps> p_hevc_sps;

  external ffi.Pointer<v4l2_ctrl_hevc_pps> p_hevc_pps;

  external ffi.Pointer<v4l2_ctrl_hevc_slice_params> p_hevc_slice_params;

  external ffi.Pointer<v4l2_ctrl_hevc_scaling_matrix> p_hevc_scaling_matrix;

  external ffi.Pointer<v4l2_ctrl_hevc_decode_params> p_hevc_decode_params;

  external ffi.Pointer<v4l2_ctrl_av1_sequence> p_av1_sequence;

  external ffi.Pointer<v4l2_ctrl_av1_tile_group_entry> p_av1_tile_group_entry;

  external ffi.Pointer<v4l2_ctrl_av1_frame> p_av1_frame;

  external ffi.Pointer<v4l2_ctrl_av1_film_grain> p_av1_film_grain;

  external ffi.Pointer<v4l2_ctrl_hdr10_cll_info> p_hdr10_cll_info;

  external ffi.Pointer<v4l2_ctrl_hdr10_mastering_display>
      p_hdr10_mastering_display;

  external ffi.Pointer<ffi.Void> ptr;
}

typedef __s64 = ffi.LongLong;
typedef Dart__s64 = int;
typedef __u16 = ffi.UnsignedShort;
typedef Dart__u16 = int;

final class v4l2_ctrl_h264_sps extends ffi.Struct {
  @__u8()
  external int profile_idc;

  @__u8()
  external int constraint_set_flags;

  @__u8()
  external int level_idc;

  @__u8()
  external int seq_parameter_set_id;

  @__u8()
  external int chroma_format_idc;

  @__u8()
  external int bit_depth_luma_minus8;

  @__u8()
  external int bit_depth_chroma_minus8;

  @__u8()
  external int log2_max_frame_num_minus4;

  @__u8()
  external int pic_order_cnt_type;

  @__u8()
  external int log2_max_pic_order_cnt_lsb_minus4;

  @__u8()
  external int max_num_ref_frames;

  @__u8()
  external int num_ref_frames_in_pic_order_cnt_cycle;

  @ffi.Array.multi([255])
  external ffi.Array<__s32> offset_for_ref_frame;

  @__s32()
  external int offset_for_non_ref_pic;

  @__s32()
  external int offset_for_top_to_bottom_field;

  @__u16()
  external int pic_width_in_mbs_minus1;

  @__u16()
  external int pic_height_in_map_units_minus1;

  @__u32()
  external int flags;
}

final class v4l2_ctrl_h264_pps extends ffi.Struct {
  @__u8()
  external int pic_parameter_set_id;

  @__u8()
  external int seq_parameter_set_id;

  @__u8()
  external int num_slice_groups_minus1;

  @__u8()
  external int num_ref_idx_l0_default_active_minus1;

  @__u8()
  external int num_ref_idx_l1_default_active_minus1;

  @__u8()
  external int weighted_bipred_idc;

  @__s8()
  external int pic_init_qp_minus26;

  @__s8()
  external int pic_init_qs_minus26;

  @__s8()
  external int chroma_qp_index_offset;

  @__s8()
  external int second_chroma_qp_index_offset;

  @__u16()
  external int flags;
}

typedef __s8 = ffi.SignedChar;
typedef Dart__s8 = int;

final class v4l2_ctrl_h264_scaling_matrix extends ffi.Struct {
  @ffi.Array.multi([6, 16])
  external ffi.Array<ffi.Array<__u8>> scaling_list_4x4;

  @ffi.Array.multi([6, 64])
  external ffi.Array<ffi.Array<__u8>> scaling_list_8x8;
}

final class v4l2_ctrl_h264_pred_weights extends ffi.Struct {
  @__u16()
  external int luma_log2_weight_denom;

  @__u16()
  external int chroma_log2_weight_denom;

  @ffi.Array.multi([2])
  external ffi.Array<v4l2_h264_weight_factors> weight_factors;
}

final class v4l2_h264_weight_factors extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<__s16> luma_weight;

  @ffi.Array.multi([32])
  external ffi.Array<__s16> luma_offset;

  @ffi.Array.multi([32, 2])
  external ffi.Array<ffi.Array<__s16>> chroma_weight;

  @ffi.Array.multi([32, 2])
  external ffi.Array<ffi.Array<__s16>> chroma_offset;
}

typedef __s16 = ffi.Short;
typedef Dart__s16 = int;

final class v4l2_ctrl_h264_slice_params extends ffi.Struct {
  @__u32()
  external int header_bit_size;

  @__u32()
  external int first_mb_in_slice;

  @__u8()
  external int slice_type;

  @__u8()
  external int colour_plane_id;

  @__u8()
  external int redundant_pic_cnt;

  @__u8()
  external int cabac_init_idc;

  @__s8()
  external int slice_qp_delta;

  @__s8()
  external int slice_qs_delta;

  @__u8()
  external int disable_deblocking_filter_idc;

  @__s8()
  external int slice_alpha_c0_offset_div2;

  @__s8()
  external int slice_beta_offset_div2;

  @__u8()
  external int num_ref_idx_l0_active_minus1;

  @__u8()
  external int num_ref_idx_l1_active_minus1;

  @__u8()
  external int reserved;

  @ffi.Array.multi([32])
  external ffi.Array<v4l2_h264_reference> ref_pic_list0;

  @ffi.Array.multi([32])
  external ffi.Array<v4l2_h264_reference> ref_pic_list1;

  @__u32()
  external int flags;
}

final class v4l2_h264_reference extends ffi.Struct {
  @__u8()
  external int fields;

  @__u8()
  external int index;
}

final class v4l2_ctrl_h264_decode_params extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<v4l2_h264_dpb_entry> dpb;

  @__u16()
  external int nal_ref_idc;

  @__u16()
  external int frame_num;

  @__s32()
  external int top_field_order_cnt;

  @__s32()
  external int bottom_field_order_cnt;

  @__u16()
  external int idr_pic_id;

  @__u16()
  external int pic_order_cnt_lsb;

  @__s32()
  external int delta_pic_order_cnt_bottom;

  @__s32()
  external int delta_pic_order_cnt0;

  @__s32()
  external int delta_pic_order_cnt1;

  @__u32()
  external int dec_ref_pic_marking_bit_size;

  @__u32()
  external int pic_order_cnt_bit_size;

  @__u32()
  external int slice_group_change_cycle;

  @__u32()
  external int reserved;

  @__u32()
  external int flags;
}

final class v4l2_h264_dpb_entry extends ffi.Struct {
  @__u64()
  external int reference_ts;

  @__u32()
  external int pic_num;

  @__u16()
  external int frame_num;

  @__u8()
  external int fields;

  @ffi.Array.multi([5])
  external ffi.Array<__u8> reserved;

  @__s32()
  external int top_field_order_cnt;

  @__s32()
  external int bottom_field_order_cnt;

  @__u32()
  external int flags;
}

final class v4l2_ctrl_fwht_params extends ffi.Struct {
  @__u64()
  external int backward_ref_ts;

  @__u32()
  external int version;

  @__u32()
  external int width;

  @__u32()
  external int height;

  @__u32()
  external int flags;

  @__u32()
  external int colorspace;

  @__u32()
  external int xfer_func;

  @__u32()
  external int ycbcr_enc;

  @__u32()
  external int quantization;
}

final class v4l2_ctrl_vp8_frame extends ffi.Struct {
  external v4l2_vp8_segment segment;

  external v4l2_vp8_loop_filter lf;

  external v4l2_vp8_quantization quant;

  external v4l2_vp8_entropy entropy;

  external v4l2_vp8_entropy_coder_state coder_state;

  @__u16()
  external int width;

  @__u16()
  external int height;

  @__u8()
  external int horizontal_scale;

  @__u8()
  external int vertical_scale;

  @__u8()
  external int version;

  @__u8()
  external int prob_skip_false;

  @__u8()
  external int prob_intra;

  @__u8()
  external int prob_last;

  @__u8()
  external int prob_gf;

  @__u8()
  external int num_dct_parts;

  @__u32()
  external int first_part_size;

  @__u32()
  external int first_part_header_bits;

  @ffi.Array.multi([8])
  external ffi.Array<__u32> dct_part_sizes;

  @__u64()
  external int last_frame_ts;

  @__u64()
  external int golden_frame_ts;

  @__u64()
  external int alt_frame_ts;

  @__u64()
  external int flags;
}

final class v4l2_vp8_segment extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__s8> quant_update;

  @ffi.Array.multi([4])
  external ffi.Array<__s8> lf_update;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> segment_probs;

  @__u8()
  external int padding;

  @__u32()
  external int flags;
}

final class v4l2_vp8_loop_filter extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__s8> ref_frm_delta;

  @ffi.Array.multi([4])
  external ffi.Array<__s8> mb_mode_delta;

  @__u8()
  external int sharpness_level;

  @__u8()
  external int level;

  @__u16()
  external int padding;

  @__u32()
  external int flags;
}

final class v4l2_vp8_quantization extends ffi.Struct {
  @__u8()
  external int y_ac_qi;

  @__s8()
  external int y_dc_delta;

  @__s8()
  external int y2_dc_delta;

  @__s8()
  external int y2_ac_delta;

  @__s8()
  external int uv_dc_delta;

  @__s8()
  external int uv_ac_delta;

  @__u16()
  external int padding;
}

final class v4l2_vp8_entropy extends ffi.Struct {
  @ffi.Array.multi([4, 8, 3, 11])
  external ffi.Array<ffi.Array<ffi.Array<ffi.Array<__u8>>>> coeff_probs;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> y_mode_probs;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> uv_mode_probs;

  @ffi.Array.multi([2, 19])
  external ffi.Array<ffi.Array<__u8>> mv_probs;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> padding;
}

final class v4l2_vp8_entropy_coder_state extends ffi.Struct {
  @__u8()
  external int range;

  @__u8()
  external int value;

  @__u8()
  external int bit_count;

  @__u8()
  external int padding;
}

final class v4l2_ctrl_mpeg2_sequence extends ffi.Struct {
  @__u16()
  external int horizontal_size;

  @__u16()
  external int vertical_size;

  @__u32()
  external int vbv_buffer_size;

  @__u16()
  external int profile_and_level_indication;

  @__u8()
  external int chroma_format;

  @__u8()
  external int flags;
}

final class v4l2_ctrl_mpeg2_picture extends ffi.Struct {
  @__u64()
  external int backward_ref_ts;

  @__u64()
  external int forward_ref_ts;

  @__u32()
  external int flags;

  @ffi.Array.multi([2, 2])
  external ffi.Array<ffi.Array<__u8>> f_code;

  @__u8()
  external int picture_coding_type;

  @__u8()
  external int picture_structure;

  @__u8()
  external int intra_dc_precision;

  @ffi.Array.multi([5])
  external ffi.Array<__u8> reserved;
}

final class v4l2_ctrl_mpeg2_quantisation extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__u8> intra_quantiser_matrix;

  @ffi.Array.multi([64])
  external ffi.Array<__u8> non_intra_quantiser_matrix;

  @ffi.Array.multi([64])
  external ffi.Array<__u8> chroma_intra_quantiser_matrix;

  @ffi.Array.multi([64])
  external ffi.Array<__u8> chroma_non_intra_quantiser_matrix;
}

final class v4l2_ctrl_vp9_compressed_hdr extends ffi.Struct {
  @__u8()
  external int tx_mode;

  @ffi.Array.multi([2, 1])
  external ffi.Array<ffi.Array<__u8>> tx8;

  @ffi.Array.multi([2, 2])
  external ffi.Array<ffi.Array<__u8>> tx16;

  @ffi.Array.multi([2, 3])
  external ffi.Array<ffi.Array<__u8>> tx32;

  @ffi.Array.multi([4, 2, 2, 6, 6, 3])
  external ffi
      .Array<ffi.Array<ffi.Array<ffi.Array<ffi.Array<ffi.Array<__u8>>>>>> coef;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> skip;

  @ffi.Array.multi([7, 3])
  external ffi.Array<ffi.Array<__u8>> inter_mode;

  @ffi.Array.multi([4, 2])
  external ffi.Array<ffi.Array<__u8>> interp_filter;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> is_inter;

  @ffi.Array.multi([5])
  external ffi.Array<__u8> comp_mode;

  @ffi.Array.multi([5, 2])
  external ffi.Array<ffi.Array<__u8>> single_ref;

  @ffi.Array.multi([5])
  external ffi.Array<__u8> comp_ref;

  @ffi.Array.multi([4, 9])
  external ffi.Array<ffi.Array<__u8>> y_mode;

  @ffi.Array.multi([10, 9])
  external ffi.Array<ffi.Array<__u8>> uv_mode;

  @ffi.Array.multi([16, 3])
  external ffi.Array<ffi.Array<__u8>> partition;

  external v4l2_vp9_mv_probs mv;
}

final class v4l2_vp9_mv_probs extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<__u8> joint;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> sign;

  @ffi.Array.multi([2, 10])
  external ffi.Array<ffi.Array<__u8>> classes;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> class0_bit;

  @ffi.Array.multi([2, 10])
  external ffi.Array<ffi.Array<__u8>> bits;

  @ffi.Array.multi([2, 2, 3])
  external ffi.Array<ffi.Array<ffi.Array<__u8>>> class0_fr;

  @ffi.Array.multi([2, 3])
  external ffi.Array<ffi.Array<__u8>> fr;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> class0_hp;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> hp;
}

final class v4l2_ctrl_vp9_frame extends ffi.Struct {
  external v4l2_vp9_loop_filter lf;

  external v4l2_vp9_quantization quant;

  external v4l2_vp9_segmentation seg;

  @__u32()
  external int flags;

  @__u16()
  external int compressed_header_size;

  @__u16()
  external int uncompressed_header_size;

  @__u16()
  external int frame_width_minus_1;

  @__u16()
  external int frame_height_minus_1;

  @__u16()
  external int render_width_minus_1;

  @__u16()
  external int render_height_minus_1;

  @__u64()
  external int last_frame_ts;

  @__u64()
  external int golden_frame_ts;

  @__u64()
  external int alt_frame_ts;

  @__u8()
  external int ref_frame_sign_bias;

  @__u8()
  external int reset_frame_context;

  @__u8()
  external int frame_context_idx;

  @__u8()
  external int profile;

  @__u8()
  external int bit_depth;

  @__u8()
  external int interpolation_filter;

  @__u8()
  external int tile_cols_log2;

  @__u8()
  external int tile_rows_log2;

  @__u8()
  external int reference_mode;

  @ffi.Array.multi([7])
  external ffi.Array<__u8> reserved;
}

final class v4l2_vp9_loop_filter extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__s8> ref_deltas;

  @ffi.Array.multi([2])
  external ffi.Array<__s8> mode_deltas;

  @__u8()
  external int level;

  @__u8()
  external int sharpness;

  @__u8()
  external int flags;

  @ffi.Array.multi([7])
  external ffi.Array<__u8> reserved;
}

final class v4l2_vp9_quantization extends ffi.Struct {
  @__u8()
  external int base_q_idx;

  @__s8()
  external int delta_q_y_dc;

  @__s8()
  external int delta_q_uv_dc;

  @__s8()
  external int delta_q_uv_ac;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> reserved;
}

final class v4l2_vp9_segmentation extends ffi.Struct {
  @ffi.Array.multi([8, 4])
  external ffi.Array<ffi.Array<__s16>> feature_data;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> feature_enabled;

  @ffi.Array.multi([7])
  external ffi.Array<__u8> tree_probs;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> pred_probs;

  @__u8()
  external int flags;

  @ffi.Array.multi([5])
  external ffi.Array<__u8> reserved;
}

final class v4l2_ctrl_hevc_sps extends ffi.Struct {
  @__u8()
  external int video_parameter_set_id;

  @__u8()
  external int seq_parameter_set_id;

  @__u16()
  external int pic_width_in_luma_samples;

  @__u16()
  external int pic_height_in_luma_samples;

  @__u8()
  external int bit_depth_luma_minus8;

  @__u8()
  external int bit_depth_chroma_minus8;

  @__u8()
  external int log2_max_pic_order_cnt_lsb_minus4;

  @__u8()
  external int sps_max_dec_pic_buffering_minus1;

  @__u8()
  external int sps_max_num_reorder_pics;

  @__u8()
  external int sps_max_latency_increase_plus1;

  @__u8()
  external int log2_min_luma_coding_block_size_minus3;

  @__u8()
  external int log2_diff_max_min_luma_coding_block_size;

  @__u8()
  external int log2_min_luma_transform_block_size_minus2;

  @__u8()
  external int log2_diff_max_min_luma_transform_block_size;

  @__u8()
  external int max_transform_hierarchy_depth_inter;

  @__u8()
  external int max_transform_hierarchy_depth_intra;

  @__u8()
  external int pcm_sample_bit_depth_luma_minus1;

  @__u8()
  external int pcm_sample_bit_depth_chroma_minus1;

  @__u8()
  external int log2_min_pcm_luma_coding_block_size_minus3;

  @__u8()
  external int log2_diff_max_min_pcm_luma_coding_block_size;

  @__u8()
  external int num_short_term_ref_pic_sets;

  @__u8()
  external int num_long_term_ref_pics_sps;

  @__u8()
  external int chroma_format_idc;

  @__u8()
  external int sps_max_sub_layers_minus1;

  @ffi.Array.multi([6])
  external ffi.Array<__u8> reserved;

  @__u64()
  external int flags;
}

final class v4l2_ctrl_hevc_pps extends ffi.Struct {
  @__u8()
  external int pic_parameter_set_id;

  @__u8()
  external int num_extra_slice_header_bits;

  @__u8()
  external int num_ref_idx_l0_default_active_minus1;

  @__u8()
  external int num_ref_idx_l1_default_active_minus1;

  @__s8()
  external int init_qp_minus26;

  @__u8()
  external int diff_cu_qp_delta_depth;

  @__s8()
  external int pps_cb_qp_offset;

  @__s8()
  external int pps_cr_qp_offset;

  @__u8()
  external int num_tile_columns_minus1;

  @__u8()
  external int num_tile_rows_minus1;

  @ffi.Array.multi([20])
  external ffi.Array<__u8> column_width_minus1;

  @ffi.Array.multi([22])
  external ffi.Array<__u8> row_height_minus1;

  @__s8()
  external int pps_beta_offset_div2;

  @__s8()
  external int pps_tc_offset_div2;

  @__u8()
  external int log2_parallel_merge_level_minus2;

  @__u8()
  external int reserved;

  @__u64()
  external int flags;
}

final class v4l2_ctrl_hevc_slice_params extends ffi.Struct {
  @__u32()
  external int bit_size;

  @__u32()
  external int data_byte_offset;

  @__u32()
  external int num_entry_point_offsets;

  @__u8()
  external int nal_unit_type;

  @__u8()
  external int nuh_temporal_id_plus1;

  @__u8()
  external int slice_type;

  @__u8()
  external int colour_plane_id;

  @__s32()
  external int slice_pic_order_cnt;

  @__u8()
  external int num_ref_idx_l0_active_minus1;

  @__u8()
  external int num_ref_idx_l1_active_minus1;

  @__u8()
  external int collocated_ref_idx;

  @__u8()
  external int five_minus_max_num_merge_cand;

  @__s8()
  external int slice_qp_delta;

  @__s8()
  external int slice_cb_qp_offset;

  @__s8()
  external int slice_cr_qp_offset;

  @__s8()
  external int slice_act_y_qp_offset;

  @__s8()
  external int slice_act_cb_qp_offset;

  @__s8()
  external int slice_act_cr_qp_offset;

  @__s8()
  external int slice_beta_offset_div2;

  @__s8()
  external int slice_tc_offset_div2;

  @__u8()
  external int pic_struct;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> reserved0;

  @__u32()
  external int slice_segment_addr;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> ref_idx_l0;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> ref_idx_l1;

  @__u16()
  external int short_term_ref_pic_set_size;

  @__u16()
  external int long_term_ref_pic_set_size;

  external v4l2_hevc_pred_weight_table pred_weight_table;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> reserved1;

  @__u64()
  external int flags;
}

final class v4l2_hevc_pred_weight_table extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__s8> delta_luma_weight_l0;

  @ffi.Array.multi([16])
  external ffi.Array<__s8> luma_offset_l0;

  @ffi.Array.multi([16, 2])
  external ffi.Array<ffi.Array<__s8>> delta_chroma_weight_l0;

  @ffi.Array.multi([16, 2])
  external ffi.Array<ffi.Array<__s8>> chroma_offset_l0;

  @ffi.Array.multi([16])
  external ffi.Array<__s8> delta_luma_weight_l1;

  @ffi.Array.multi([16])
  external ffi.Array<__s8> luma_offset_l1;

  @ffi.Array.multi([16, 2])
  external ffi.Array<ffi.Array<__s8>> delta_chroma_weight_l1;

  @ffi.Array.multi([16, 2])
  external ffi.Array<ffi.Array<__s8>> chroma_offset_l1;

  @__u8()
  external int luma_log2_weight_denom;

  @__s8()
  external int delta_chroma_log2_weight_denom;
}

final class v4l2_ctrl_hevc_scaling_matrix extends ffi.Struct {
  @ffi.Array.multi([6, 16])
  external ffi.Array<ffi.Array<__u8>> scaling_list_4x4;

  @ffi.Array.multi([6, 64])
  external ffi.Array<ffi.Array<__u8>> scaling_list_8x8;

  @ffi.Array.multi([6, 64])
  external ffi.Array<ffi.Array<__u8>> scaling_list_16x16;

  @ffi.Array.multi([2, 64])
  external ffi.Array<ffi.Array<__u8>> scaling_list_32x32;

  @ffi.Array.multi([6])
  external ffi.Array<__u8> scaling_list_dc_coef_16x16;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> scaling_list_dc_coef_32x32;
}

final class v4l2_ctrl_hevc_decode_params extends ffi.Struct {
  @__s32()
  external int pic_order_cnt_val;

  @__u16()
  external int short_term_ref_pic_set_size;

  @__u16()
  external int long_term_ref_pic_set_size;

  @__u8()
  external int num_active_dpb_entries;

  @__u8()
  external int num_poc_st_curr_before;

  @__u8()
  external int num_poc_st_curr_after;

  @__u8()
  external int num_poc_lt_curr;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> poc_st_curr_before;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> poc_st_curr_after;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> poc_lt_curr;

  @__u8()
  external int num_delta_pocs_of_ref_rps_idx;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> reserved;

  @ffi.Array.multi([16])
  external ffi.Array<v4l2_hevc_dpb_entry> dpb;

  @__u64()
  external int flags;
}

final class v4l2_hevc_dpb_entry extends ffi.Struct {
  @__u64()
  external int timestamp;

  @__u8()
  external int flags;

  @__u8()
  external int field_pic;

  @__u16()
  external int reserved;

  @__s32()
  external int pic_order_cnt_val;
}

final class v4l2_ctrl_av1_sequence extends ffi.Struct {
  @__u32()
  external int flags;

  @__u8()
  external int seq_profile;

  @__u8()
  external int order_hint_bits;

  @__u8()
  external int bit_depth;

  @__u8()
  external int reserved;

  @__u16()
  external int max_frame_width_minus_1;

  @__u16()
  external int max_frame_height_minus_1;
}

final class v4l2_ctrl_av1_tile_group_entry extends ffi.Struct {
  @__u32()
  external int tile_offset;

  @__u32()
  external int tile_size;

  @__u32()
  external int tile_row;

  @__u32()
  external int tile_col;
}

final class v4l2_ctrl_av1_frame extends ffi.Struct {
  external v4l2_av1_tile_info tile_info;

  external v4l2_av1_quantization quantization;

  @__u8()
  external int superres_denom;

  external v4l2_av1_segmentation segmentation;

  external v4l2_av1_loop_filter loop_filter;

  external v4l2_av1_cdef cdef;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> skip_mode_frame;

  @__u8()
  external int primary_ref_frame;

  external v4l2_av1_loop_restoration loop_restoration;

  external v4l2_av1_global_motion global_motion;

  @__u32()
  external int flags;

  @ffi.UnsignedInt()
  external int frame_typeAsInt;

  v4l2_av1_frame_type get frame_type =>
      v4l2_av1_frame_type.fromValue(frame_typeAsInt);

  @__u32()
  external int order_hint;

  @__u32()
  external int upscaled_width;

  @ffi.UnsignedInt()
  external int interpolation_filterAsInt;

  v4l2_av1_interpolation_filter get interpolation_filter =>
      v4l2_av1_interpolation_filter.fromValue(interpolation_filterAsInt);

  @ffi.UnsignedInt()
  external int tx_modeAsInt;

  v4l2_av1_tx_mode get tx_mode => v4l2_av1_tx_mode.fromValue(tx_modeAsInt);

  @__u32()
  external int frame_width_minus_1;

  @__u32()
  external int frame_height_minus_1;

  @__u16()
  external int render_width_minus_1;

  @__u16()
  external int render_height_minus_1;

  @__u32()
  external int current_frame_id;

  @ffi.Array.multi([32])
  external ffi.Array<__u32> buffer_removal_time;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> reserved;

  @ffi.Array.multi([8])
  external ffi.Array<__u32> order_hints;

  @ffi.Array.multi([8])
  external ffi.Array<__u64> reference_frame_ts;

  @ffi.Array.multi([7])
  external ffi.Array<__s8> ref_frame_idx;

  @__u8()
  external int refresh_frame_flags;
}

final class v4l2_av1_tile_info extends ffi.Struct {
  @__u8()
  external int flags;

  @__u8()
  external int context_update_tile_id;

  @__u8()
  external int tile_cols;

  @__u8()
  external int tile_rows;

  @ffi.Array.multi([65])
  external ffi.Array<__u32> mi_col_starts;

  @ffi.Array.multi([65])
  external ffi.Array<__u32> mi_row_starts;

  @ffi.Array.multi([64])
  external ffi.Array<__u32> width_in_sbs_minus_1;

  @ffi.Array.multi([64])
  external ffi.Array<__u32> height_in_sbs_minus_1;

  @__u8()
  external int tile_size_bytes;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> reserved;
}

final class v4l2_av1_quantization extends ffi.Struct {
  @__u8()
  external int flags;

  @__u8()
  external int base_q_idx;

  @__s8()
  external int delta_q_y_dc;

  @__s8()
  external int delta_q_u_dc;

  @__s8()
  external int delta_q_u_ac;

  @__s8()
  external int delta_q_v_dc;

  @__s8()
  external int delta_q_v_ac;

  @__u8()
  external int qm_y;

  @__u8()
  external int qm_u;

  @__u8()
  external int qm_v;

  @__u8()
  external int delta_q_res;
}

final class v4l2_av1_segmentation extends ffi.Struct {
  @__u8()
  external int flags;

  @__u8()
  external int last_active_seg_id;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> feature_enabled;

  @ffi.Array.multi([8, 8])
  external ffi.Array<ffi.Array<__s16>> feature_data;
}

final class v4l2_av1_loop_filter extends ffi.Struct {
  @__u8()
  external int flags;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> level;

  @__u8()
  external int sharpness;

  @ffi.Array.multi([8])
  external ffi.Array<__s8> ref_deltas;

  @ffi.Array.multi([2])
  external ffi.Array<__s8> mode_deltas;

  @__u8()
  external int delta_lf_res;
}

final class v4l2_av1_cdef extends ffi.Struct {
  @__u8()
  external int damping_minus_3;

  @__u8()
  external int bits;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> y_pri_strength;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> y_sec_strength;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> uv_pri_strength;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> uv_sec_strength;
}

final class v4l2_av1_loop_restoration extends ffi.Struct {
  @__u8()
  external int flags;

  @__u8()
  external int lr_unit_shift;

  @__u8()
  external int lr_uv_shift;

  @__u8()
  external int reserved;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedInt> frame_restoration_type;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> loop_restoration_size;
}

enum v4l2_av1_frame_restoration_type {
  V4L2_AV1_FRAME_RESTORE_NONE(0),
  V4L2_AV1_FRAME_RESTORE_WIENER(1),
  V4L2_AV1_FRAME_RESTORE_SGRPROJ(2),
  V4L2_AV1_FRAME_RESTORE_SWITCHABLE(3);

  final int value;
  const v4l2_av1_frame_restoration_type(this.value);

  static v4l2_av1_frame_restoration_type fromValue(int value) =>
      switch (value) {
        0 => V4L2_AV1_FRAME_RESTORE_NONE,
        1 => V4L2_AV1_FRAME_RESTORE_WIENER,
        2 => V4L2_AV1_FRAME_RESTORE_SGRPROJ,
        3 => V4L2_AV1_FRAME_RESTORE_SWITCHABLE,
        _ => throw ArgumentError(
            "Unknown value for v4l2_av1_frame_restoration_type: $value"),
      };
}

final class v4l2_av1_global_motion extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<__u8> flags;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedInt> type;

  @ffi.Array.multi([8, 6])
  external ffi.Array<ffi.Array<__s32>> params;

  @__u8()
  external int invalid;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> reserved;
}

enum v4l2_av1_warp_model {
  V4L2_AV1_WARP_MODEL_IDENTITY(0),
  V4L2_AV1_WARP_MODEL_TRANSLATION(1),
  V4L2_AV1_WARP_MODEL_ROTZOOM(2),
  V4L2_AV1_WARP_MODEL_AFFINE(3);

  final int value;
  const v4l2_av1_warp_model(this.value);

  static v4l2_av1_warp_model fromValue(int value) => switch (value) {
        0 => V4L2_AV1_WARP_MODEL_IDENTITY,
        1 => V4L2_AV1_WARP_MODEL_TRANSLATION,
        2 => V4L2_AV1_WARP_MODEL_ROTZOOM,
        3 => V4L2_AV1_WARP_MODEL_AFFINE,
        _ =>
          throw ArgumentError("Unknown value for v4l2_av1_warp_model: $value"),
      };
}

enum v4l2_av1_frame_type {
  V4L2_AV1_KEY_FRAME(0),
  V4L2_AV1_INTER_FRAME(1),
  V4L2_AV1_INTRA_ONLY_FRAME(2),
  V4L2_AV1_SWITCH_FRAME(3);

  final int value;
  const v4l2_av1_frame_type(this.value);

  static v4l2_av1_frame_type fromValue(int value) => switch (value) {
        0 => V4L2_AV1_KEY_FRAME,
        1 => V4L2_AV1_INTER_FRAME,
        2 => V4L2_AV1_INTRA_ONLY_FRAME,
        3 => V4L2_AV1_SWITCH_FRAME,
        _ =>
          throw ArgumentError("Unknown value for v4l2_av1_frame_type: $value"),
      };
}

enum v4l2_av1_interpolation_filter {
  V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP(0),
  V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH(1),
  V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP(2),
  V4L2_AV1_INTERPOLATION_FILTER_BILINEAR(3),
  V4L2_AV1_INTERPOLATION_FILTER_SWITCHABLE(4);

  final int value;
  const v4l2_av1_interpolation_filter(this.value);

  static v4l2_av1_interpolation_filter fromValue(int value) => switch (value) {
        0 => V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP,
        1 => V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH,
        2 => V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP,
        3 => V4L2_AV1_INTERPOLATION_FILTER_BILINEAR,
        4 => V4L2_AV1_INTERPOLATION_FILTER_SWITCHABLE,
        _ => throw ArgumentError(
            "Unknown value for v4l2_av1_interpolation_filter: $value"),
      };
}

enum v4l2_av1_tx_mode {
  V4L2_AV1_TX_MODE_ONLY_4X4(0),
  V4L2_AV1_TX_MODE_LARGEST(1),
  V4L2_AV1_TX_MODE_SELECT(2);

  final int value;
  const v4l2_av1_tx_mode(this.value);

  static v4l2_av1_tx_mode fromValue(int value) => switch (value) {
        0 => V4L2_AV1_TX_MODE_ONLY_4X4,
        1 => V4L2_AV1_TX_MODE_LARGEST,
        2 => V4L2_AV1_TX_MODE_SELECT,
        _ => throw ArgumentError("Unknown value for v4l2_av1_tx_mode: $value"),
      };
}

final class v4l2_ctrl_av1_film_grain extends ffi.Struct {
  @__u8()
  external int flags;

  @__u8()
  external int cr_mult;

  @__u16()
  external int grain_seed;

  @__u8()
  external int film_grain_params_ref_idx;

  @__u8()
  external int num_y_points;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_y_value;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_y_scaling;

  @__u8()
  external int num_cb_points;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_cb_value;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_cb_scaling;

  @__u8()
  external int num_cr_points;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_cr_value;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_cr_scaling;

  @__u8()
  external int grain_scaling_minus_8;

  @__u8()
  external int ar_coeff_lag;

  @ffi.Array.multi([25])
  external ffi.Array<__u8> ar_coeffs_y_plus_128;

  @ffi.Array.multi([25])
  external ffi.Array<__u8> ar_coeffs_cb_plus_128;

  @ffi.Array.multi([25])
  external ffi.Array<__u8> ar_coeffs_cr_plus_128;

  @__u8()
  external int ar_coeff_shift_minus_6;

  @__u8()
  external int grain_scale_shift;

  @__u8()
  external int cb_mult;

  @__u8()
  external int cb_luma_mult;

  @__u8()
  external int cr_luma_mult;

  @__u16()
  external int cb_offset;

  @__u16()
  external int cr_offset;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> reserved;
}

final class v4l2_ctrl_hdr10_cll_info extends ffi.Struct {
  @__u16()
  external int max_content_light_level;

  @__u16()
  external int max_pic_average_light_level;
}

final class v4l2_ctrl_hdr10_mastering_display extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<__u16> display_primaries_x;

  @ffi.Array.multi([3])
  external ffi.Array<__u16> display_primaries_y;

  @__u16()
  external int white_point_x;

  @__u16()
  external int white_point_y;

  @__u32()
  external int max_display_mastering_luminance;

  @__u32()
  external int min_display_mastering_luminance;
}

final class v4l2_ext_controls extends ffi.Struct {
  external UnnamedUnion10 unnamed;

  @__u32()
  external int count;

  @__u32()
  external int error_idx;

  @__s32()
  external int request_fd;

  @ffi.Array.multi([1])
  external ffi.Array<__u32> reserved;

  external ffi.Pointer<v4l2_ext_control> controls;
}

final class UnnamedUnion10 extends ffi.Union {
  @__u32()
  external int ctrl_class;

  @__u32()
  external int which;
}

enum v4l2_ctrl_type {
  V4L2_CTRL_TYPE_INTEGER(1),
  V4L2_CTRL_TYPE_BOOLEAN(2),
  V4L2_CTRL_TYPE_MENU(3),
  V4L2_CTRL_TYPE_BUTTON(4),
  V4L2_CTRL_TYPE_INTEGER64(5),
  V4L2_CTRL_TYPE_CTRL_CLASS(6),
  V4L2_CTRL_TYPE_STRING(7),
  V4L2_CTRL_TYPE_BITMASK(8),
  V4L2_CTRL_TYPE_INTEGER_MENU(9),

  /// Compound types are >= 0x0100
  V4L2_CTRL_COMPOUND_TYPES(256),
  V4L2_CTRL_TYPE_U16(257),
  V4L2_CTRL_TYPE_U32(258),
  V4L2_CTRL_TYPE_AREA(262),
  V4L2_CTRL_TYPE_HDR10_CLL_INFO(272),
  V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY(273),
  V4L2_CTRL_TYPE_H264_SPS(512),
  V4L2_CTRL_TYPE_H264_PPS(513),
  V4L2_CTRL_TYPE_H264_SCALING_MATRIX(514),
  V4L2_CTRL_TYPE_H264_SLICE_PARAMS(515),
  V4L2_CTRL_TYPE_H264_DECODE_PARAMS(516),
  V4L2_CTRL_TYPE_H264_PRED_WEIGHTS(517),
  V4L2_CTRL_TYPE_FWHT_PARAMS(544),
  V4L2_CTRL_TYPE_VP8_FRAME(576),
  V4L2_CTRL_TYPE_MPEG2_QUANTISATION(592),
  V4L2_CTRL_TYPE_MPEG2_SEQUENCE(593),
  V4L2_CTRL_TYPE_MPEG2_PICTURE(594),
  V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR(608),
  V4L2_CTRL_TYPE_VP9_FRAME(609),
  V4L2_CTRL_TYPE_HEVC_SPS(624),
  V4L2_CTRL_TYPE_HEVC_PPS(625),
  V4L2_CTRL_TYPE_HEVC_SLICE_PARAMS(626),
  V4L2_CTRL_TYPE_HEVC_SCALING_MATRIX(627),
  V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS(628),
  V4L2_CTRL_TYPE_AV1_SEQUENCE(640),
  V4L2_CTRL_TYPE_AV1_TILE_GROUP_ENTRY(641),
  V4L2_CTRL_TYPE_AV1_FRAME(642),
  V4L2_CTRL_TYPE_AV1_FILM_GRAIN(643);

  static const V4L2_CTRL_TYPE_U8 = V4L2_CTRL_COMPOUND_TYPES;

  final int value;
  const v4l2_ctrl_type(this.value);

  static v4l2_ctrl_type fromValue(int value) => switch (value) {
        1 => V4L2_CTRL_TYPE_INTEGER,
        2 => V4L2_CTRL_TYPE_BOOLEAN,
        3 => V4L2_CTRL_TYPE_MENU,
        4 => V4L2_CTRL_TYPE_BUTTON,
        5 => V4L2_CTRL_TYPE_INTEGER64,
        6 => V4L2_CTRL_TYPE_CTRL_CLASS,
        7 => V4L2_CTRL_TYPE_STRING,
        8 => V4L2_CTRL_TYPE_BITMASK,
        9 => V4L2_CTRL_TYPE_INTEGER_MENU,
        256 => V4L2_CTRL_COMPOUND_TYPES,
        257 => V4L2_CTRL_TYPE_U16,
        258 => V4L2_CTRL_TYPE_U32,
        262 => V4L2_CTRL_TYPE_AREA,
        272 => V4L2_CTRL_TYPE_HDR10_CLL_INFO,
        273 => V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY,
        512 => V4L2_CTRL_TYPE_H264_SPS,
        513 => V4L2_CTRL_TYPE_H264_PPS,
        514 => V4L2_CTRL_TYPE_H264_SCALING_MATRIX,
        515 => V4L2_CTRL_TYPE_H264_SLICE_PARAMS,
        516 => V4L2_CTRL_TYPE_H264_DECODE_PARAMS,
        517 => V4L2_CTRL_TYPE_H264_PRED_WEIGHTS,
        544 => V4L2_CTRL_TYPE_FWHT_PARAMS,
        576 => V4L2_CTRL_TYPE_VP8_FRAME,
        592 => V4L2_CTRL_TYPE_MPEG2_QUANTISATION,
        593 => V4L2_CTRL_TYPE_MPEG2_SEQUENCE,
        594 => V4L2_CTRL_TYPE_MPEG2_PICTURE,
        608 => V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR,
        609 => V4L2_CTRL_TYPE_VP9_FRAME,
        624 => V4L2_CTRL_TYPE_HEVC_SPS,
        625 => V4L2_CTRL_TYPE_HEVC_PPS,
        626 => V4L2_CTRL_TYPE_HEVC_SLICE_PARAMS,
        627 => V4L2_CTRL_TYPE_HEVC_SCALING_MATRIX,
        628 => V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS,
        640 => V4L2_CTRL_TYPE_AV1_SEQUENCE,
        641 => V4L2_CTRL_TYPE_AV1_TILE_GROUP_ENTRY,
        642 => V4L2_CTRL_TYPE_AV1_FRAME,
        643 => V4L2_CTRL_TYPE_AV1_FILM_GRAIN,
        _ => throw ArgumentError("Unknown value for v4l2_ctrl_type: $value"),
      };

  @override
  String toString() {
    if (this == V4L2_CTRL_COMPOUND_TYPES)
      return "v4l2_ctrl_type.V4L2_CTRL_COMPOUND_TYPES, v4l2_ctrl_type.V4L2_CTRL_TYPE_U8";
    return super.toString();
  }
}

/// Used in the VIDIOC_QUERYCTRL ioctl for querying controls
final class v4l2_queryctrl extends ffi.Struct {
  @__u32()
  external int id;

  /// enum v4l2_ctrl_type
  @__u32()
  external int type;

  /// Whatever
  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  /// Note signedness
  @__s32()
  external int minimum;

  @__s32()
  external int maximum;

  @__s32()
  external int step;

  @__s32()
  external int default_value;

  @__u32()
  external int flags;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

/// Used in the VIDIOC_QUERY_EXT_CTRL ioctl for querying extended controls
final class v4l2_query_ext_ctrl extends ffi.Struct {
  @__u32()
  external int id;

  @__u32()
  external int type;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;

  @__s64()
  external int minimum;

  @__s64()
  external int maximum;

  @__u64()
  external int step;

  @__s64()
  external int default_value;

  @__u32()
  external int flags;

  @__u32()
  external int elem_size;

  @__u32()
  external int elems;

  @__u32()
  external int nr_of_dims;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> dims;

  @ffi.Array.multi([32])
  external ffi.Array<__u32> reserved;
}

/// Used in the VIDIOC_QUERYMENU ioctl for querying menu items
@ffi.Packed(1)
final class v4l2_querymenu extends ffi.Struct {
  @__u32()
  external int id;

  @__u32()
  external int index;

  external UnnamedUnion11 unnamed;

  @__u32()
  external int reserved;
}

final class UnnamedUnion11 extends ffi.Union {
  /// Whatever
  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  @__s64()
  external int value;
}

/// T U N I N G
final class v4l2_tuner extends ffi.Struct {
  @__u32()
  external int index;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  /// enum v4l2_tuner_type
  @__u32()
  external int type;

  @__u32()
  external int capability;

  @__u32()
  external int rangelow;

  @__u32()
  external int rangehigh;

  @__u32()
  external int rxsubchans;

  @__u32()
  external int audmode;

  @__s32()
  external int signal;

  @__s32()
  external int afc;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> reserved;
}

final class v4l2_modulator extends ffi.Struct {
  @__u32()
  external int index;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  @__u32()
  external int capability;

  @__u32()
  external int rangelow;

  @__u32()
  external int rangehigh;

  @__u32()
  external int txsubchans;

  /// enum v4l2_tuner_type
  @__u32()
  external int type;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

final class v4l2_frequency extends ffi.Struct {
  @__u32()
  external int tuner;

  /// enum v4l2_tuner_type
  @__u32()
  external int type;

  @__u32()
  external int frequency;

  @ffi.Array.multi([8])
  external ffi.Array<__u32> reserved;
}

final class v4l2_frequency_band extends ffi.Struct {
  @__u32()
  external int tuner;

  /// enum v4l2_tuner_type
  @__u32()
  external int type;

  @__u32()
  external int index;

  @__u32()
  external int capability;

  @__u32()
  external int rangelow;

  @__u32()
  external int rangehigh;

  @__u32()
  external int modulation;

  @ffi.Array.multi([9])
  external ffi.Array<__u32> reserved;
}

final class v4l2_hw_freq_seek extends ffi.Struct {
  @__u32()
  external int tuner;

  /// enum v4l2_tuner_type
  @__u32()
  external int type;

  @__u32()
  external int seek_upward;

  @__u32()
  external int wrap_around;

  @__u32()
  external int spacing;

  @__u32()
  external int rangelow;

  @__u32()
  external int rangehigh;

  @ffi.Array.multi([5])
  external ffi.Array<__u32> reserved;
}

/// R D S
@ffi.Packed(1)
final class v4l2_rds_data extends ffi.Struct {
  @__u8()
  external int lsb;

  @__u8()
  external int msb;

  @__u8()
  external int block;
}

/// A U D I O
final class v4l2_audio extends ffi.Struct {
  @__u32()
  external int index;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  @__u32()
  external int capability;

  @__u32()
  external int mode;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class v4l2_audioout extends ffi.Struct {
  @__u32()
  external int index;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  @__u32()
  external int capability;

  @__u32()
  external int mode;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class v4l2_enc_idx_entry extends ffi.Struct {
  @__u64()
  external int offset;

  @__u64()
  external int pts;

  @__u32()
  external int length;

  @__u32()
  external int flags;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class v4l2_enc_idx extends ffi.Struct {
  @__u32()
  external int entries;

  @__u32()
  external int entries_cap;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> reserved;

  @ffi.Array.multi([64])
  external ffi.Array<v4l2_enc_idx_entry> entry;
}

final class v4l2_encoder_cmd extends ffi.Struct {
  @__u32()
  external int cmd;

  @__u32()
  external int flags;

  external UnnamedUnion12 unnamed;
}

final class UnnamedUnion12 extends ffi.Union {
  external UnnamedStruct2 raw;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<__u32> data;
}

/// The structure must be zeroed before use by the application
/// This ensures it can be extended safely in the future.
final class v4l2_decoder_cmd extends ffi.Struct {
  @__u32()
  external int cmd;

  @__u32()
  external int flags;

  external UnnamedUnion13 unnamed;
}

final class UnnamedUnion13 extends ffi.Union {
  external UnnamedStruct3 stop;

  external UnnamedStruct4 start;

  external UnnamedStruct5 raw;
}

final class UnnamedStruct3 extends ffi.Struct {
  @__u64()
  external int pts;
}

final class UnnamedStruct4 extends ffi.Struct {
  /// 0 or 1000 specifies normal speed,
  /// 1 specifies forward single stepping,
  /// -1 specifies backward single stepping,
  /// >1: playback at speed/1000 of the normal speed,
  /// <-1: reverse playback at (-speed/1000) of the normal speed.
  @__s32()
  external int speed;

  @__u32()
  external int format;
}

final class UnnamedStruct5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__u32> data;
}

/// Raw VBI
final class v4l2_vbi_format extends ffi.Struct {
  /// in 1 Hz
  @__u32()
  external int sampling_rate;

  @__u32()
  external int offset;

  @__u32()
  external int samples_per_line;

  /// V4L2_PIX_FMT_*
  @__u32()
  external int sample_format;

  @ffi.Array.multi([2])
  external ffi.Array<__s32> start;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> count;

  /// V4L2_VBI_*
  @__u32()
  external int flags;

  /// must be zero
  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

/// Sliced VBI
///
/// This implements is a proposal V4L2 API to allow SLICED VBI
/// required for some hardware encoders. It should change without
/// notice in the definitive implementation.
final class v4l2_sliced_vbi_format extends ffi.Struct {
  @__u16()
  external int service_set;

  /// service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
  /// service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
  /// (equals frame lines 313-336 for 625 line video
  /// standards, 263-286 for 525 line standards)
  @ffi.Array.multi([2, 24])
  external ffi.Array<ffi.Array<__u16>> service_lines;

  @__u32()
  external int io_size;

  /// must be zero
  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class v4l2_sliced_vbi_cap extends ffi.Struct {
  @__u16()
  external int service_set;

  /// service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
  /// service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
  /// (equals frame lines 313-336 for 625 line video
  /// standards, 263-286 for 525 line standards)
  @ffi.Array.multi([2, 24])
  external ffi.Array<ffi.Array<__u16>> service_lines;

  /// enum v4l2_buf_type
  @__u32()
  external int type;

  /// must be 0
  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

final class v4l2_sliced_vbi_data extends ffi.Struct {
  @__u32()
  external int id;

  /// 0: first field, 1: second field
  @__u32()
  external int field;

  /// 1-23
  @__u32()
  external int line;

  /// must be 0
  @__u32()
  external int reserved;

  @ffi.Array.multi([48])
  external ffi.Array<__u8> data;
}

@ffi.Packed(1)
final class v4l2_mpeg_vbi_itv0_line extends ffi.Struct {
  /// One of V4L2_MPEG_VBI_IVTV_* above
  @__u8()
  external int id;

  /// Sliced VBI data for the line
  @ffi.Array.multi([42])
  external ffi.Array<__u8> data;
}

@ffi.Packed(1)
final class v4l2_mpeg_vbi_itv0 extends ffi.Struct {
  /// Bitmasks of VBI service lines present
  @ffi.Array.multi([2])
  external ffi.Array<__le32> linemask;

  @ffi.Array.multi([35])
  external ffi.Array<v4l2_mpeg_vbi_itv0_line> line;
}

typedef __le32 = __u32;

@ffi.Packed(1)
final class v4l2_mpeg_vbi_ITV0 extends ffi.Struct {
  @ffi.Array.multi([36])
  external ffi.Array<v4l2_mpeg_vbi_itv0_line> line;
}

@ffi.Packed(1)
final class v4l2_mpeg_vbi_fmt_ivtv extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__u8> magic;

  external UnnamedUnion14 unnamed;
}

final class UnnamedUnion14 extends ffi.Union {
  external v4l2_mpeg_vbi_itv0 itv0;

  external v4l2_mpeg_vbi_ITV0 ITV0;
}

/// struct v4l2_plane_pix_format - additional, per-plane format definition
/// @sizeimage:		maximum size in bytes required for data, for which
/// this plane will be used
/// @bytesperline:	distance in bytes between the leftmost pixels in two
/// adjacent lines
/// @reserved:		drivers and applications must zero this array
@ffi.Packed(1)
final class v4l2_plane_pix_format extends ffi.Struct {
  @__u32()
  external int sizeimage;

  @__u32()
  external int bytesperline;

  @ffi.Array.multi([6])
  external ffi.Array<__u16> reserved;
}

/// struct v4l2_pix_format_mplane - multiplanar format definition
/// @width:		image width in pixels
/// @height:		image height in pixels
/// @pixelformat:	little endian four character code (fourcc)
/// @field:		enum v4l2_field; field order (for interlaced video)
/// @colorspace:		enum v4l2_colorspace; supplemental to pixelformat
/// @plane_fmt:		per-plane information
/// @num_planes:		number of planes for this format
/// @flags:		format flags (V4L2_PIX_FMT_FLAG_*)
/// @ycbcr_enc:		enum v4l2_ycbcr_encoding, Y'CbCr encoding
/// @hsv_enc:		enum v4l2_hsv_encoding, HSV encoding
/// @quantization:	enum v4l2_quantization, colorspace quantization
/// @xfer_func:		enum v4l2_xfer_func, colorspace transfer function
/// @reserved:		drivers and applications must zero this array
@ffi.Packed(1)
final class v4l2_pix_format_mplane extends ffi.Struct {
  @__u32()
  external int width;

  @__u32()
  external int height;

  @__u32()
  external int pixelformat;

  @__u32()
  external int field;

  @__u32()
  external int colorspace;

  @ffi.Array.multi([8])
  external ffi.Array<v4l2_plane_pix_format> plane_fmt;

  @__u8()
  external int num_planes;

  @__u8()
  external int flags;

  external UnnamedUnion15 unnamed;

  @__u8()
  external int quantization;

  @__u8()
  external int xfer_func;

  @ffi.Array.multi([7])
  external ffi.Array<__u8> reserved;
}

final class UnnamedUnion15 extends ffi.Union {
  @__u8()
  external int ycbcr_enc;

  @__u8()
  external int hsv_enc;
}

/// struct v4l2_sdr_format - SDR format definition
/// @pixelformat:	little endian four character code (fourcc)
/// @buffersize:		maximum size in bytes required for data
/// @reserved:		drivers and applications must zero this array
@ffi.Packed(1)
final class v4l2_sdr_format extends ffi.Struct {
  @__u32()
  external int pixelformat;

  @__u32()
  external int buffersize;

  @ffi.Array.multi([24])
  external ffi.Array<__u8> reserved;
}

/// struct v4l2_meta_format - metadata format definition
/// @dataformat:		little endian four character code (fourcc)
/// @buffersize:		maximum size in bytes required for data
@ffi.Packed(1)
final class v4l2_meta_format extends ffi.Struct {
  @__u32()
  external int dataformat;

  @__u32()
  external int buffersize;
}

/// struct v4l2_format - stream data format
/// @type:	enum v4l2_buf_type; type of the data stream
/// @pix:	definition of an image format
/// @pix_mp:	definition of a multiplanar image format
/// @win:	definition of an overlaid image
/// @vbi:	raw VBI capture or output parameters
/// @sliced:	sliced VBI capture or output parameters
/// @raw_data:	placeholder for future extensions and custom formats
/// @fmt:	union of @pix, @pix_mp, @win, @vbi, @sliced, @sdr, @meta
/// and @raw_data
final class v4l2_format extends ffi.Struct {
  @__u32()
  external int type;

  external UnnamedUnion16 fmt;
}

final class UnnamedUnion16 extends ffi.Union {
  /// V4L2_BUF_TYPE_VIDEO_CAPTURE
  external v4l2_pix_format pix;

  /// V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE
  external v4l2_pix_format_mplane pix_mp;

  /// V4L2_BUF_TYPE_VIDEO_OVERLAY
  external v4l2_window win;

  /// V4L2_BUF_TYPE_VBI_CAPTURE
  external v4l2_vbi_format vbi;

  /// V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
  external v4l2_sliced_vbi_format sliced;

  /// V4L2_BUF_TYPE_SDR_CAPTURE
  external v4l2_sdr_format sdr;

  /// V4L2_BUF_TYPE_META_CAPTURE
  external v4l2_meta_format meta;

  /// user-defined
  @ffi.Array.multi([200])
  external ffi.Array<__u8> raw_data;
}

/// Stream type-dependent parameters
final class v4l2_streamparm extends ffi.Struct {
  /// enum v4l2_buf_type
  @__u32()
  external int type;

  external UnnamedUnion17 parm;
}

final class UnnamedUnion17 extends ffi.Union {
  external v4l2_captureparm capture;

  external v4l2_outputparm output;

  /// user-defined
  @ffi.Array.multi([200])
  external ffi.Array<__u8> raw_data;
}

/// Payload for V4L2_EVENT_VSYNC
@ffi.Packed(1)
final class v4l2_event_vsync extends ffi.Struct {
  /// Can be V4L2_FIELD_ANY, _NONE, _TOP or _BOTTOM
  @__u8()
  external int field;
}

final class v4l2_event_ctrl extends ffi.Struct {
  @__u32()
  external int changes;

  @__u32()
  external int type;

  external UnnamedUnion18 unnamed;

  @__u32()
  external int flags;

  @__s32()
  external int minimum;

  @__s32()
  external int maximum;

  @__s32()
  external int step;

  @__s32()
  external int default_value;
}

final class UnnamedUnion18 extends ffi.Union {
  @__s32()
  external int value;

  @__s64()
  external int value64;
}

final class v4l2_event_frame_sync extends ffi.Struct {
  @__u32()
  external int frame_sequence;
}

final class v4l2_event_src_change extends ffi.Struct {
  @__u32()
  external int changes;
}

/// struct v4l2_event_motion_det - motion detection event
/// @flags:             if V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ is set, then the
/// frame_sequence field is valid.
/// @frame_sequence:    the frame sequence number associated with this event.
/// @region_mask:       which regions detected motion.
final class v4l2_event_motion_det extends ffi.Struct {
  @__u32()
  external int flags;

  @__u32()
  external int frame_sequence;

  @__u32()
  external int region_mask;
}

final class v4l2_event extends ffi.Struct {
  @__u32()
  external int type;

  external UnnamedUnion19 u;

  @__u32()
  external int pending;

  @__u32()
  external int sequence;

  external timespec timestamp;

  @__u32()
  external int id;

  @ffi.Array.multi([8])
  external ffi.Array<__u32> reserved;
}

final class UnnamedUnion19 extends ffi.Union {
  external v4l2_event_vsync vsync;

  external v4l2_event_ctrl ctrl;

  external v4l2_event_frame_sync frame_sync;

  external v4l2_event_src_change src_change;

  external v4l2_event_motion_det motion_det;

  @ffi.Array.multi([64])
  external ffi.Array<__u8> data;
}

final class timespec extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__syscall_slong_t()
  external int tv_nsec;
}

typedef __syscall_slong_t = ffi.Long;
typedef Dart__syscall_slong_t = int;

final class v4l2_event_subscription extends ffi.Struct {
  @__u32()
  external int type;

  @__u32()
  external int id;

  @__u32()
  external int flags;

  @ffi.Array.multi([5])
  external ffi.Array<__u32> reserved;
}

@ffi.Packed(1)
final class v4l2_dbg_match extends ffi.Struct {
  /// Match type
  @__u32()
  external int type;

  external UnnamedUnion20 unnamed;
}

final class UnnamedUnion20 extends ffi.Union {
  @__u32()
  external int addr;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;
}

@ffi.Packed(1)
final class v4l2_dbg_register extends ffi.Struct {
  external v4l2_dbg_match match;

  /// register size in bytes
  @__u32()
  external int size;

  @__u64()
  external int reg;

  @__u64()
  external int val;
}

/// VIDIOC_DBG_G_CHIP_INFO
@ffi.Packed(1)
final class v4l2_dbg_chip_info extends ffi.Struct {
  external v4l2_dbg_match match;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;

  @__u32()
  external int flags;

  @ffi.Array.multi([32])
  external ffi.Array<__u32> reserved;
}

/// struct v4l2_create_buffers - VIDIOC_CREATE_BUFS argument
/// @index:	on return, index of the first created buffer
/// @count:	entry: number of requested buffers,
/// return: number of created buffers
/// @memory:	enum v4l2_memory; buffer memory type
/// @format:	frame format, for which buffers are requested
/// @capabilities: capabilities of this buffer type.
/// @flags:	additional buffer management attributes (ignored unless the
/// queue has V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS capability
/// and configured for MMAP streaming I/O).
/// @max_num_buffers: if V4L2_BUF_CAP_SUPPORTS_MAX_NUM_BUFFERS capability flag is set
/// this field indicate the maximum possible number of buffers
/// for this queue.
/// @reserved:	future extensions
final class v4l2_create_buffers extends ffi.Struct {
  @__u32()
  external int index;

  @__u32()
  external int count;

  @__u32()
  external int memory;

  external v4l2_format format;

  @__u32()
  external int capabilities;

  @__u32()
  external int flags;

  @__u32()
  external int max_num_buffers;

  @ffi.Array.multi([5])
  external ffi.Array<__u32> reserved;
}

const int _FCNTL_H = 1;

const int S_IFMT = 61440;

const int S_IFDIR = 16384;

const int S_IFCHR = 8192;

const int S_IFBLK = 24576;

const int S_IFREG = 32768;

const int S_IFIFO = 4096;

const int S_IFLNK = 40960;

const int S_IFSOCK = 49152;

const int S_ISUID = 2048;

const int S_ISGID = 1024;

const int S_ISVTX = 512;

const int S_IRUSR = 256;

const int S_IWUSR = 128;

const int S_IXUSR = 64;

const int S_IRWXU = 448;

const int S_IRGRP = 32;

const int S_IWGRP = 16;

const int S_IXGRP = 8;

const int S_IRWXG = 56;

const int S_IROTH = 4;

const int S_IWOTH = 2;

const int S_IXOTH = 1;

const int S_IRWXO = 7;

const int R_OK = 4;

const int W_OK = 2;

const int X_OK = 1;

const int F_OK = 0;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int AT_FDCWD = -100;

const int AT_SYMLINK_NOFOLLOW = 256;

const int AT_REMOVEDIR = 512;

const int AT_SYMLINK_FOLLOW = 1024;

const int AT_EACCESS = 512;

const int F_ULOCK = 0;

const int F_LOCK = 1;

const int F_TLOCK = 2;

const int F_TEST = 3;

const int _UNISTD_H = 1;

const int _POSIX_VERSION = 200809;

const int __POSIX2_THIS_VERSION = 200809;

const int _POSIX2_VERSION = 200809;

const int _POSIX2_C_VERSION = 200809;

const int _POSIX2_C_BIND = 200809;

const int _POSIX2_C_DEV = 200809;

const int _POSIX2_SW_DEV = 200809;

const int _POSIX2_LOCALEDEF = 200809;

const int _XOPEN_VERSION = 700;

const int _XOPEN_XCU_VERSION = 4;

const int _XOPEN_XPG2 = 1;

const int _XOPEN_XPG3 = 1;

const int _XOPEN_XPG4 = 1;

const int _XOPEN_UNIX = 1;

const int _XOPEN_ENH_I18N = 1;

const int _XOPEN_LEGACY = 1;

const int STDIN_FILENO = 0;

const int STDOUT_FILENO = 1;

const int STDERR_FILENO = 2;

const int L_SET = 0;

const int L_INCR = 1;

const int L_XTND = 2;

const int O_ACCMODE = 3;

const int O_RDONLY = 0;

const int O_WRONLY = 1;

const int O_RDWR = 2;

const int O_CREAT = 64;

const int O_EXCL = 128;

const int O_NOCTTY = 256;

const int O_TRUNC = 512;

const int O_APPEND = 1024;

const int O_NONBLOCK = 2048;

const int O_DSYNC = 4096;

const int FASYNC = 8192;

const int O_DIRECT = 16384;

const int O_LARGEFILE = 0;

const int O_DIRECTORY = 65536;

const int O_NOFOLLOW = 131072;

const int O_NOATIME = 262144;

const int O_CLOEXEC = 524288;

const int O_SYNC = 1052672;

const int O_PATH = 2097152;

const int __O_TMPFILE = 4259840;

const int O_TMPFILE = 4259840;

const int O_NDELAY = 2048;

const int F_DUPFD = 0;

const int F_GETFD = 1;

const int F_SETFD = 2;

const int F_GETFL = 3;

const int F_SETFL = 4;

const int F_GETLK = 5;

const int F_SETLK = 6;

const int F_SETLKW = 7;

const int F_SETOWN = 8;

const int F_GETOWN = 9;

const int F_SETSIG = 10;

const int F_GETSIG = 11;

const int F_GETLK64 = 5;

const int F_SETLK64 = 6;

const int F_SETLKW64 = 7;

const int F_SETOWN_EX = 15;

const int F_GETOWN_EX = 16;

const int F_GETOWNER_UIDS = 17;

const int F_OFD_GETLK = 36;

const int F_OFD_SETLK = 37;

const int F_OFD_SETLKW = 38;

const int F_OWNER_TID = 0;

const int F_OWNER_PID = 1;

const int F_OWNER_PGRP = 2;

const int FD_CLOEXEC = 1;

const int F_RDLCK = 0;

const int F_WRLCK = 1;

const int F_UNLCK = 2;

const int F_EXLCK = 4;

const int F_SHLCK = 8;

const int LOCK_SH = 1;

const int LOCK_EX = 2;

const int LOCK_NB = 4;

const int LOCK_UN = 8;

const int LOCK_MAND = 32;

const int LOCK_READ = 64;

const int LOCK_WRITE = 128;

const int LOCK_RW = 192;

const int F_LINUX_SPECIFIC_BASE = 1024;

const int _SYS_IOCTL_H = 1;

const int VIDEO_MAX_FRAME = 32;

const int VIDEO_MAX_PLANES = 8;

const int V4L2_TUNER_ADC = 4;

const int V4L2_COLORSPACE_ADOBERGB = 9;

const int V4L2_XFER_FUNC_ADOBERGB = 3;

const int V4L2_CAP_VIDEO_CAPTURE = 1;

const int V4L2_CAP_VIDEO_OUTPUT = 2;

const int V4L2_CAP_VIDEO_OVERLAY = 4;

const int V4L2_CAP_VBI_CAPTURE = 16;

const int V4L2_CAP_VBI_OUTPUT = 32;

const int V4L2_CAP_SLICED_VBI_CAPTURE = 64;

const int V4L2_CAP_SLICED_VBI_OUTPUT = 128;

const int V4L2_CAP_RDS_CAPTURE = 256;

const int V4L2_CAP_VIDEO_OUTPUT_OVERLAY = 512;

const int V4L2_CAP_HW_FREQ_SEEK = 1024;

const int V4L2_CAP_RDS_OUTPUT = 2048;

const int V4L2_CAP_VIDEO_CAPTURE_MPLANE = 4096;

const int V4L2_CAP_VIDEO_OUTPUT_MPLANE = 8192;

const int V4L2_CAP_VIDEO_M2M_MPLANE = 16384;

const int V4L2_CAP_VIDEO_M2M = 32768;

const int V4L2_CAP_TUNER = 65536;

const int V4L2_CAP_AUDIO = 131072;

const int V4L2_CAP_RADIO = 262144;

const int V4L2_CAP_MODULATOR = 524288;

const int V4L2_CAP_SDR_CAPTURE = 1048576;

const int V4L2_CAP_EXT_PIX_FORMAT = 2097152;

const int V4L2_CAP_SDR_OUTPUT = 4194304;

const int V4L2_CAP_META_CAPTURE = 8388608;

const int V4L2_CAP_READWRITE = 16777216;

const int V4L2_CAP_STREAMING = 67108864;

const int V4L2_CAP_META_OUTPUT = 134217728;

const int V4L2_CAP_TOUCH = 268435456;

const int V4L2_CAP_IO_MC = 536870912;

const int V4L2_CAP_DEVICE_CAPS = 2147483648;

const int V4L2_PIX_FMT_RGB332 = 826427218;

const int V4L2_PIX_FMT_RGB444 = 875836498;

const int V4L2_PIX_FMT_ARGB444 = 842093121;

const int V4L2_PIX_FMT_XRGB444 = 842093144;

const int V4L2_PIX_FMT_RGBA444 = 842088786;

const int V4L2_PIX_FMT_RGBX444 = 842094674;

const int V4L2_PIX_FMT_ABGR444 = 842089025;

const int V4L2_PIX_FMT_XBGR444 = 842089048;

const int V4L2_PIX_FMT_BGRA444 = 842088775;

const int V4L2_PIX_FMT_BGRX444 = 842094658;

const int V4L2_PIX_FMT_RGB555 = 1329743698;

const int V4L2_PIX_FMT_ARGB555 = 892424769;

const int V4L2_PIX_FMT_XRGB555 = 892424792;

const int V4L2_PIX_FMT_RGBA555 = 892420434;

const int V4L2_PIX_FMT_RGBX555 = 892426322;

const int V4L2_PIX_FMT_ABGR555 = 892420673;

const int V4L2_PIX_FMT_XBGR555 = 892420696;

const int V4L2_PIX_FMT_BGRA555 = 892420418;

const int V4L2_PIX_FMT_BGRX555 = 892426306;

const int V4L2_PIX_FMT_RGB565 = 1346520914;

const int V4L2_PIX_FMT_RGB555X = 1363298130;

const int V4L2_PIX_FMT_ARGB555X = 3039908417;

const int V4L2_PIX_FMT_XRGB555X = 3039908440;

const int V4L2_PIX_FMT_RGB565X = 1380075346;

const int V4L2_PIX_FMT_BGR666 = 1213351746;

const int V4L2_PIX_FMT_BGR24 = 861030210;

const int V4L2_PIX_FMT_RGB24 = 859981650;

const int V4L2_PIX_FMT_BGR32 = 877807426;

const int V4L2_PIX_FMT_ABGR32 = 875713089;

const int V4L2_PIX_FMT_XBGR32 = 875713112;

const int V4L2_PIX_FMT_BGRA32 = 875708754;

const int V4L2_PIX_FMT_BGRX32 = 875714642;

const int V4L2_PIX_FMT_RGB32 = 876758866;

const int V4L2_PIX_FMT_RGBA32 = 875708993;

const int V4L2_PIX_FMT_RGBX32 = 875709016;

const int V4L2_PIX_FMT_ARGB32 = 875708738;

const int V4L2_PIX_FMT_XRGB32 = 875714626;

const int V4L2_PIX_FMT_RGBX1010102 = 808671314;

const int V4L2_PIX_FMT_RGBA1010102 = 808665426;

const int V4L2_PIX_FMT_ARGB2101010 = 808669761;

const int V4L2_PIX_FMT_BGR48_12 = 842085186;

const int V4L2_PIX_FMT_ABGR64_12 = 842085442;

const int V4L2_PIX_FMT_GREY = 1497715271;

const int V4L2_PIX_FMT_Y4 = 540291161;

const int V4L2_PIX_FMT_Y6 = 540422233;

const int V4L2_PIX_FMT_Y10 = 540029273;

const int V4L2_PIX_FMT_Y12 = 540160345;

const int V4L2_PIX_FMT_Y012 = 842084441;

const int V4L2_PIX_FMT_Y14 = 540291417;

const int V4L2_PIX_FMT_Y16 = 540422489;

const int V4L2_PIX_FMT_Y16_BE = 2687906137;

const int V4L2_PIX_FMT_Y10BPACK = 1110454617;

const int V4L2_PIX_FMT_Y10P = 1345335641;

const int V4L2_PIX_FMT_IPU3_Y10 = 2033414249;

const int V4L2_PIX_FMT_PAL8 = 944521552;

const int V4L2_PIX_FMT_UV8 = 540563029;

const int V4L2_PIX_FMT_YUYV = 1448695129;

const int V4L2_PIX_FMT_YYUV = 1448434009;

const int V4L2_PIX_FMT_YVYU = 1431918169;

const int V4L2_PIX_FMT_UYVY = 1498831189;

const int V4L2_PIX_FMT_VYUY = 1498765654;

const int V4L2_PIX_FMT_Y41P = 1345401945;

const int V4L2_PIX_FMT_YUV444 = 875836505;

const int V4L2_PIX_FMT_YUV555 = 1331058009;

const int V4L2_PIX_FMT_YUV565 = 1347835225;

const int V4L2_PIX_FMT_YUV24 = 861295961;

const int V4L2_PIX_FMT_YUV32 = 878073177;

const int V4L2_PIX_FMT_AYUV32 = 1448433985;

const int V4L2_PIX_FMT_XYUV32 = 1448434008;

const int V4L2_PIX_FMT_VUYA32 = 1096373590;

const int V4L2_PIX_FMT_VUYX32 = 1482249558;

const int V4L2_PIX_FMT_YUVA32 = 1096176985;

const int V4L2_PIX_FMT_YUVX32 = 1482052953;

const int V4L2_PIX_FMT_M420 = 808596557;

const int V4L2_PIX_FMT_YUV48_12 = 842085209;

const int V4L2_PIX_FMT_Y210 = 808530521;

const int V4L2_PIX_FMT_Y212 = 842084953;

const int V4L2_PIX_FMT_Y216 = 909193817;

const int V4L2_PIX_FMT_NV12 = 842094158;

const int V4L2_PIX_FMT_NV21 = 825382478;

const int V4L2_PIX_FMT_NV16 = 909203022;

const int V4L2_PIX_FMT_NV61 = 825644622;

const int V4L2_PIX_FMT_NV24 = 875714126;

const int V4L2_PIX_FMT_NV42 = 842290766;

const int V4L2_PIX_FMT_P010 = 808530000;

const int V4L2_PIX_FMT_P012 = 842084432;

const int V4L2_PIX_FMT_NV12M = 842091854;

const int V4L2_PIX_FMT_NV21M = 825380174;

const int V4L2_PIX_FMT_NV16M = 909200718;

const int V4L2_PIX_FMT_NV61M = 825642318;

const int V4L2_PIX_FMT_P012M = 842091856;

const int V4L2_PIX_FMT_YUV410 = 961959257;

const int V4L2_PIX_FMT_YVU410 = 961893977;

const int V4L2_PIX_FMT_YUV411P = 1345401140;

const int V4L2_PIX_FMT_YUV420 = 842093913;

const int V4L2_PIX_FMT_YVU420 = 842094169;

const int V4L2_PIX_FMT_YUV422P = 1345466932;

const int V4L2_PIX_FMT_YUV420M = 842091865;

const int V4L2_PIX_FMT_YVU420M = 825380185;

const int V4L2_PIX_FMT_YUV422M = 909200729;

const int V4L2_PIX_FMT_YVU422M = 825642329;

const int V4L2_PIX_FMT_YUV444M = 875711833;

const int V4L2_PIX_FMT_YVU444M = 842288473;

const int V4L2_PIX_FMT_NV12_4L4 = 842093654;

const int V4L2_PIX_FMT_NV12_16L16 = 842091848;

const int V4L2_PIX_FMT_NV12_32L32 = 842093651;

const int V4L2_PIX_FMT_NV15_4L4 = 892425302;

const int V4L2_PIX_FMT_P010_4L4 = 808530004;

const int V4L2_PIX_FMT_NV12_8L128 = 842093633;

const int V4L2_PIX_FMT_NV12_10BE_8L128 = 2989578305;

const int V4L2_PIX_FMT_NV12MT = 842091860;

const int V4L2_PIX_FMT_NV12MT_16X16 = 842091862;

const int V4L2_PIX_FMT_NV12M_8L128 = 842088782;

const int V4L2_PIX_FMT_NV12M_10BE_8L128 = 2989577294;

const int V4L2_PIX_FMT_SBGGR8 = 825770306;

const int V4L2_PIX_FMT_SGBRG8 = 1196573255;

const int V4L2_PIX_FMT_SGRBG8 = 1195528775;

const int V4L2_PIX_FMT_SRGGB8 = 1111967570;

const int V4L2_PIX_FMT_SBGGR10 = 808535874;

const int V4L2_PIX_FMT_SGBRG10 = 808534599;

const int V4L2_PIX_FMT_SGRBG10 = 808534338;

const int V4L2_PIX_FMT_SRGGB10 = 808535890;

const int V4L2_PIX_FMT_SBGGR10P = 1094795888;

const int V4L2_PIX_FMT_SGBRG10P = 1094797168;

const int V4L2_PIX_FMT_SGRBG10P = 1094805360;

const int V4L2_PIX_FMT_SRGGB10P = 1094799984;

const int V4L2_PIX_FMT_SBGGR10ALAW8 = 943800929;

const int V4L2_PIX_FMT_SGBRG10ALAW8 = 943802209;

const int V4L2_PIX_FMT_SGRBG10ALAW8 = 943810401;

const int V4L2_PIX_FMT_SRGGB10ALAW8 = 943805025;

const int V4L2_PIX_FMT_SBGGR10DPCM8 = 943800930;

const int V4L2_PIX_FMT_SGBRG10DPCM8 = 943802210;

const int V4L2_PIX_FMT_SGRBG10DPCM8 = 808535106;

const int V4L2_PIX_FMT_SRGGB10DPCM8 = 943805026;

const int V4L2_PIX_FMT_SBGGR12 = 842090306;

const int V4L2_PIX_FMT_SGBRG12 = 842089031;

const int V4L2_PIX_FMT_SGRBG12 = 842088770;

const int V4L2_PIX_FMT_SRGGB12 = 842090322;

const int V4L2_PIX_FMT_SBGGR12P = 1128481392;

const int V4L2_PIX_FMT_SGBRG12P = 1128482672;

const int V4L2_PIX_FMT_SGRBG12P = 1128490864;

const int V4L2_PIX_FMT_SRGGB12P = 1128485488;

const int V4L2_PIX_FMT_SBGGR14 = 875644738;

const int V4L2_PIX_FMT_SGBRG14 = 875643463;

const int V4L2_PIX_FMT_SGRBG14 = 875647559;

const int V4L2_PIX_FMT_SRGGB14 = 875644754;

const int V4L2_PIX_FMT_SBGGR14P = 1162166896;

const int V4L2_PIX_FMT_SGBRG14P = 1162168176;

const int V4L2_PIX_FMT_SGRBG14P = 1162176368;

const int V4L2_PIX_FMT_SRGGB14P = 1162170992;

const int V4L2_PIX_FMT_SBGGR16 = 844257602;

const int V4L2_PIX_FMT_SGBRG16 = 909197895;

const int V4L2_PIX_FMT_SGRBG16 = 909201991;

const int V4L2_PIX_FMT_SRGGB16 = 909199186;

const int V4L2_PIX_FMT_HSV24 = 861295432;

const int V4L2_PIX_FMT_HSV32 = 878072648;

const int V4L2_PIX_FMT_MJPEG = 1196444237;

const int V4L2_PIX_FMT_JPEG = 1195724874;

const int V4L2_PIX_FMT_DV = 1685288548;

const int V4L2_PIX_FMT_MPEG = 1195724877;

const int V4L2_PIX_FMT_H264 = 875967048;

const int V4L2_PIX_FMT_H264_NO_SC = 826496577;

const int V4L2_PIX_FMT_H264_MVC = 875967053;

const int V4L2_PIX_FMT_H263 = 859189832;

const int V4L2_PIX_FMT_MPEG1 = 826757197;

const int V4L2_PIX_FMT_MPEG2 = 843534413;

const int V4L2_PIX_FMT_MPEG2_SLICE = 1395803981;

const int V4L2_PIX_FMT_MPEG4 = 877088845;

const int V4L2_PIX_FMT_XVID = 1145656920;

const int V4L2_PIX_FMT_VC1_ANNEX_G = 1194410838;

const int V4L2_PIX_FMT_VC1_ANNEX_L = 1278296918;

const int V4L2_PIX_FMT_VP8 = 808996950;

const int V4L2_PIX_FMT_VP8_FRAME = 1178095702;

const int V4L2_PIX_FMT_VP9 = 809062486;

const int V4L2_PIX_FMT_VP9_FRAME = 1178161238;

const int V4L2_PIX_FMT_HEVC = 1129727304;

const int V4L2_PIX_FMT_FWHT = 1414027078;

const int V4L2_PIX_FMT_FWHT_STATELESS = 1213679187;

const int V4L2_PIX_FMT_H264_SLICE = 875967059;

const int V4L2_PIX_FMT_HEVC_SLICE = 892744275;

const int V4L2_PIX_FMT_AV1_FRAME = 1177638465;

const int V4L2_PIX_FMT_SPK = 810242131;

const int V4L2_PIX_FMT_RV30 = 808670802;

const int V4L2_PIX_FMT_RV40 = 808736338;

const int V4L2_PIX_FMT_CPIA1 = 1095323715;

const int V4L2_PIX_FMT_WNVA = 1096175191;

const int V4L2_PIX_FMT_SN9C10X = 808532307;

const int V4L2_PIX_FMT_SN9C20X_I420 = 808597843;

const int V4L2_PIX_FMT_PWC1 = 826496848;

const int V4L2_PIX_FMT_PWC2 = 843274064;

const int V4L2_PIX_FMT_ET61X251 = 892483141;

const int V4L2_PIX_FMT_SPCA501 = 825242963;

const int V4L2_PIX_FMT_SPCA505 = 892351827;

const int V4L2_PIX_FMT_SPCA508 = 942683475;

const int V4L2_PIX_FMT_SPCA561 = 825636179;

const int V4L2_PIX_FMT_PAC207 = 925905488;

const int V4L2_PIX_FMT_MR97310A = 808530765;

const int V4L2_PIX_FMT_JL2005BCD = 808602698;

const int V4L2_PIX_FMT_SN9C2028 = 1481527123;

const int V4L2_PIX_FMT_SQ905C = 1127559225;

const int V4L2_PIX_FMT_PJPG = 1196444240;

const int V4L2_PIX_FMT_OV511 = 825308495;

const int V4L2_PIX_FMT_OV518 = 942749007;

const int V4L2_PIX_FMT_STV0680 = 808990291;

const int V4L2_PIX_FMT_TM6000 = 808865108;

const int V4L2_PIX_FMT_CIT_YYVYUY = 1448364355;

const int V4L2_PIX_FMT_KONICA420 = 1229868875;

const int V4L2_PIX_FMT_JPGL = 1279742026;

const int V4L2_PIX_FMT_SE401 = 825242707;

const int V4L2_PIX_FMT_S5C_UYVY_JPG = 1229141331;

const int V4L2_PIX_FMT_Y8I = 541669465;

const int V4L2_PIX_FMT_Y12I = 1228026201;

const int V4L2_PIX_FMT_Z16 = 540422490;

const int V4L2_PIX_FMT_MT21C = 825381965;

const int V4L2_PIX_FMT_MM21 = 825380173;

const int V4L2_PIX_FMT_MT2110T = 1412584525;

const int V4L2_PIX_FMT_MT2110R = 1379030093;

const int V4L2_PIX_FMT_INZI = 1230655049;

const int V4L2_PIX_FMT_CNF4 = 877022787;

const int V4L2_PIX_FMT_HI240 = 875710792;

const int V4L2_PIX_FMT_QC08C = 1127755857;

const int V4L2_PIX_FMT_QC10C = 1127231825;

const int V4L2_PIX_FMT_AJPG = 1196444225;

const int V4L2_PIX_FMT_HEXTILE = 1280596040;

const int V4L2_PIX_FMT_IPU3_SBGGR10 = 1647538281;

const int V4L2_PIX_FMT_IPU3_SGBRG10 = 1731424361;

const int V4L2_PIX_FMT_IPU3_SGRBG10 = 1194553449;

const int V4L2_PIX_FMT_IPU3_SRGGB10 = 1915973737;

const int V4L2_SDR_FMT_CU8 = 942691651;

const int V4L2_SDR_FMT_CU16LE = 909202755;

const int V4L2_SDR_FMT_CS8 = 942691139;

const int V4L2_SDR_FMT_CS14LE = 875647811;

const int V4L2_SDR_FMT_RU12LE = 842093906;

const int V4L2_SDR_FMT_PCU16BE = 909198160;

const int V4L2_SDR_FMT_PCU18BE = 942752592;

const int V4L2_SDR_FMT_PCU20BE = 808600400;

const int V4L2_TCH_FMT_DELTA_TD16 = 909198420;

const int V4L2_TCH_FMT_DELTA_TD08 = 942687316;

const int V4L2_TCH_FMT_TU16 = 909202772;

const int V4L2_TCH_FMT_TU08 = 942691668;

const int V4L2_META_FMT_VSP1_HGO = 1213223766;

const int V4L2_META_FMT_VSP1_HGT = 1414550358;

const int V4L2_META_FMT_UVC = 1212372565;

const int V4L2_META_FMT_D4XX = 1482175556;

const int V4L2_META_FMT_VIVID = 1146505558;

const int V4L2_META_FMT_RK_ISP1_PARAMS = 1345407826;

const int V4L2_META_FMT_RK_ISP1_STAT_3A = 1395739474;

const int V4L2_PIX_FMT_PRIV_MAGIC = 4276996862;

const int V4L2_PIX_FMT_FLAG_PREMUL_ALPHA = 1;

const int V4L2_PIX_FMT_FLAG_SET_CSC = 2;

const int V4L2_FMT_FLAG_COMPRESSED = 1;

const int V4L2_FMT_FLAG_EMULATED = 2;

const int V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM = 4;

const int V4L2_FMT_FLAG_DYN_RESOLUTION = 8;

const int V4L2_FMT_FLAG_ENC_CAP_FRAME_INTERVAL = 16;

const int V4L2_FMT_FLAG_CSC_COLORSPACE = 32;

const int V4L2_FMT_FLAG_CSC_XFER_FUNC = 64;

const int V4L2_FMT_FLAG_CSC_YCBCR_ENC = 128;

const int V4L2_FMT_FLAG_CSC_HSV_ENC = 128;

const int V4L2_FMT_FLAG_CSC_QUANTIZATION = 256;

const int V4L2_TC_TYPE_24FPS = 1;

const int V4L2_TC_TYPE_25FPS = 2;

const int V4L2_TC_TYPE_30FPS = 3;

const int V4L2_TC_TYPE_50FPS = 4;

const int V4L2_TC_TYPE_60FPS = 5;

const int V4L2_TC_FLAG_DROPFRAME = 1;

const int V4L2_TC_FLAG_COLORFRAME = 2;

const int V4L2_TC_USERBITS_field = 12;

const int V4L2_TC_USERBITS_USERDEFINED = 0;

const int V4L2_TC_USERBITS_8BITCHARS = 8;

const int V4L2_JPEG_MARKER_DHT = 8;

const int V4L2_JPEG_MARKER_DQT = 16;

const int V4L2_JPEG_MARKER_DRI = 32;

const int V4L2_JPEG_MARKER_COM = 64;

const int V4L2_JPEG_MARKER_APP = 128;

const int V4L2_MEMORY_FLAG_NON_COHERENT = 1;

const int V4L2_BUF_CAP_SUPPORTS_MMAP = 1;

const int V4L2_BUF_CAP_SUPPORTS_USERPTR = 2;

const int V4L2_BUF_CAP_SUPPORTS_DMABUF = 4;

const int V4L2_BUF_CAP_SUPPORTS_REQUESTS = 8;

const int V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS = 16;

const int V4L2_BUF_CAP_SUPPORTS_M2M_HOLD_CAPTURE_BUF = 32;

const int V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS = 64;

const int V4L2_BUF_CAP_SUPPORTS_MAX_NUM_BUFFERS = 128;

const int V4L2_BUF_FLAG_MAPPED = 1;

const int V4L2_BUF_FLAG_QUEUED = 2;

const int V4L2_BUF_FLAG_DONE = 4;

const int V4L2_BUF_FLAG_KEYFRAME = 8;

const int V4L2_BUF_FLAG_PFRAME = 16;

const int V4L2_BUF_FLAG_BFRAME = 32;

const int V4L2_BUF_FLAG_ERROR = 64;

const int V4L2_BUF_FLAG_IN_REQUEST = 128;

const int V4L2_BUF_FLAG_TIMECODE = 256;

const int V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF = 512;

const int V4L2_BUF_FLAG_PREPARED = 1024;

const int V4L2_BUF_FLAG_NO_CACHE_INVALIDATE = 2048;

const int V4L2_BUF_FLAG_NO_CACHE_CLEAN = 4096;

const int V4L2_BUF_FLAG_TIMESTAMP_MASK = 57344;

const int V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN = 0;

const int V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC = 8192;

const int V4L2_BUF_FLAG_TIMESTAMP_COPY = 16384;

const int V4L2_BUF_FLAG_TSTAMP_SRC_MASK = 458752;

const int V4L2_BUF_FLAG_TSTAMP_SRC_EOF = 0;

const int V4L2_BUF_FLAG_TSTAMP_SRC_SOE = 65536;

const int V4L2_BUF_FLAG_LAST = 1048576;

const int V4L2_BUF_FLAG_REQUEST_FD = 8388608;

const int V4L2_FBUF_CAP_EXTERNOVERLAY = 1;

const int V4L2_FBUF_CAP_CHROMAKEY = 2;

const int V4L2_FBUF_CAP_LIST_CLIPPING = 4;

const int V4L2_FBUF_CAP_BITMAP_CLIPPING = 8;

const int V4L2_FBUF_CAP_LOCAL_ALPHA = 16;

const int V4L2_FBUF_CAP_GLOBAL_ALPHA = 32;

const int V4L2_FBUF_CAP_LOCAL_INV_ALPHA = 64;

const int V4L2_FBUF_CAP_SRC_CHROMAKEY = 128;

const int V4L2_FBUF_FLAG_PRIMARY = 1;

const int V4L2_FBUF_FLAG_OVERLAY = 2;

const int V4L2_FBUF_FLAG_CHROMAKEY = 4;

const int V4L2_FBUF_FLAG_LOCAL_ALPHA = 8;

const int V4L2_FBUF_FLAG_GLOBAL_ALPHA = 16;

const int V4L2_FBUF_FLAG_LOCAL_INV_ALPHA = 32;

const int V4L2_FBUF_FLAG_SRC_CHROMAKEY = 64;

const int V4L2_MODE_HIGHQUALITY = 1;

const int V4L2_CAP_TIMEPERFRAME = 4096;

const int V4L2_STD_PAL_B = 1;

const int V4L2_STD_PAL_B1 = 2;

const int V4L2_STD_PAL_G = 4;

const int V4L2_STD_PAL_H = 8;

const int V4L2_STD_PAL_I = 16;

const int V4L2_STD_PAL_D = 32;

const int V4L2_STD_PAL_D1 = 64;

const int V4L2_STD_PAL_K = 128;

const int V4L2_STD_PAL_M = 256;

const int V4L2_STD_PAL_N = 512;

const int V4L2_STD_PAL_Nc = 1024;

const int V4L2_STD_PAL_60 = 2048;

const int V4L2_STD_NTSC_M = 4096;

const int V4L2_STD_NTSC_M_JP = 8192;

const int V4L2_STD_NTSC_443 = 16384;

const int V4L2_STD_NTSC_M_KR = 32768;

const int V4L2_STD_SECAM_B = 65536;

const int V4L2_STD_SECAM_D = 131072;

const int V4L2_STD_SECAM_G = 262144;

const int V4L2_STD_SECAM_H = 524288;

const int V4L2_STD_SECAM_K = 1048576;

const int V4L2_STD_SECAM_K1 = 2097152;

const int V4L2_STD_SECAM_L = 4194304;

const int V4L2_STD_SECAM_LC = 8388608;

const int V4L2_STD_ATSC_8_VSB = 16777216;

const int V4L2_STD_ATSC_16_VSB = 33554432;

const int V4L2_STD_NTSC = 45056;

const int V4L2_STD_SECAM_DK = 3276800;

const int V4L2_STD_SECAM = 16711680;

const int V4L2_STD_PAL_BG = 7;

const int V4L2_STD_PAL_DK = 224;

const int V4L2_STD_PAL = 255;

const int V4L2_STD_B = 65539;

const int V4L2_STD_G = 262148;

const int V4L2_STD_H = 524296;

const int V4L2_STD_L = 12582912;

const int V4L2_STD_GH = 786444;

const int V4L2_STD_DK = 3277024;

const int V4L2_STD_BG = 327687;

const int V4L2_STD_MN = 46848;

const int V4L2_STD_MTS = 5888;

const int V4L2_STD_525_60 = 63744;

const int V4L2_STD_625_50 = 16713471;

const int V4L2_STD_ATSC = 50331648;

const int V4L2_STD_UNKNOWN = 0;

const int V4L2_STD_ALL = 16777215;

const int V4L2_DV_PROGRESSIVE = 0;

const int V4L2_DV_INTERLACED = 1;

const int V4L2_DV_VSYNC_POS_POL = 1;

const int V4L2_DV_HSYNC_POS_POL = 2;

const int V4L2_DV_BT_STD_CEA861 = 1;

const int V4L2_DV_BT_STD_DMT = 2;

const int V4L2_DV_BT_STD_CVT = 4;

const int V4L2_DV_BT_STD_GTF = 8;

const int V4L2_DV_BT_STD_SDI = 16;

const int V4L2_DV_FL_REDUCED_BLANKING = 1;

const int V4L2_DV_FL_CAN_REDUCE_FPS = 2;

const int V4L2_DV_FL_REDUCED_FPS = 4;

const int V4L2_DV_FL_HALF_LINE = 8;

const int V4L2_DV_FL_IS_CE_VIDEO = 16;

const int V4L2_DV_FL_FIRST_FIELD_EXTRA_LINE = 32;

const int V4L2_DV_FL_HAS_PICTURE_ASPECT = 64;

const int V4L2_DV_FL_HAS_CEA861_VIC = 128;

const int V4L2_DV_FL_HAS_HDMI_VIC = 256;

const int V4L2_DV_FL_CAN_DETECT_REDUCED_FPS = 512;

const int V4L2_DV_BT_656_1120 = 0;

const int V4L2_DV_BT_CAP_INTERLACED = 1;

const int V4L2_DV_BT_CAP_PROGRESSIVE = 2;

const int V4L2_DV_BT_CAP_REDUCED_BLANKING = 4;

const int V4L2_DV_BT_CAP_CUSTOM = 8;

const int V4L2_INPUT_TYPE_TUNER = 1;

const int V4L2_INPUT_TYPE_CAMERA = 2;

const int V4L2_INPUT_TYPE_TOUCH = 3;

const int V4L2_IN_ST_NO_POWER = 1;

const int V4L2_IN_ST_NO_SIGNAL = 2;

const int V4L2_IN_ST_NO_COLOR = 4;

const int V4L2_IN_ST_HFLIP = 16;

const int V4L2_IN_ST_VFLIP = 32;

const int V4L2_IN_ST_NO_H_LOCK = 256;

const int V4L2_IN_ST_COLOR_KILL = 512;

const int V4L2_IN_ST_NO_V_LOCK = 1024;

const int V4L2_IN_ST_NO_STD_LOCK = 2048;

const int V4L2_IN_ST_NO_SYNC = 65536;

const int V4L2_IN_ST_NO_EQU = 131072;

const int V4L2_IN_ST_NO_CARRIER = 262144;

const int V4L2_IN_ST_MACROVISION = 16777216;

const int V4L2_IN_ST_NO_ACCESS = 33554432;

const int V4L2_IN_ST_VTR = 67108864;

const int V4L2_IN_CAP_DV_TIMINGS = 2;

const int V4L2_IN_CAP_CUSTOM_TIMINGS = 2;

const int V4L2_IN_CAP_STD = 4;

const int V4L2_IN_CAP_NATIVE_SIZE = 8;

const int V4L2_OUTPUT_TYPE_MODULATOR = 1;

const int V4L2_OUTPUT_TYPE_ANALOG = 2;

const int V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY = 3;

const int V4L2_OUT_CAP_DV_TIMINGS = 2;

const int V4L2_OUT_CAP_CUSTOM_TIMINGS = 2;

const int V4L2_OUT_CAP_STD = 4;

const int V4L2_OUT_CAP_NATIVE_SIZE = 8;

const int V4L2_CTRL_ID_MASK = 268435455;

const int V4L2_CTRL_MAX_DIMS = 4;

const int V4L2_CTRL_WHICH_CUR_VAL = 0;

const int V4L2_CTRL_WHICH_DEF_VAL = 251658240;

const int V4L2_CTRL_WHICH_REQUEST_VAL = 251723776;

const int V4L2_CTRL_FLAG_DISABLED = 1;

const int V4L2_CTRL_FLAG_GRABBED = 2;

const int V4L2_CTRL_FLAG_READ_ONLY = 4;

const int V4L2_CTRL_FLAG_UPDATE = 8;

const int V4L2_CTRL_FLAG_INACTIVE = 16;

const int V4L2_CTRL_FLAG_SLIDER = 32;

const int V4L2_CTRL_FLAG_WRITE_ONLY = 64;

const int V4L2_CTRL_FLAG_VOLATILE = 128;

const int V4L2_CTRL_FLAG_HAS_PAYLOAD = 256;

const int V4L2_CTRL_FLAG_EXECUTE_ON_WRITE = 512;

const int V4L2_CTRL_FLAG_MODIFY_LAYOUT = 1024;

const int V4L2_CTRL_FLAG_DYNAMIC_ARRAY = 2048;

const int V4L2_CTRL_FLAG_NEXT_CTRL = 2147483648;

const int V4L2_CTRL_FLAG_NEXT_COMPOUND = 1073741824;

const int V4L2_CID_MAX_CTRLS = 1024;

const int V4L2_CID_PRIVATE_BASE = 134217728;

const int V4L2_TUNER_CAP_LOW = 1;

const int V4L2_TUNER_CAP_NORM = 2;

const int V4L2_TUNER_CAP_HWSEEK_BOUNDED = 4;

const int V4L2_TUNER_CAP_HWSEEK_WRAP = 8;

const int V4L2_TUNER_CAP_STEREO = 16;

const int V4L2_TUNER_CAP_LANG2 = 32;

const int V4L2_TUNER_CAP_SAP = 32;

const int V4L2_TUNER_CAP_LANG1 = 64;

const int V4L2_TUNER_CAP_RDS = 128;

const int V4L2_TUNER_CAP_RDS_BLOCK_IO = 256;

const int V4L2_TUNER_CAP_RDS_CONTROLS = 512;

const int V4L2_TUNER_CAP_FREQ_BANDS = 1024;

const int V4L2_TUNER_CAP_HWSEEK_PROG_LIM = 2048;

const int V4L2_TUNER_CAP_1HZ = 4096;

const int V4L2_TUNER_SUB_MONO = 1;

const int V4L2_TUNER_SUB_STEREO = 2;

const int V4L2_TUNER_SUB_LANG2 = 4;

const int V4L2_TUNER_SUB_SAP = 4;

const int V4L2_TUNER_SUB_LANG1 = 8;

const int V4L2_TUNER_SUB_RDS = 16;

const int V4L2_TUNER_MODE_MONO = 0;

const int V4L2_TUNER_MODE_STEREO = 1;

const int V4L2_TUNER_MODE_LANG2 = 2;

const int V4L2_TUNER_MODE_SAP = 2;

const int V4L2_TUNER_MODE_LANG1 = 3;

const int V4L2_TUNER_MODE_LANG1_LANG2 = 4;

const int V4L2_BAND_MODULATION_VSB = 2;

const int V4L2_BAND_MODULATION_FM = 4;

const int V4L2_BAND_MODULATION_AM = 8;

const int V4L2_RDS_BLOCK_MSK = 7;

const int V4L2_RDS_BLOCK_A = 0;

const int V4L2_RDS_BLOCK_B = 1;

const int V4L2_RDS_BLOCK_C = 2;

const int V4L2_RDS_BLOCK_D = 3;

const int V4L2_RDS_BLOCK_C_ALT = 4;

const int V4L2_RDS_BLOCK_INVALID = 7;

const int V4L2_RDS_BLOCK_CORRECTED = 64;

const int V4L2_RDS_BLOCK_ERROR = 128;

const int V4L2_AUDCAP_STEREO = 1;

const int V4L2_AUDCAP_AVL = 2;

const int V4L2_AUDMODE_AVL = 1;

const int V4L2_ENC_IDX_FRAME_I = 0;

const int V4L2_ENC_IDX_FRAME_P = 1;

const int V4L2_ENC_IDX_FRAME_B = 2;

const int V4L2_ENC_IDX_FRAME_MASK = 15;

const int V4L2_ENC_IDX_ENTRIES = 64;

const int V4L2_ENC_CMD_START = 0;

const int V4L2_ENC_CMD_STOP = 1;

const int V4L2_ENC_CMD_PAUSE = 2;

const int V4L2_ENC_CMD_RESUME = 3;

const int V4L2_ENC_CMD_STOP_AT_GOP_END = 1;

const int V4L2_DEC_CMD_START = 0;

const int V4L2_DEC_CMD_STOP = 1;

const int V4L2_DEC_CMD_PAUSE = 2;

const int V4L2_DEC_CMD_RESUME = 3;

const int V4L2_DEC_CMD_FLUSH = 4;

const int V4L2_DEC_CMD_START_MUTE_AUDIO = 1;

const int V4L2_DEC_CMD_PAUSE_TO_BLACK = 1;

const int V4L2_DEC_CMD_STOP_TO_BLACK = 1;

const int V4L2_DEC_CMD_STOP_IMMEDIATELY = 2;

const int V4L2_DEC_START_FMT_NONE = 0;

const int V4L2_DEC_START_FMT_GOP = 1;

const int V4L2_VBI_UNSYNC = 1;

const int V4L2_VBI_INTERLACED = 2;

const int V4L2_VBI_ITU_525_F1_START = 1;

const int V4L2_VBI_ITU_525_F2_START = 264;

const int V4L2_VBI_ITU_625_F1_START = 1;

const int V4L2_VBI_ITU_625_F2_START = 314;

const int V4L2_SLICED_TELETEXT_B = 1;

const int V4L2_SLICED_VPS = 1024;

const int V4L2_SLICED_CAPTION_525 = 4096;

const int V4L2_SLICED_WSS_625 = 16384;

const int V4L2_SLICED_VBI_525 = 4096;

const int V4L2_SLICED_VBI_625 = 17409;

const int V4L2_MPEG_VBI_IVTV_TELETEXT_B = 1;

const int V4L2_MPEG_VBI_IVTV_CAPTION_525 = 4;

const int V4L2_MPEG_VBI_IVTV_WSS_625 = 5;

const int V4L2_MPEG_VBI_IVTV_VPS = 7;

const String V4L2_MPEG_VBI_IVTV_MAGIC0 = 'itv0';

const String V4L2_MPEG_VBI_IVTV_MAGIC1 = 'ITV0';

const int V4L2_EVENT_ALL = 0;

const int V4L2_EVENT_VSYNC = 1;

const int V4L2_EVENT_EOS = 2;

const int V4L2_EVENT_CTRL = 3;

const int V4L2_EVENT_FRAME_SYNC = 4;

const int V4L2_EVENT_SOURCE_CHANGE = 5;

const int V4L2_EVENT_MOTION_DET = 6;

const int V4L2_EVENT_PRIVATE_START = 134217728;

const int V4L2_EVENT_CTRL_CH_VALUE = 1;

const int V4L2_EVENT_CTRL_CH_FLAGS = 2;

const int V4L2_EVENT_CTRL_CH_RANGE = 4;

const int V4L2_EVENT_CTRL_CH_DIMENSIONS = 8;

const int V4L2_EVENT_SRC_CH_RESOLUTION = 1;

const int V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ = 1;

const int V4L2_EVENT_SUB_FL_SEND_INITIAL = 1;

const int V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK = 2;

const int V4L2_CHIP_MATCH_BRIDGE = 0;

const int V4L2_CHIP_MATCH_SUBDEV = 4;

const int V4L2_CHIP_MATCH_HOST = 0;

const int V4L2_CHIP_MATCH_I2C_DRIVER = 1;

const int V4L2_CHIP_MATCH_I2C_ADDR = 2;

const int V4L2_CHIP_MATCH_AC97 = 3;

const int V4L2_CHIP_FL_READABLE = 1;

const int V4L2_CHIP_FL_WRITABLE = 2;

const int VIDIOC_QUERYCAP = 2154321408;

const int VIDIOC_ENUM_FMT = 3225441794;

const int VIDIOC_G_FMT = 3234878980;

const int VIDIOC_S_FMT = 3234878981;

const int VIDIOC_REQBUFS = 3222558216;

const int VIDIOC_QUERYBUF = 3227014665;

const int VIDIOC_G_FBUF = 2150651402;

const int VIDIOC_S_FBUF = 1076909579;

const int VIDIOC_OVERLAY = 1074025998;

const int VIDIOC_QBUF = 3227014671;

const int VIDIOC_EXPBUF = 3225441808;

const int VIDIOC_DQBUF = 3227014673;

const int VIDIOC_STREAMON = 1074026002;

const int VIDIOC_STREAMOFF = 1074026003;

const int VIDIOC_G_PARM = 3234616853;

const int VIDIOC_S_PARM = 3234616854;

const int VIDIOC_G_STD = 2148029975;

const int VIDIOC_S_STD = 1074288152;

const int VIDIOC_ENUMSTD = 3225966105;

const int VIDIOC_ENUMINPUT = 3226490394;

const int VIDIOC_G_CTRL = 3221771803;

const int VIDIOC_S_CTRL = 3221771804;

const int VIDIOC_G_TUNER = 3226752541;

const int VIDIOC_S_TUNER = 1079268894;

const int VIDIOC_G_AUDIO = 2150913569;

const int VIDIOC_S_AUDIO = 1077171746;

const int VIDIOC_QUERYCTRL = 3225703972;

const int VIDIOC_QUERYMENU = 3224131109;

const int VIDIOC_G_INPUT = 2147767846;

const int VIDIOC_S_INPUT = 3221509671;

const int VIDIOC_G_EDID = 3223868968;

const int VIDIOC_S_EDID = 3223868969;

const int VIDIOC_G_OUTPUT = 2147767854;

const int VIDIOC_S_OUTPUT = 3221509679;

const int VIDIOC_ENUMOUTPUT = 3225966128;

const int VIDIOC_G_AUDOUT = 2150913585;

const int VIDIOC_S_AUDOUT = 1077171762;

const int VIDIOC_G_MODULATOR = 3225703990;

const int VIDIOC_S_MODULATOR = 1078220343;

const int VIDIOC_G_FREQUENCY = 3224131128;

const int VIDIOC_S_FREQUENCY = 1076647481;

const int VIDIOC_CROPCAP = 3224131130;

const int VIDIOC_G_CROP = 3222558267;

const int VIDIOC_S_CROP = 1075074620;

const int VIDIOC_G_JPEGCOMP = 2156680765;

const int VIDIOC_S_JPEGCOMP = 1082938942;

const int VIDIOC_QUERYSTD = 2148030015;

const int VIDIOC_TRY_FMT = 3234879040;

const int VIDIOC_ENUMAUDIO = 3224655425;

const int VIDIOC_ENUMAUDOUT = 3224655426;

const int VIDIOC_G_PRIORITY = 2147767875;

const int VIDIOC_S_PRIORITY = 1074026052;

const int VIDIOC_G_SLICED_VBI_CAP = 3228849733;

const int VIDIOC_LOG_STATUS = 22086;

const int VIDIOC_G_EXT_CTRLS = 3223344711;

const int VIDIOC_S_EXT_CTRLS = 3223344712;

const int VIDIOC_TRY_EXT_CTRLS = 3223344713;

const int VIDIOC_ENUM_FRAMESIZES = 3224131146;

const int VIDIOC_ENUM_FRAMEINTERVALS = 3224655435;

const int VIDIOC_G_ENC_INDEX = 2283296332;

const int VIDIOC_ENCODER_CMD = 3223869005;

const int VIDIOC_TRY_ENCODER_CMD = 3223869006;

const int VIDIOC_DBG_S_REGISTER = 1077433935;

const int VIDIOC_DBG_G_REGISTER = 3224917584;

const int VIDIOC_S_HW_FREQ_SEEK = 1076909650;

const int VIDIOC_S_DV_TIMINGS = 3229898327;

const int VIDIOC_G_DV_TIMINGS = 3229898328;

const int VIDIOC_DQEVENT = 2156418649;

const int VIDIOC_SUBSCRIBE_EVENT = 1075861082;

const int VIDIOC_UNSUBSCRIBE_EVENT = 1075861083;

const int VIDIOC_CREATE_BUFS = 3238024796;

const int VIDIOC_PREPARE_BUF = 3227014749;

const int VIDIOC_G_SELECTION = 3225441886;

const int VIDIOC_S_SELECTION = 3225441887;

const int VIDIOC_DECODER_CMD = 3225966176;

const int VIDIOC_TRY_DECODER_CMD = 3225966177;

const int VIDIOC_ENUM_DV_TIMINGS = 3230946914;

const int VIDIOC_QUERY_DV_TIMINGS = 2156156515;

const int VIDIOC_DV_TIMINGS_CAP = 3230684772;

const int VIDIOC_ENUM_FREQ_BANDS = 3225441893;

const int VIDIOC_DBG_G_CHIP_INFO = 3234354790;

const int VIDIOC_QUERY_EXT_CTRL = 3236451943;

const int BASE_VIDIOC_PRIVATE = 192;

const int V4L2_PIX_FMT_HM12 = 842091848;

const int V4L2_PIX_FMT_SUNXI_TILED_NV12 = 842093651;

const int V4L2_CAP_ASYNCIO = 33554432;
