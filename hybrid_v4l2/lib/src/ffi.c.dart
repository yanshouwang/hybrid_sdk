// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `c`.
///
class LibC {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibC(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibC.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int fcntl(
    int __fd,
    int __cmd,
  ) {
    return _fcntl(
      __fd,
      __cmd,
    );
  }

  late final _fcntlPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('fcntl');
  late final _fcntl = _fcntlPtr.asFunction<int Function(int, int)>();

  int open(
    ffi.Pointer<ffi.Char> __file,
    int __oflag,
    int va,
  ) {
    return _open(
      __file,
      __oflag,
      va,
    );
  }

  late final _openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.VarArgs<(ffi.Int,)>)>>('open');
  late final _open =
      _openPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int openat(
    int __fd,
    ffi.Pointer<ffi.Char> __file,
    int __oflag,
    int va,
  ) {
    return _openat(
      __fd,
      __file,
      __oflag,
      va,
    );
  }

  late final _openatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.VarArgs<(ffi.Int,)>)>>('openat');
  late final _openat = _openatPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  int creat(
    ffi.Pointer<ffi.Char> __file,
    int __mode,
  ) {
    return _creat(
      __file,
      __mode,
    );
  }

  late final _creatPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, mode_t)>>(
      'creat');
  late final _creat =
      _creatPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int lockf(
    int __fd,
    int __cmd,
    int __len,
  ) {
    return _lockf(
      __fd,
      __cmd,
      __len,
    );
  }

  late final _lockfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, off_t)>>(
          'lockf');
  late final _lockf = _lockfPtr.asFunction<int Function(int, int, int)>();

  int posix_fadvise(
    int __fd,
    int __offset,
    int __len,
    int __advise,
  ) {
    return _posix_fadvise(
      __fd,
      __offset,
      __len,
      __advise,
    );
  }

  late final _posix_fadvisePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, off_t, off_t, ffi.Int)>>(
      'posix_fadvise');
  late final _posix_fadvise =
      _posix_fadvisePtr.asFunction<int Function(int, int, int, int)>();

  int posix_fallocate(
    int __fd,
    int __offset,
    int __len,
  ) {
    return _posix_fallocate(
      __fd,
      __offset,
      __len,
    );
  }

  late final _posix_fallocatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, off_t, off_t)>>(
          'posix_fallocate');
  late final _posix_fallocate =
      _posix_fallocatePtr.asFunction<int Function(int, int, int)>();

  /// Test for access to NAME using the real UID and real GID.
  int access(
    ffi.Pointer<ffi.Char> __name,
    int __type,
  ) {
    return _access(
      __name,
      __type,
    );
  }

  late final _accessPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'access');
  late final _access =
      _accessPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Test for access to FILE relative to the directory FD is open on.
  /// If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
  /// otherwise use real IDs like `access'.
  int faccessat(
    int __fd,
    ffi.Pointer<ffi.Char> __file,
    int __type,
    int __flag,
  ) {
    return _faccessat(
      __fd,
      __file,
      __type,
      __flag,
    );
  }

  late final _faccessatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int, ffi.Int)>>('faccessat');
  late final _faccessat = _faccessatPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int)>();

  int lseek(
    int __fd,
    int __offset,
    int __whence,
  ) {
    return _lseek(
      __fd,
      __offset,
      __whence,
    );
  }

  late final _lseekPtr =
      _lookup<ffi.NativeFunction<__off_t Function(ffi.Int, __off_t, ffi.Int)>>(
          'lseek');
  late final _lseek = _lseekPtr.asFunction<int Function(int, int, int)>();

  /// Close the file descriptor FD.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int close(
    int __fd,
  ) {
    return _close(
      __fd,
    );
  }

  late final _closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('close');
  late final _close = _closePtr.asFunction<int Function(int)>();

  /// Close all open file descriptors greater than or equal to LOWFD.
  /// Negative LOWFD is clamped to 0.
  void closefrom(
    int __lowfd,
  ) {
    return _closefrom(
      __lowfd,
    );
  }

  late final _closefromPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('closefrom');
  late final _closefrom = _closefromPtr.asFunction<void Function(int)>();

  /// Read NBYTES into BUF from FD.  Return the
  /// number read, -1 for errors or 0 for EOF.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int read(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _read(
      __fd,
      __buf,
      __nbytes,
    );
  }

  late final _readPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('read');
  late final _read =
      _readPtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Write N bytes of BUF to FD.  Return the number written, or -1.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int write(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __n,
  ) {
    return _write(
      __fd,
      __buf,
      __n,
    );
  }

  late final _writePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size)>>('write');
  late final _write =
      _writePtr.asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Read NBYTES into BUF from FD at the given position OFFSET without
  /// changing the file pointer.  Return the number read, -1 for errors
  /// or 0 for EOF.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int pread(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
    int __offset,
  ) {
    return _pread(
      __fd,
      __buf,
      __nbytes,
      __offset,
    );
  }

  late final _preadPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, __off_t)>>('pread');
  late final _pread = _preadPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// Write N bytes of BUF to FD at the given position OFFSET without
  /// changing the file pointer.  Return the number written, or -1.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int pwrite(
    int __fd,
    ffi.Pointer<ffi.Void> __buf,
    int __n,
    int __offset,
  ) {
    return _pwrite(
      __fd,
      __buf,
      __n,
      __offset,
    );
  }

  late final _pwritePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(
              ffi.Int, ffi.Pointer<ffi.Void>, ffi.Size, __off_t)>>('pwrite');
  late final _pwrite = _pwritePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int, int)>();

  /// Create a one-way communication channel (pipe).
  /// If successful, two file descriptors are stored in PIPEDES;
  /// bytes written on PIPEDES[1] can be read from PIPEDES[0].
  /// Returns 0 if successful, -1 if not.
  int pipe(
    ffi.Pointer<ffi.Int> __pipedes,
  ) {
    return _pipe(
      __pipedes,
    );
  }

  late final _pipePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Int>)>>(
          'pipe');
  late final _pipe = _pipePtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  /// Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
  /// If SECONDS is zero, any currently scheduled alarm will be cancelled.
  /// The function returns the number of seconds remaining until the last
  /// alarm scheduled would have signaled, or zero if there wasn't one.
  /// There is no return value to indicate an error, but you can set `errno'
  /// to 0 and check its value after calling `alarm', and this might tell you.
  /// The signal may come late due to processor scheduling.
  int alarm(
    int __seconds,
  ) {
    return _alarm(
      __seconds,
    );
  }

  late final _alarmPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'alarm');
  late final _alarm = _alarmPtr.asFunction<int Function(int)>();

  /// Make the process sleep for SECONDS seconds, or until a signal arrives
  /// and is not ignored.  The function returns the number of seconds less
  /// than SECONDS which it actually slept (thus zero if it slept the full time).
  /// If a signal handler does a `longjmp' or modifies the handling of the
  /// SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
  /// signal afterwards is undefined.  There is no return value to indicate
  /// error, but if `sleep' returns SECONDS, it probably didn't work.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int sleep(
    int __seconds,
  ) {
    return _sleep(
      __seconds,
    );
  }

  late final _sleepPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'sleep');
  late final _sleep = _sleepPtr.asFunction<int Function(int)>();

  /// Set an alarm to go off (generating a SIGALRM signal) in VALUE
  /// microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
  /// timer is reset to go off every INTERVAL microseconds thereafter.
  /// Returns the number of microseconds remaining before the alarm.
  int ualarm(
    int __value,
    int __interval,
  ) {
    return _ualarm(
      __value,
      __interval,
    );
  }

  late final _ualarmPtr = _lookup<
      ffi.NativeFunction<
          __useconds_t Function(__useconds_t, __useconds_t)>>('ualarm');
  late final _ualarm = _ualarmPtr.asFunction<int Function(int, int)>();

  /// Sleep USECONDS microseconds, or until a signal arrives that is not blocked
  /// or ignored.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int usleep(
    int __useconds,
  ) {
    return _usleep(
      __useconds,
    );
  }

  late final _usleepPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__useconds_t)>>('usleep');
  late final _usleep = _usleepPtr.asFunction<int Function(int)>();

  /// Suspend the process until a signal arrives.
  /// This always returns -1 and sets `errno' to EINTR.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int pause() {
    return _pause();
  }

  late final _pausePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('pause');
  late final _pause = _pausePtr.asFunction<int Function()>();

  /// Change the owner and group of FILE.
  int chown(
    ffi.Pointer<ffi.Char> __file,
    int __owner,
    int __group,
  ) {
    return _chown(
      __file,
      __owner,
      __group,
    );
  }

  late final _chownPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, __uid_t, __gid_t)>>('chown');
  late final _chown =
      _chownPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// Change the owner and group of the file that FD is open on.
  int fchown(
    int __fd,
    int __owner,
    int __group,
  ) {
    return _fchown(
      __fd,
      __owner,
      __group,
    );
  }

  late final _fchownPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, __uid_t, __gid_t)>>(
          'fchown');
  late final _fchown = _fchownPtr.asFunction<int Function(int, int, int)>();

  /// Change owner and group of FILE, if it is a symbolic
  /// link the ownership of the symbolic link is changed.
  int lchown(
    ffi.Pointer<ffi.Char> __file,
    int __owner,
    int __group,
  ) {
    return _lchown(
      __file,
      __owner,
      __group,
    );
  }

  late final _lchownPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, __uid_t, __gid_t)>>('lchown');
  late final _lchown =
      _lchownPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// Change the owner and group of FILE relative to the directory FD is open
  /// on.
  int fchownat(
    int __fd,
    ffi.Pointer<ffi.Char> __file,
    int __owner,
    int __group,
    int __flag,
  ) {
    return _fchownat(
      __fd,
      __file,
      __owner,
      __group,
      __flag,
    );
  }

  late final _fchownatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, __uid_t, __gid_t,
              ffi.Int)>>('fchownat');
  late final _fchownat = _fchownatPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int, int, int)>();

  /// Change the process's working directory to PATH.
  int chdir(
    ffi.Pointer<ffi.Char> __path,
  ) {
    return _chdir(
      __path,
    );
  }

  late final _chdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'chdir');
  late final _chdir =
      _chdirPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Change the process's working directory to the one FD is open on.
  int fchdir(
    int __fd,
  ) {
    return _fchdir(
      __fd,
    );
  }

  late final _fchdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fchdir');
  late final _fchdir = _fchdirPtr.asFunction<int Function(int)>();

  /// Get the pathname of the current working directory,
  /// and put it in SIZE bytes of BUF.  Returns NULL if the
  /// directory couldn't be determined or SIZE was too small.
  /// If successful, returns BUF.  In GNU, if BUF is NULL,
  /// an array is allocated with `malloc'; the array is SIZE
  /// bytes long, unless SIZE == 0, in which case it is as
  /// big as necessary.
  ffi.Pointer<ffi.Char> getcwd(
    ffi.Pointer<ffi.Char> __buf,
    int __size,
  ) {
    return _getcwd(
      __buf,
      __size,
    );
  }

  late final _getcwdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('getcwd');
  late final _getcwd = _getcwdPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Put the absolute pathname of the current working directory in BUF.
  /// If successful, return BUF.  If not, put an error message in
  /// BUF and return NULL.  BUF should be at least PATH_MAX bytes long.
  ffi.Pointer<ffi.Char> getwd(
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _getwd(
      __buf,
    );
  }

  late final _getwdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getwd');
  late final _getwd = _getwdPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Duplicate FD, returning a new file descriptor on the same file.
  int dup(
    int __fd,
  ) {
    return _dup(
      __fd,
    );
  }

  late final _dupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('dup');
  late final _dup = _dupPtr.asFunction<int Function(int)>();

  /// Duplicate FD to FD2, closing FD2 and making it open on the same file.
  int dup2(
    int __fd,
    int __fd2,
  ) {
    return _dup2(
      __fd,
      __fd2,
    );
  }

  late final _dup2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('dup2');
  late final _dup2 = _dup2Ptr.asFunction<int Function(int, int)>();

  /// NULL-terminated array of "NAME=VALUE" environment variables.
  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> ___environ =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('__environ');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get __environ => ___environ.value;

  set __environ(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      ___environ.value = value;

  /// Replace the current process, executing PATH with arguments ARGV and
  /// environment ENVP.  ARGV and ENVP are terminated by NULL pointers.
  int execve(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __envp,
  ) {
    return _execve(
      __path,
      __argv,
      __envp,
    );
  }

  late final _execvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execve');
  late final _execve = _execvePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Execute the file FD refers to, overlaying the running program image.
  /// ARGV and ENVP are passed to the new program, as for `execve'.
  int fexecve(
    int __fd,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __envp,
  ) {
    return _fexecve(
      __fd,
      __argv,
      __envp,
    );
  }

  late final _fexecvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('fexecve');
  late final _fexecve = _fexecvePtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Execute PATH with arguments ARGV and environment from `environ'.
  int execv(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
  ) {
    return _execv(
      __path,
      __argv,
    );
  }

  late final _execvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execv');
  late final _execv = _execvPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Execute PATH with all arguments after PATH until a NULL pointer,
  /// and the argument after that for environment.
  int execle(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __arg,
  ) {
    return _execle(
      __path,
      __arg,
    );
  }

  late final _execlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execle');
  late final _execle = _execlePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Execute PATH with all arguments after PATH until
  /// a NULL pointer and environment from `environ'.
  int execl(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __arg,
  ) {
    return _execl(
      __path,
      __arg,
    );
  }

  late final _execlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execl');
  late final _execl = _execlPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Execute FILE, searching in the `PATH' environment variable if it contains
  /// no slashes, with arguments ARGV and environment from `environ'.
  int execvp(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __argv,
  ) {
    return _execvp(
      __file,
      __argv,
    );
  }

  late final _execvpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('execvp');
  late final _execvp = _execvpPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Execute FILE, searching in the `PATH' environment variable if
  /// it contains no slashes, with all arguments after FILE until a
  /// NULL pointer and environment from `environ'.
  int execlp(
    ffi.Pointer<ffi.Char> __file,
    ffi.Pointer<ffi.Char> __arg,
  ) {
    return _execlp(
      __file,
      __arg,
    );
  }

  late final _execlpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('execlp');
  late final _execlp = _execlpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Add INC to priority of the current process.
  int nice(
    int __inc,
  ) {
    return _nice(
      __inc,
    );
  }

  late final _nicePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('nice');
  late final _nice = _nicePtr.asFunction<int Function(int)>();

  /// Terminate program execution with the low-order 8 bits of STATUS.
  void _exit(
    int __status,
  ) {
    return __exit(
      __status,
    );
  }

  late final __exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_exit');
  late final __exit = __exitPtr.asFunction<void Function(int)>();

  /// Get file-specific configuration information about PATH.
  int pathconf(
    ffi.Pointer<ffi.Char> __path,
    int __name,
  ) {
    return _pathconf(
      __path,
      __name,
    );
  }

  late final _pathconfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>, ffi.Int)>>('pathconf');
  late final _pathconf =
      _pathconfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Get file-specific configuration about descriptor FD.
  int fpathconf(
    int __fd,
    int __name,
  ) {
    return _fpathconf(
      __fd,
      __name,
    );
  }

  late final _fpathconfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Int, ffi.Int)>>(
          'fpathconf');
  late final _fpathconf = _fpathconfPtr.asFunction<int Function(int, int)>();

  /// Get the value of the system variable NAME.
  int sysconf(
    int __name,
  ) {
    return _sysconf(
      __name,
    );
  }

  late final _sysconfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Int)>>('sysconf');
  late final _sysconf = _sysconfPtr.asFunction<int Function(int)>();

  /// Get the value of the string-valued system variable NAME.
  int confstr(
    int __name,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _confstr(
      __name,
      __buf,
      __len,
    );
  }

  late final _confstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('confstr');
  late final _confstr =
      _confstrPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Get the process ID of the calling process.
  int getpid() {
    return _getpid();
  }

  late final _getpidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function()>>('getpid');
  late final _getpid = _getpidPtr.asFunction<int Function()>();

  /// Get the process ID of the calling process's parent.
  int getppid() {
    return _getppid();
  }

  late final _getppidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function()>>('getppid');
  late final _getppid = _getppidPtr.asFunction<int Function()>();

  /// Get the process group ID of the calling process.
  int getpgrp() {
    return _getpgrp();
  }

  late final _getpgrpPtr =
      _lookup<ffi.NativeFunction<__pid_t Function()>>('getpgrp');
  late final _getpgrp = _getpgrpPtr.asFunction<int Function()>();

  /// Get the process group ID of process PID.
  int __getpgid(
    int __pid,
  ) {
    return ___getpgid(
      __pid,
    );
  }

  late final ___getpgidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function(__pid_t)>>('__getpgid');
  late final ___getpgid = ___getpgidPtr.asFunction<int Function(int)>();

  int getpgid(
    int __pid,
  ) {
    return _getpgid(
      __pid,
    );
  }

  late final _getpgidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function(__pid_t)>>('getpgid');
  late final _getpgid = _getpgidPtr.asFunction<int Function(int)>();

  /// Set the process group ID of the process matching PID to PGID.
  /// If PID is zero, the current process's process group ID is set.
  /// If PGID is zero, the process ID of the process is used.
  int setpgid(
    int __pid,
    int __pgid,
  ) {
    return _setpgid(
      __pid,
      __pgid,
    );
  }

  late final _setpgidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__pid_t, __pid_t)>>(
          'setpgid');
  late final _setpgid = _setpgidPtr.asFunction<int Function(int, int)>();

  /// Set the process group ID of the calling process to its own PID.
  /// This is exactly the same as `setpgid (0, 0)'.
  int setpgrp() {
    return _setpgrp();
  }

  late final _setpgrpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('setpgrp');
  late final _setpgrp = _setpgrpPtr.asFunction<int Function()>();

  /// Create a new session with the calling process as its leader.
  /// The process group IDs of the session and the calling process
  /// are set to the process ID of the calling process, which is returned.
  int setsid() {
    return _setsid();
  }

  late final _setsidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function()>>('setsid');
  late final _setsid = _setsidPtr.asFunction<int Function()>();

  /// Return the session ID of the given process.
  int getsid(
    int __pid,
  ) {
    return _getsid(
      __pid,
    );
  }

  late final _getsidPtr =
      _lookup<ffi.NativeFunction<__pid_t Function(__pid_t)>>('getsid');
  late final _getsid = _getsidPtr.asFunction<int Function(int)>();

  /// Get the real user ID of the calling process.
  int getuid() {
    return _getuid();
  }

  late final _getuidPtr =
      _lookup<ffi.NativeFunction<__uid_t Function()>>('getuid');
  late final _getuid = _getuidPtr.asFunction<int Function()>();

  /// Get the effective user ID of the calling process.
  int geteuid() {
    return _geteuid();
  }

  late final _geteuidPtr =
      _lookup<ffi.NativeFunction<__uid_t Function()>>('geteuid');
  late final _geteuid = _geteuidPtr.asFunction<int Function()>();

  /// Get the real group ID of the calling process.
  int getgid() {
    return _getgid();
  }

  late final _getgidPtr =
      _lookup<ffi.NativeFunction<__gid_t Function()>>('getgid');
  late final _getgid = _getgidPtr.asFunction<int Function()>();

  /// Get the effective group ID of the calling process.
  int getegid() {
    return _getegid();
  }

  late final _getegidPtr =
      _lookup<ffi.NativeFunction<__gid_t Function()>>('getegid');
  late final _getegid = _getegidPtr.asFunction<int Function()>();

  /// If SIZE is zero, return the number of supplementary groups
  /// the calling process is in.  Otherwise, fill in the group IDs
  /// of its supplementary groups in LIST and return the number written.
  int getgroups(
    int __size,
    ffi.Pointer<__gid_t> __list,
  ) {
    return _getgroups(
      __size,
      __list,
    );
  }

  late final _getgroupsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<__gid_t>)>>(
      'getgroups');
  late final _getgroups =
      _getgroupsPtr.asFunction<int Function(int, ffi.Pointer<__gid_t>)>();

  /// Set the user ID of the calling process to UID.
  /// If the calling process is the super-user, set the real
  /// and effective user IDs, and the saved set-user-ID to UID;
  /// if not, the effective user ID is set to UID.
  int setuid(
    int __uid,
  ) {
    return _setuid(
      __uid,
    );
  }

  late final _setuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__uid_t)>>('setuid');
  late final _setuid = _setuidPtr.asFunction<int Function(int)>();

  /// Set the real user ID of the calling process to RUID,
  /// and the effective user ID of the calling process to EUID.
  int setreuid(
    int __ruid,
    int __euid,
  ) {
    return _setreuid(
      __ruid,
      __euid,
    );
  }

  late final _setreuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__uid_t, __uid_t)>>(
          'setreuid');
  late final _setreuid = _setreuidPtr.asFunction<int Function(int, int)>();

  /// Set the effective user ID of the calling process to UID.
  int seteuid(
    int __uid,
  ) {
    return _seteuid(
      __uid,
    );
  }

  late final _seteuidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__uid_t)>>('seteuid');
  late final _seteuid = _seteuidPtr.asFunction<int Function(int)>();

  /// Set the group ID of the calling process to GID.
  /// If the calling process is the super-user, set the real
  /// and effective group IDs, and the saved set-group-ID to GID;
  /// if not, the effective group ID is set to GID.
  int setgid(
    int __gid,
  ) {
    return _setgid(
      __gid,
    );
  }

  late final _setgidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__gid_t)>>('setgid');
  late final _setgid = _setgidPtr.asFunction<int Function(int)>();

  /// Set the real group ID of the calling process to RGID,
  /// and the effective group ID of the calling process to EGID.
  int setregid(
    int __rgid,
    int __egid,
  ) {
    return _setregid(
      __rgid,
      __egid,
    );
  }

  late final _setregidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__gid_t, __gid_t)>>(
          'setregid');
  late final _setregid = _setregidPtr.asFunction<int Function(int, int)>();

  /// Set the effective group ID of the calling process to GID.
  int setegid(
    int __gid,
  ) {
    return _setegid(
      __gid,
    );
  }

  late final _setegidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(__gid_t)>>('setegid');
  late final _setegid = _setegidPtr.asFunction<int Function(int)>();

  /// Clone the calling process, creating an exact copy.
  /// Return -1 for errors, 0 to the new process,
  /// and the process ID of the new process to the old process.
  int fork() {
    return _fork();
  }

  late final _forkPtr = _lookup<ffi.NativeFunction<__pid_t Function()>>('fork');
  late final _fork = _forkPtr.asFunction<int Function()>();

  /// Clone the calling process, but without copying the whole address space.
  /// The calling process is suspended until the new process exits or is
  /// replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
  /// and the process ID of the new process to the old process.
  int vfork() {
    return _vfork();
  }

  late final _vforkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('vfork');
  late final _vfork = _vforkPtr.asFunction<int Function()>();

  /// Return the pathname of the terminal FD is open on, or NULL on errors.
  /// The returned storage is good only until the next call to this function.
  ffi.Pointer<ffi.Char> ttyname(
    int __fd,
  ) {
    return _ttyname(
      __fd,
    );
  }

  late final _ttynamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ttyname');
  late final _ttyname =
      _ttynamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Store at most BUFLEN characters of the pathname of the terminal FD is
  /// open on in BUF.  Return 0 on success, otherwise an error number.
  int ttyname_r(
    int __fd,
    ffi.Pointer<ffi.Char> __buf,
    int __buflen,
  ) {
    return _ttyname_r(
      __fd,
      __buf,
      __buflen,
    );
  }

  late final _ttyname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ttyname_r');
  late final _ttyname_r =
      _ttyname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Return 1 if FD is a valid descriptor associated
  /// with a terminal, zero if not.
  int isatty(
    int __fd,
  ) {
    return _isatty(
      __fd,
    );
  }

  late final _isattyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('isatty');
  late final _isatty = _isattyPtr.asFunction<int Function(int)>();

  /// Return the index into the active-logins file (utmp) for
  /// the controlling terminal.
  int ttyslot() {
    return _ttyslot();
  }

  late final _ttyslotPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('ttyslot');
  late final _ttyslot = _ttyslotPtr.asFunction<int Function()>();

  /// Make a link to FROM named TO.
  int link(
    ffi.Pointer<ffi.Char> __from,
    ffi.Pointer<ffi.Char> __to,
  ) {
    return _link(
      __from,
      __to,
    );
  }

  late final _linkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('link');
  late final _link = _linkPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Like link but relative paths in TO and FROM are interpreted relative
  /// to FROMFD and TOFD respectively.
  int linkat(
    int __fromfd,
    ffi.Pointer<ffi.Char> __from,
    int __tofd,
    ffi.Pointer<ffi.Char> __to,
    int __flags,
  ) {
    return _linkat(
      __fromfd,
      __from,
      __tofd,
      __to,
      __flags,
    );
  }

  late final _linkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('linkat');
  late final _linkat = _linkatPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  /// Make a symbolic link to FROM named TO.
  int symlink(
    ffi.Pointer<ffi.Char> __from,
    ffi.Pointer<ffi.Char> __to,
  ) {
    return _symlink(
      __from,
      __to,
    );
  }

  late final _symlinkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('symlink');
  late final _symlink = _symlinkPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Read the contents of the symbolic link PATH into no more than
  /// LEN bytes of BUF.  The contents are not null-terminated.
  /// Returns the number of characters read, or -1 for errors.
  int readlink(
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _readlink(
      __path,
      __buf,
      __len,
    );
  }

  late final _readlinkPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('readlink');
  late final _readlink = _readlinkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Like symlink but a relative path in TO is interpreted relative to TOFD.
  int symlinkat(
    ffi.Pointer<ffi.Char> __from,
    int __tofd,
    ffi.Pointer<ffi.Char> __to,
  ) {
    return _symlinkat(
      __from,
      __tofd,
      __to,
    );
  }

  late final _symlinkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('symlinkat');
  late final _symlinkat = _symlinkatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Like readlink but a relative PATH is interpreted relative to FD.
  int readlinkat(
    int __fd,
    ffi.Pointer<ffi.Char> __path,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _readlinkat(
      __fd,
      __path,
      __buf,
      __len,
    );
  }

  late final _readlinkatPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('readlinkat');
  late final _readlinkat = _readlinkatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Remove the link NAME.
  int unlink(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _unlink(
      __name,
    );
  }

  late final _unlinkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unlink');
  late final _unlink =
      _unlinkPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Remove the link NAME relative to FD.
  int unlinkat(
    int __fd,
    ffi.Pointer<ffi.Char> __name,
    int __flag,
  ) {
    return _unlinkat(
      __fd,
      __name,
      __flag,
    );
  }

  late final _unlinkatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int)>>('unlinkat');
  late final _unlinkat =
      _unlinkatPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Remove the directory PATH.
  int rmdir(
    ffi.Pointer<ffi.Char> __path,
  ) {
    return _rmdir(
      __path,
    );
  }

  late final _rmdirPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rmdir');
  late final _rmdir =
      _rmdirPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Return the foreground process group ID of FD.
  int tcgetpgrp(
    int __fd,
  ) {
    return _tcgetpgrp(
      __fd,
    );
  }

  late final _tcgetpgrpPtr =
      _lookup<ffi.NativeFunction<__pid_t Function(ffi.Int)>>('tcgetpgrp');
  late final _tcgetpgrp = _tcgetpgrpPtr.asFunction<int Function(int)>();

  /// Set the foreground process group ID of FD set PGRP_ID.
  int tcsetpgrp(
    int __fd,
    int __pgrp_id,
  ) {
    return _tcsetpgrp(
      __fd,
      __pgrp_id,
    );
  }

  late final _tcsetpgrpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, __pid_t)>>(
          'tcsetpgrp');
  late final _tcsetpgrp = _tcsetpgrpPtr.asFunction<int Function(int, int)>();

  /// Return the login name of the user.
  ///
  /// This function is a possible cancellation point and therefore not
  /// marked with __THROW.
  ffi.Pointer<ffi.Char> getlogin() {
    return _getlogin();
  }

  late final _getloginPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>('getlogin');
  late final _getlogin =
      _getloginPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return at most NAME_LEN characters of the login name of the user in NAME.
  /// If it cannot be determined or some other error occurred, return the error
  /// code.  Otherwise return 0.
  ///
  /// This function is a possible cancellation point and therefore not
  /// marked with __THROW.
  int getlogin_r(
    ffi.Pointer<ffi.Char> __name,
    int __name_len,
  ) {
    return _getlogin_r(
      __name,
      __name_len,
    );
  }

  late final _getlogin_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('getlogin_r');
  late final _getlogin_r =
      _getlogin_rPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Set the login name returned by `getlogin'.
  int setlogin(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _setlogin(
      __name,
    );
  }

  late final _setloginPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'setlogin');
  late final _setlogin =
      _setloginPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Put the name of the current host in no more than LEN bytes of NAME.
  /// The result is null-terminated if LEN is large enough for the full
  /// name and the terminator.
  int gethostname(
    ffi.Pointer<ffi.Char> __name,
    int __len,
  ) {
    return _gethostname(
      __name,
      __len,
    );
  }

  late final _gethostnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('gethostname');
  late final _gethostname =
      _gethostnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Set the name of the current host to NAME, which is LEN bytes long.
  /// This call is restricted to the super-user.
  int sethostname(
    ffi.Pointer<ffi.Char> __name,
    int __len,
  ) {
    return _sethostname(
      __name,
      __len,
    );
  }

  late final _sethostnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('sethostname');
  late final _sethostname =
      _sethostnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Set the current machine's Internet number to ID.
  /// This call is restricted to the super-user.
  int sethostid(
    int __id,
  ) {
    return _sethostid(
      __id,
    );
  }

  late final _sethostidPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('sethostid');
  late final _sethostid = _sethostidPtr.asFunction<int Function(int)>();

  /// Get and set the NIS (aka YP) domain name, if any.
  /// Called just like `gethostname' and `sethostname'.
  /// The NIS domain name is usually the empty string when not using NIS.
  int getdomainname(
    ffi.Pointer<ffi.Char> __name,
    int __len,
  ) {
    return _getdomainname(
      __name,
      __len,
    );
  }

  late final _getdomainnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('getdomainname');
  late final _getdomainname =
      _getdomainnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int setdomainname(
    ffi.Pointer<ffi.Char> __name,
    int __len,
  ) {
    return _setdomainname(
      __name,
      __len,
    );
  }

  late final _setdomainnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('setdomainname');
  late final _setdomainname =
      _setdomainnamePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Revoke access permissions to all processes currently communicating
  /// with the control terminal, and then send a SIGHUP signal to the process
  /// group of the control terminal.
  int vhangup() {
    return _vhangup();
  }

  late final _vhangupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('vhangup');
  late final _vhangup = _vhangupPtr.asFunction<int Function()>();

  /// Revoke the access of all descriptors currently open on FILE.
  int revoke(
    ffi.Pointer<ffi.Char> __file,
  ) {
    return _revoke(
      __file,
    );
  }

  late final _revokePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'revoke');
  late final _revoke =
      _revokePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Enable statistical profiling, writing samples of the PC into at most
  /// SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
  /// is enabled, the system examines the user PC and increments
  /// SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
  /// disable profiling.  Returns zero on success, -1 on error.
  int profil(
    ffi.Pointer<ffi.UnsignedShort> __sample_buffer,
    int __size,
    int __offset,
    int __scale,
  ) {
    return _profil(
      __sample_buffer,
      __size,
      __offset,
      __scale,
    );
  }

  late final _profilPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Size, ffi.Size,
              ffi.UnsignedInt)>>('profil');
  late final _profil = _profilPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, int, int, int)>();

  /// Turn accounting on if NAME is an existing file.  The system will then write
  /// a record for each process as it terminates, to this file.  If NAME is NULL,
  /// turn accounting off.  This call is restricted to the super-user.
  int acct(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _acct(
      __name,
    );
  }

  late final _acctPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'acct');
  late final _acct = _acctPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Successive calls return the shells listed in `/etc/shells'.
  ffi.Pointer<ffi.Char> getusershell() {
    return _getusershell();
  }

  late final _getusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getusershell');
  late final _getusershell =
      _getusershellPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void endusershell() {
    return _endusershell();
  }

  late final _endusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('endusershell');
  late final _endusershell = _endusershellPtr.asFunction<void Function()>();

  void setusershell() {
    return _setusershell();
  }

  late final _setusershellPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('setusershell');
  late final _setusershell = _setusershellPtr.asFunction<void Function()>();

  /// Put the program in the background, and dissociate from the controlling
  /// terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
  /// redirects stdin, stdout, and stderr to /dev/null.
  int daemon(
    int __nochdir,
    int __noclose,
  ) {
    return _daemon(
      __nochdir,
      __noclose,
    );
  }

  late final _daemonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('daemon');
  late final _daemon = _daemonPtr.asFunction<int Function(int, int)>();

  /// Make PATH be the root directory (the starting point for absolute paths).
  /// This call is restricted to the super-user.
  int chroot(
    ffi.Pointer<ffi.Char> __path,
  ) {
    return _chroot(
      __path,
    );
  }

  late final _chrootPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'chroot');
  late final _chroot =
      _chrootPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Prompt with PROMPT and read a string from the terminal without echoing.
  /// Uses /dev/tty if possible; otherwise stderr and stdin.
  ffi.Pointer<ffi.Char> getpass(
    ffi.Pointer<ffi.Char> __prompt,
  ) {
    return _getpass(
      __prompt,
    );
  }

  late final _getpassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getpass');
  late final _getpass = _getpassPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Make all changes done to FD actually appear on disk.
  ///
  /// This function is a cancellation point and therefore not marked with
  /// __THROW.
  int fsync(
    int __fd,
  ) {
    return _fsync(
      __fd,
    );
  }

  late final _fsyncPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fsync');
  late final _fsync = _fsyncPtr.asFunction<int Function(int)>();

  /// Return identifier for the current host.
  int gethostid() {
    return _gethostid();
  }

  late final _gethostidPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('gethostid');
  late final _gethostid = _gethostidPtr.asFunction<int Function()>();

  /// Make all changes done to all files actually appear on disk.
  void sync1() {
    return _sync1();
  }

  late final _sync1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sync');
  late final _sync1 = _sync1Ptr.asFunction<void Function()>();

  /// Return the number of bytes in a page.  This is the system's page size,
  /// which is not necessarily the same as the hardware page size.
  int getpagesize() {
    return _getpagesize();
  }

  late final _getpagesizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getpagesize');
  late final _getpagesize = _getpagesizePtr.asFunction<int Function()>();

  /// Return the maximum number of file descriptors
  /// the current process could possibly have.
  int getdtablesize() {
    return _getdtablesize();
  }

  late final _getdtablesizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getdtablesize');
  late final _getdtablesize = _getdtablesizePtr.asFunction<int Function()>();

  int truncate(
    ffi.Pointer<ffi.Char> __file,
    int __length,
  ) {
    return _truncate(
      __file,
      __length,
    );
  }

  late final _truncatePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, __off_t)>>(
      'truncate');
  late final _truncate =
      _truncatePtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int ftruncate(
    int __fd,
    int __length,
  ) {
    return _ftruncate(
      __fd,
      __length,
    );
  }

  late final _ftruncatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, __off_t)>>(
          'ftruncate');
  late final _ftruncate = _ftruncatePtr.asFunction<int Function(int, int)>();

  /// Set the end of accessible data space (aka "the break") to ADDR.
  /// Returns zero on success and -1 for errors (with errno set).
  int brk(
    ffi.Pointer<ffi.Void> __addr,
  ) {
    return _brk(
      __addr,
    );
  }

  late final _brkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>(
          'brk');
  late final _brk = _brkPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// Increase or decrease the end of accessible data space by DELTA bytes.
  /// If successful, returns the address the previous end of data space
  /// (i.e. the beginning of the new space, if DELTA > 0);
  /// returns (void *) -1 for errors (with errno set).
  ffi.Pointer<ffi.Void> sbrk(
    int __delta,
  ) {
    return _sbrk(
      __delta,
    );
  }

  late final _sbrkPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.IntPtr)>>(
          'sbrk');
  late final _sbrk = _sbrkPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Invoke `system call' number SYSNO, passing it the remaining arguments.
  /// This is completely system-dependent, and not often useful.
  ///
  /// In Unix, `syscall' sets `errno' for all errors and most calls return -1
  /// for errors; in many systems you cannot pass arguments or get return
  /// values for all system calls (`pipe', `fork', and `getppid' typically
  /// among them).
  ///
  /// In Mach, all system calls take normal arguments and always return an
  /// error code (zero for success).
  int syscall(
    int __sysno,
  ) {
    return _syscall(
      __sysno,
    );
  }

  late final _syscallPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('syscall');
  late final _syscall = _syscallPtr.asFunction<int Function(int)>();

  /// Synchronize at least the data part of a file with the underlying
  /// media.
  int fdatasync(
    int __fildes,
  ) {
    return _fdatasync(
      __fildes,
    );
  }

  late final _fdatasyncPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fdatasync');
  late final _fdatasync = _fdatasyncPtr.asFunction<int Function(int)>();

  /// One-way hash PHRASE, returning a string suitable for storage in the
  /// user database.  SALT selects the one-way function to use, and
  /// ensures that no two users' hashes are the same, even if they use
  /// the same passphrase.  The return value points to static storage
  /// which will be overwritten by the next call to crypt.
  ffi.Pointer<ffi.Char> crypt(
    ffi.Pointer<ffi.Char> __key,
    ffi.Pointer<ffi.Char> __salt,
  ) {
    return _crypt(
      __key,
      __salt,
    );
  }

  late final _cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('crypt');
  late final _crypt = _cryptPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on
  /// success or -1 on error.
  int getentropy(
    ffi.Pointer<ffi.Void> __buffer,
    int __length,
  ) {
    return _getentropy(
      __buffer,
      __length,
    );
  }

  late final _getentropyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Size)>>('getentropy');
  late final _getentropy =
      _getentropyPtr.asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();
}

typedef mode_t = __mode_t;
typedef __mode_t = ffi.UnsignedInt;
typedef Dart__mode_t = int;
typedef off_t = __off_t;
typedef __off_t = ffi.Long;
typedef Dart__off_t = int;
typedef ssize_t = __ssize_t;
typedef __ssize_t = ffi.Long;
typedef Dart__ssize_t = int;
typedef __useconds_t = ffi.UnsignedInt;
typedef Dart__useconds_t = int;
typedef __uid_t = ffi.UnsignedInt;
typedef Dart__uid_t = int;
typedef __gid_t = ffi.UnsignedInt;
typedef Dart__gid_t = int;
typedef __pid_t = ffi.Int;
typedef Dart__pid_t = int;

final class f_owner_ex extends ffi.Struct {
  @ffi.Int()
  external int type;

  @__kernel_pid_t()
  external int pid;
}

typedef __kernel_pid_t = ffi.Int;
typedef Dart__kernel_pid_t = int;

final class flock extends ffi.Struct {
  @ffi.Short()
  external int l_type;

  @ffi.Short()
  external int l_whence;

  @__kernel_off_t()
  external int l_start;

  @__kernel_off_t()
  external int l_len;

  @__kernel_pid_t()
  external int l_pid;
}

typedef __kernel_off_t = __kernel_long_t;
typedef __kernel_long_t = ffi.Long;
typedef Dart__kernel_long_t = int;

final class flock64 extends ffi.Struct {
  @ffi.Short()
  external int l_type;

  @ffi.Short()
  external int l_whence;

  @__kernel_loff_t()
  external int l_start;

  @__kernel_loff_t()
  external int l_len;

  @__kernel_pid_t()
  external int l_pid;
}

typedef __kernel_loff_t = ffi.LongLong;
typedef Dart__kernel_loff_t = int;

const int _FCNTL_H = 1;

const int S_IFMT = 61440;

const int S_IFDIR = 16384;

const int S_IFCHR = 8192;

const int S_IFBLK = 24576;

const int S_IFREG = 32768;

const int S_IFIFO = 4096;

const int S_IFLNK = 40960;

const int S_IFSOCK = 49152;

const int S_ISUID = 2048;

const int S_ISGID = 1024;

const int S_ISVTX = 512;

const int S_IRUSR = 256;

const int S_IWUSR = 128;

const int S_IXUSR = 64;

const int S_IRWXU = 448;

const int S_IRGRP = 32;

const int S_IWGRP = 16;

const int S_IXGRP = 8;

const int S_IRWXG = 56;

const int S_IROTH = 4;

const int S_IWOTH = 2;

const int S_IXOTH = 1;

const int S_IRWXO = 7;

const int R_OK = 4;

const int W_OK = 2;

const int X_OK = 1;

const int F_OK = 0;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int F_ULOCK = 0;

const int F_LOCK = 1;

const int F_TLOCK = 2;

const int F_TEST = 3;

const int _UNISTD_H = 1;

const int _POSIX_VERSION = 200809;

const int __POSIX2_THIS_VERSION = 200809;

const int _POSIX2_VERSION = 200809;

const int _POSIX2_C_VERSION = 200809;

const int _POSIX2_C_BIND = 200809;

const int _POSIX2_C_DEV = 200809;

const int _POSIX2_SW_DEV = 200809;

const int _POSIX2_LOCALEDEF = 200809;

const int _XOPEN_VERSION = 700;

const int _XOPEN_XCU_VERSION = 4;

const int _XOPEN_XPG2 = 1;

const int _XOPEN_XPG3 = 1;

const int _XOPEN_XPG4 = 1;

const int _XOPEN_UNIX = 1;

const int _XOPEN_ENH_I18N = 1;

const int _XOPEN_LEGACY = 1;

const int STDIN_FILENO = 0;

const int STDOUT_FILENO = 1;

const int STDERR_FILENO = 2;

const int L_SET = 0;

const int L_INCR = 1;

const int L_XTND = 2;

const int O_ACCMODE = 3;

const int O_RDONLY = 0;

const int O_WRONLY = 1;

const int O_RDWR = 2;

const int O_CREAT = 64;

const int O_EXCL = 128;

const int O_NOCTTY = 256;

const int O_TRUNC = 512;

const int O_APPEND = 1024;

const int O_NONBLOCK = 2048;

const int O_DSYNC = 4096;

const int FASYNC = 8192;

const int O_DIRECT = 16384;

const int O_LARGEFILE = 0;

const int O_DIRECTORY = 65536;

const int O_NOFOLLOW = 131072;

const int O_NOATIME = 262144;

const int O_CLOEXEC = 524288;

const int O_SYNC = 1052672;

const int O_PATH = 2097152;

const int __O_TMPFILE = 4259840;

const int O_TMPFILE = 4259840;

const int O_TMPFILE_MASK = 4259904;

const int O_NDELAY = 2048;

const int F_DUPFD = 0;

const int F_GETFD = 1;

const int F_SETFD = 2;

const int F_GETFL = 3;

const int F_SETFL = 4;

const int F_GETLK = 5;

const int F_SETLK = 6;

const int F_SETLKW = 7;

const int F_SETOWN = 8;

const int F_GETOWN = 9;

const int F_SETSIG = 10;

const int F_GETSIG = 11;

const int F_GETLK64 = 5;

const int F_SETLK64 = 6;

const int F_SETLKW64 = 7;

const int F_SETOWN_EX = 15;

const int F_GETOWN_EX = 16;

const int F_GETOWNER_UIDS = 17;

const int F_OFD_GETLK = 36;

const int F_OFD_SETLK = 37;

const int F_OFD_SETLKW = 38;

const int F_OWNER_TID = 0;

const int F_OWNER_PID = 1;

const int F_OWNER_PGRP = 2;

const int FD_CLOEXEC = 1;

const int F_RDLCK = 0;

const int F_WRLCK = 1;

const int F_UNLCK = 2;

const int F_EXLCK = 4;

const int F_SHLCK = 8;

const int LOCK_SH = 1;

const int LOCK_EX = 2;

const int LOCK_NB = 4;

const int LOCK_UN = 8;

const int LOCK_MAND = 32;

const int LOCK_READ = 64;

const int LOCK_WRITE = 128;

const int LOCK_RW = 192;

const int F_LINUX_SPECIFIC_BASE = 1024;
