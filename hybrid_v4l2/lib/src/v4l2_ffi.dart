// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// E N U M S
sealed class v4l2_field {
  /// driver can choose from none,
  /// top, bottom, interlaced
  /// depending on whatever it thinks
  /// is approximate ...
  static const V4L2_FIELD_ANY = 0;

  /// this device has no fields ...
  static const V4L2_FIELD_NONE = 1;

  /// top field only
  static const V4L2_FIELD_TOP = 2;

  /// bottom field only
  static const V4L2_FIELD_BOTTOM = 3;

  /// both fields interlaced
  static const V4L2_FIELD_INTERLACED = 4;

  /// both fields sequential into one
  /// buffer, top-bottom order
  static const V4L2_FIELD_SEQ_TB = 5;

  /// same as above + bottom-top order
  static const V4L2_FIELD_SEQ_BT = 6;

  /// both fields alternating into
  /// separate buffers
  static const V4L2_FIELD_ALTERNATE = 7;

  /// both fields interlaced, top field
  /// first and the top field is
  /// transmitted first
  static const V4L2_FIELD_INTERLACED_TB = 8;

  /// both fields interlaced, top field
  /// first and the bottom field is
  /// transmitted first
  static const V4L2_FIELD_INTERLACED_BT = 9;
}

sealed class v4l2_buf_type {
  static const V4L2_BUF_TYPE_VIDEO_CAPTURE = 1;
  static const V4L2_BUF_TYPE_VIDEO_OUTPUT = 2;
  static const V4L2_BUF_TYPE_VIDEO_OVERLAY = 3;
  static const V4L2_BUF_TYPE_VBI_CAPTURE = 4;
  static const V4L2_BUF_TYPE_VBI_OUTPUT = 5;
  static const V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6;
  static const V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7;
  static const V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8;
  static const V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9;
  static const V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10;
  static const V4L2_BUF_TYPE_SDR_CAPTURE = 11;
  static const V4L2_BUF_TYPE_SDR_OUTPUT = 12;
  static const V4L2_BUF_TYPE_META_CAPTURE = 13;
  static const V4L2_BUF_TYPE_META_OUTPUT = 14;

  /// Deprecated, do not use
  static const V4L2_BUF_TYPE_PRIVATE = 128;
}

enum v4l2_tuner_type {
  V4L2_TUNER_RADIO(1),
  V4L2_TUNER_ANALOG_TV(2),
  V4L2_TUNER_DIGITAL_TV(3),
  V4L2_TUNER_SDR(4),
  V4L2_TUNER_RF(5);

  final int value;
  const v4l2_tuner_type(this.value);

  static v4l2_tuner_type fromValue(int value) => switch (value) {
        1 => V4L2_TUNER_RADIO,
        2 => V4L2_TUNER_ANALOG_TV,
        3 => V4L2_TUNER_DIGITAL_TV,
        4 => V4L2_TUNER_SDR,
        5 => V4L2_TUNER_RF,
        _ => throw ArgumentError("Unknown value for v4l2_tuner_type: $value"),
      };
}

sealed class v4l2_memory {
  static const V4L2_MEMORY_MMAP = 1;
  static const V4L2_MEMORY_USERPTR = 2;
  static const V4L2_MEMORY_OVERLAY = 3;
  static const V4L2_MEMORY_DMABUF = 4;
}

/// see also http://vektor.theorem.ca/graphics/ycbcr/
enum v4l2_colorspace {
  /// Default colorspace, i.e. let the driver figure it out.
  /// Can only be used with video capture.
  V4L2_COLORSPACE_DEFAULT(0),

  /// SMPTE 170M: used for broadcast NTSC/PAL SDTV
  V4L2_COLORSPACE_SMPTE170M(1),

  /// Obsolete pre-1998 SMPTE 240M HDTV standard, superseded by Rec 709
  V4L2_COLORSPACE_SMPTE240M(2),

  /// Rec.709: used for HDTV
  V4L2_COLORSPACE_REC709(3),

  /// Deprecated, do not use. No driver will ever return this. This was
  /// based on a misunderstanding of the bt878 datasheet.
  V4L2_COLORSPACE_BT878(4),

  /// NTSC 1953 colorspace. This only makes sense when dealing with
  /// really, really old NTSC recordings. Superseded by SMPTE 170M.
  V4L2_COLORSPACE_470_SYSTEM_M(5),

  /// EBU Tech 3213 PAL/SECAM colorspace.
  V4L2_COLORSPACE_470_SYSTEM_BG(6),

  /// Effectively shorthand for V4L2_COLORSPACE_SRGB, V4L2_YCBCR_ENC_601
  /// and V4L2_QUANTIZATION_FULL_RANGE. To be used for (Motion-)JPEG.
  V4L2_COLORSPACE_JPEG(7),

  /// For RGB colorspaces such as produces by most webcams.
  V4L2_COLORSPACE_SRGB(8),

  /// opRGB colorspace
  V4L2_COLORSPACE_OPRGB(9),

  /// BT.2020 colorspace, used for UHDTV.
  V4L2_COLORSPACE_BT2020(10),

  /// Raw colorspace: for RAW unprocessed images
  V4L2_COLORSPACE_RAW(11),

  /// DCI-P3 colorspace, used by cinema projectors
  V4L2_COLORSPACE_DCI_P3(12);

  final int value;
  const v4l2_colorspace(this.value);

  static v4l2_colorspace fromValue(int value) => switch (value) {
        0 => V4L2_COLORSPACE_DEFAULT,
        1 => V4L2_COLORSPACE_SMPTE170M,
        2 => V4L2_COLORSPACE_SMPTE240M,
        3 => V4L2_COLORSPACE_REC709,
        4 => V4L2_COLORSPACE_BT878,
        5 => V4L2_COLORSPACE_470_SYSTEM_M,
        6 => V4L2_COLORSPACE_470_SYSTEM_BG,
        7 => V4L2_COLORSPACE_JPEG,
        8 => V4L2_COLORSPACE_SRGB,
        9 => V4L2_COLORSPACE_OPRGB,
        10 => V4L2_COLORSPACE_BT2020,
        11 => V4L2_COLORSPACE_RAW,
        12 => V4L2_COLORSPACE_DCI_P3,
        _ => throw ArgumentError("Unknown value for v4l2_colorspace: $value"),
      };
}

enum v4l2_xfer_func {
  /// Mapping of V4L2_XFER_FUNC_DEFAULT to actual transfer functions
  /// for the various colorspaces:
  ///
  /// V4L2_COLORSPACE_SMPTE170M, V4L2_COLORSPACE_470_SYSTEM_M,
  /// V4L2_COLORSPACE_470_SYSTEM_BG, V4L2_COLORSPACE_REC709 and
  /// V4L2_COLORSPACE_BT2020: V4L2_XFER_FUNC_709
  ///
  /// V4L2_COLORSPACE_SRGB, V4L2_COLORSPACE_JPEG: V4L2_XFER_FUNC_SRGB
  ///
  /// V4L2_COLORSPACE_OPRGB: V4L2_XFER_FUNC_OPRGB
  ///
  /// V4L2_COLORSPACE_SMPTE240M: V4L2_XFER_FUNC_SMPTE240M
  ///
  /// V4L2_COLORSPACE_RAW: V4L2_XFER_FUNC_NONE
  ///
  /// V4L2_COLORSPACE_DCI_P3: V4L2_XFER_FUNC_DCI_P3
  V4L2_XFER_FUNC_DEFAULT(0),
  V4L2_XFER_FUNC_709(1),
  V4L2_XFER_FUNC_SRGB(2),
  V4L2_XFER_FUNC_OPRGB(3),
  V4L2_XFER_FUNC_SMPTE240M(4),
  V4L2_XFER_FUNC_NONE(5),
  V4L2_XFER_FUNC_DCI_P3(6),
  V4L2_XFER_FUNC_SMPTE2084(7);

  final int value;
  const v4l2_xfer_func(this.value);

  static v4l2_xfer_func fromValue(int value) => switch (value) {
        0 => V4L2_XFER_FUNC_DEFAULT,
        1 => V4L2_XFER_FUNC_709,
        2 => V4L2_XFER_FUNC_SRGB,
        3 => V4L2_XFER_FUNC_OPRGB,
        4 => V4L2_XFER_FUNC_SMPTE240M,
        5 => V4L2_XFER_FUNC_NONE,
        6 => V4L2_XFER_FUNC_DCI_P3,
        7 => V4L2_XFER_FUNC_SMPTE2084,
        _ => throw ArgumentError("Unknown value for v4l2_xfer_func: $value"),
      };
}

enum v4l2_ycbcr_encoding {
  /// Mapping of V4L2_YCBCR_ENC_DEFAULT to actual encodings for the
  /// various colorspaces:
  ///
  /// V4L2_COLORSPACE_SMPTE170M, V4L2_COLORSPACE_470_SYSTEM_M,
  /// V4L2_COLORSPACE_470_SYSTEM_BG, V4L2_COLORSPACE_SRGB,
  /// V4L2_COLORSPACE_OPRGB and V4L2_COLORSPACE_JPEG: V4L2_YCBCR_ENC_601
  ///
  /// V4L2_COLORSPACE_REC709 and V4L2_COLORSPACE_DCI_P3: V4L2_YCBCR_ENC_709
  ///
  /// V4L2_COLORSPACE_BT2020: V4L2_YCBCR_ENC_BT2020
  ///
  /// V4L2_COLORSPACE_SMPTE240M: V4L2_YCBCR_ENC_SMPTE240M
  V4L2_YCBCR_ENC_DEFAULT(0),

  /// ITU-R 601 -- SDTV
  V4L2_YCBCR_ENC_601(1),

  /// Rec. 709 -- HDTV
  V4L2_YCBCR_ENC_709(2),

  /// ITU-R 601/EN 61966-2-4 Extended Gamut -- SDTV
  V4L2_YCBCR_ENC_XV601(3),

  /// Rec. 709/EN 61966-2-4 Extended Gamut -- HDTV
  V4L2_YCBCR_ENC_XV709(4),

  /// sYCC (Y'CbCr encoding of sRGB), identical to ENC_601. It was added
  /// originally due to a misunderstanding of the sYCC standard. It should
  /// not be used, instead use V4L2_YCBCR_ENC_601.
  V4L2_YCBCR_ENC_SYCC(5),

  /// BT.2020 Non-constant Luminance Y'CbCr
  V4L2_YCBCR_ENC_BT2020(6),

  /// BT.2020 Constant Luminance Y'CbcCrc
  V4L2_YCBCR_ENC_BT2020_CONST_LUM(7),

  /// SMPTE 240M -- Obsolete HDTV
  V4L2_YCBCR_ENC_SMPTE240M(8);

  final int value;
  const v4l2_ycbcr_encoding(this.value);

  static v4l2_ycbcr_encoding fromValue(int value) => switch (value) {
        0 => V4L2_YCBCR_ENC_DEFAULT,
        1 => V4L2_YCBCR_ENC_601,
        2 => V4L2_YCBCR_ENC_709,
        3 => V4L2_YCBCR_ENC_XV601,
        4 => V4L2_YCBCR_ENC_XV709,
        5 => V4L2_YCBCR_ENC_SYCC,
        6 => V4L2_YCBCR_ENC_BT2020,
        7 => V4L2_YCBCR_ENC_BT2020_CONST_LUM,
        8 => V4L2_YCBCR_ENC_SMPTE240M,
        _ =>
          throw ArgumentError("Unknown value for v4l2_ycbcr_encoding: $value"),
      };
}

/// enum v4l2_hsv_encoding values should not collide with the ones from
/// enum v4l2_ycbcr_encoding.
enum v4l2_hsv_encoding {
  /// Hue mapped to 0 - 179
  V4L2_HSV_ENC_180(128),

  /// Hue mapped to 0-255
  V4L2_HSV_ENC_256(129);

  final int value;
  const v4l2_hsv_encoding(this.value);

  static v4l2_hsv_encoding fromValue(int value) => switch (value) {
        128 => V4L2_HSV_ENC_180,
        129 => V4L2_HSV_ENC_256,
        _ => throw ArgumentError("Unknown value for v4l2_hsv_encoding: $value"),
      };
}

enum v4l2_quantization {
  /// The default for R'G'B' quantization is always full range.
  /// For Y'CbCr the quantization is always limited range, except
  /// for COLORSPACE_JPEG: this is full range.
  V4L2_QUANTIZATION_DEFAULT(0),
  V4L2_QUANTIZATION_FULL_RANGE(1),
  V4L2_QUANTIZATION_LIM_RANGE(2);

  final int value;
  const v4l2_quantization(this.value);

  static v4l2_quantization fromValue(int value) => switch (value) {
        0 => V4L2_QUANTIZATION_DEFAULT,
        1 => V4L2_QUANTIZATION_FULL_RANGE,
        2 => V4L2_QUANTIZATION_LIM_RANGE,
        _ => throw ArgumentError("Unknown value for v4l2_quantization: $value"),
      };
}

enum v4l2_priority {
  /// not initialized
  V4L2_PRIORITY_UNSET(0),
  V4L2_PRIORITY_BACKGROUND(1),
  V4L2_PRIORITY_INTERACTIVE(2),
  V4L2_PRIORITY_RECORD(3);

  static const V4L2_PRIORITY_DEFAULT = V4L2_PRIORITY_INTERACTIVE;

  final int value;
  const v4l2_priority(this.value);

  static v4l2_priority fromValue(int value) => switch (value) {
        0 => V4L2_PRIORITY_UNSET,
        1 => V4L2_PRIORITY_BACKGROUND,
        2 => V4L2_PRIORITY_INTERACTIVE,
        3 => V4L2_PRIORITY_RECORD,
        _ => throw ArgumentError("Unknown value for v4l2_priority: $value"),
      };

  @override
  String toString() {
    if (this == V4L2_PRIORITY_INTERACTIVE)
      return "v4l2_priority.V4L2_PRIORITY_INTERACTIVE, v4l2_priority.V4L2_PRIORITY_DEFAULT";
    return super.toString();
  }
}

final class v4l2_rect extends ffi.Struct {
  @__s32()
  external int left;

  @__s32()
  external int top;

  @__u32()
  external int width;

  @__u32()
  external int height;
}

typedef __s32 = ffi.Int;
typedef Dart__s32 = int;
typedef __u32 = ffi.UnsignedInt;
typedef Dart__u32 = int;

final class v4l2_fract extends ffi.Struct {
  @__u32()
  external int numerator;

  @__u32()
  external int denominator;
}

final class v4l2_area extends ffi.Struct {
  @__u32()
  external int width;

  @__u32()
  external int height;
}

/// struct v4l2_capability - Describes V4L2 device caps returned by VIDIOC_QUERYCAP
///
/// @driver:	   name of the driver module (e.g. "bttv")
/// @card:	   name of the card (e.g. "Hauppauge WinTV")
/// @bus_info:	   name of the bus (e.g. "PCI:" + pci_name(pci_dev) )
/// @version:	   KERNEL_VERSION
/// @capabilities: capabilities of the physical device as a whole
/// @device_caps:  capabilities accessed via this particular device (node)
/// @reserved:	   reserved fields for future extensions
final class v4l2_capability extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__u8> driver;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> card;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> bus_info;

  @__u32()
  external int version;

  @__u32()
  external int capabilities;

  @__u32()
  external int device_caps;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

typedef __u8 = ffi.UnsignedChar;
typedef Dart__u8 = int;

/// V I D E O   I M A G E   F O R M A T
final class v4l2_pix_format extends ffi.Struct {
  @__u32()
  external int width;

  @__u32()
  external int height;

  @__u32()
  external int pixelformat;

  /// enum v4l2_field
  @__u32()
  external int field;

  /// for padding, zero if unused
  @__u32()
  external int bytesperline;

  @__u32()
  external int sizeimage;

  /// enum v4l2_colorspace
  @__u32()
  external int colorspace;

  /// private data, depends on pixelformat
  @__u32()
  external int priv;

  /// format flags (V4L2_PIX_FMT_FLAG_*)
  @__u32()
  external int flags;

  external UnnamedUnion1 unnamed;

  /// enum v4l2_quantization
  @__u32()
  external int quantization;

  /// enum v4l2_xfer_func
  @__u32()
  external int xfer_func;
}

final class UnnamedUnion1 extends ffi.Union {
  /// enum v4l2_ycbcr_encoding
  @__u32()
  external int ycbcr_enc;

  /// enum v4l2_hsv_encoding
  @__u32()
  external int hsv_enc;
}

/// F O R M A T   E N U M E R A T I O N
final class v4l2_fmtdesc extends ffi.Struct {
  /// Format number
  @__u32()
  external int index;

  /// enum v4l2_buf_type
  @__u32()
  external int type;

  @__u32()
  external int flags;

  /// Description string
  @ffi.Array.multi([32])
  external ffi.Array<__u8> description;

  /// Format fourcc
  @__u32()
  external int pixelformat;

  /// Media bus code
  @__u32()
  external int mbus_code;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

/// Frame Size and frame rate enumeration */
/// /*
/// F R A M E   S I Z E   E N U M E R A T I O N
sealed class v4l2_frmsizetypes {
  static const V4L2_FRMSIZE_TYPE_DISCRETE = 1;
  static const V4L2_FRMSIZE_TYPE_CONTINUOUS = 2;
  static const V4L2_FRMSIZE_TYPE_STEPWISE = 3;
}

final class v4l2_frmsize_discrete extends ffi.Struct {
  /// Frame width [pixel]
  @__u32()
  external int width;

  /// Frame height [pixel]
  @__u32()
  external int height;
}

final class v4l2_frmsize_stepwise extends ffi.Struct {
  /// Minimum frame width [pixel]
  @__u32()
  external int min_width;

  /// Maximum frame width [pixel]
  @__u32()
  external int max_width;

  /// Frame width step size [pixel]
  @__u32()
  external int step_width;

  /// Minimum frame height [pixel]
  @__u32()
  external int min_height;

  /// Maximum frame height [pixel]
  @__u32()
  external int max_height;

  /// Frame height step size [pixel]
  @__u32()
  external int step_height;
}

final class v4l2_frmsizeenum extends ffi.Struct {
  /// Frame size number
  @__u32()
  external int index;

  /// Pixel format
  @__u32()
  external int pixel_format;

  /// Frame size type the device supports.
  @__u32()
  external int type;

  external UnnamedUnion2 unnamed;

  /// Reserved space for future use
  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class UnnamedUnion2 extends ffi.Union {
  external v4l2_frmsize_discrete discrete;

  external v4l2_frmsize_stepwise stepwise;
}

/// F R A M E   R A T E   E N U M E R A T I O N
enum v4l2_frmivaltypes {
  V4L2_FRMIVAL_TYPE_DISCRETE(1),
  V4L2_FRMIVAL_TYPE_CONTINUOUS(2),
  V4L2_FRMIVAL_TYPE_STEPWISE(3);

  final int value;
  const v4l2_frmivaltypes(this.value);

  static v4l2_frmivaltypes fromValue(int value) => switch (value) {
        1 => V4L2_FRMIVAL_TYPE_DISCRETE,
        2 => V4L2_FRMIVAL_TYPE_CONTINUOUS,
        3 => V4L2_FRMIVAL_TYPE_STEPWISE,
        _ => throw ArgumentError("Unknown value for v4l2_frmivaltypes: $value"),
      };
}

final class v4l2_frmival_stepwise extends ffi.Struct {
  /// Minimum frame interval [s]
  external v4l2_fract min;

  /// Maximum frame interval [s]
  external v4l2_fract max;

  /// Frame interval step size [s]
  external v4l2_fract step;
}

final class v4l2_frmivalenum extends ffi.Struct {
  /// Frame format index
  @__u32()
  external int index;

  /// Pixel format
  @__u32()
  external int pixel_format;

  /// Frame width
  @__u32()
  external int width;

  /// Frame height
  @__u32()
  external int height;

  /// Frame interval type the device supports.
  @__u32()
  external int type;

  external UnnamedUnion3 unnamed;

  /// Reserved space for future use
  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class UnnamedUnion3 extends ffi.Union {
  external v4l2_fract discrete;

  external v4l2_frmival_stepwise stepwise;
}

/// T I M E C O D E
final class v4l2_timecode extends ffi.Struct {
  @__u32()
  external int type;

  @__u32()
  external int flags;

  @__u8()
  external int frames;

  @__u8()
  external int seconds;

  @__u8()
  external int minutes;

  @__u8()
  external int hours;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> userbits;
}

/// The above is based on SMPTE timecodes
final class v4l2_jpegcompression extends ffi.Struct {
  @ffi.Int()
  external int quality;

  /// Number of APP segment to be written,
  /// must be 0..15
  @ffi.Int()
  external int APPn;

  /// Length of data in JPEG APPn segment
  @ffi.Int()
  external int APP_len;

  /// Data in the JPEG APPn segment.
  @ffi.Array.multi([60])
  external ffi.Array<ffi.Char> APP_data;

  /// Length of data in JPEG COM segment
  @ffi.Int()
  external int COM_len;

  /// Data in JPEG COM segment
  @ffi.Array.multi([60])
  external ffi.Array<ffi.Char> COM_data;

  /// Which markers should go into the JPEG
  /// output. Unless you exactly know what
  /// you do, leave them untouched.
  /// Including less markers will make the
  /// resulting code smaller, but there will
  /// be fewer applications which can read it.
  /// The presence of the APP and COM marker
  /// is influenced by APP_len and COM_len
  /// ONLY, not by this property!
  @__u32()
  external int jpeg_markers;
}

/// M E M O R Y - M A P P I N G   B U F F E R S
final class v4l2_requestbuffers extends ffi.Struct {
  @__u32()
  external int count;

  /// enum v4l2_buf_type
  @__u32()
  external int type;

  /// enum v4l2_memory
  @__u32()
  external int memory;

  @__u32()
  external int capabilities;

  @__u8()
  external int flags;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> reserved;
}

/// struct v4l2_plane - plane info for multi-planar buffers
/// @bytesused:		number of bytes occupied by data in the plane (payload)
/// @length:		size of this plane (NOT the payload) in bytes
/// @mem_offset:		when memory in the associated struct v4l2_buffer is
/// V4L2_MEMORY_MMAP, equals the offset from the start of
/// the device memory for this plane (or is a "cookie" that
/// should be passed to mmap() called on the video node)
/// @userptr:		when memory is V4L2_MEMORY_USERPTR, a userspace pointer
/// pointing to this plane
/// @fd:			when memory is V4L2_MEMORY_DMABUF, a userspace file
/// descriptor associated with this plane
/// @m:			union of @mem_offset, @userptr and @fd
/// @data_offset:	offset in the plane to the start of data; usually 0,
/// unless there is a header in front of the data
/// @reserved:		drivers and applications must zero this array
///
/// Multi-planar buffers consist of one or more planes, e.g. an YCbCr buffer
/// with two planes can have one plane for Y, and another for interleaved CbCr
/// components. Each plane can reside in a separate memory buffer, or even in
/// a completely separate memory node (e.g. in embedded devices).
final class v4l2_plane extends ffi.Struct {
  @__u32()
  external int bytesused;

  @__u32()
  external int length;

  external UnnamedUnion4 m;

  @__u32()
  external int data_offset;

  @ffi.Array.multi([11])
  external ffi.Array<__u32> reserved;
}

final class UnnamedUnion4 extends ffi.Union {
  @__u32()
  external int mem_offset;

  @ffi.UnsignedLong()
  external int userptr;

  @__s32()
  external int fd;
}

/// struct v4l2_buffer - video buffer info
/// @index:	id number of the buffer
/// @type:	enum v4l2_buf_type; buffer type (type == *_MPLANE for
/// multiplanar buffers);
/// @bytesused:	number of bytes occupied by data in the buffer (payload);
/// unused (set to 0) for multiplanar buffers
/// @flags:	buffer informational flags
/// @field:	enum v4l2_field; field order of the image in the buffer
/// @timestamp:	frame timestamp
/// @timecode:	frame timecode
/// @sequence:	sequence count of this frame
/// @memory:	enum v4l2_memory; the method, in which the actual video data is
/// passed
/// @offset:	for non-multiplanar buffers with memory == V4L2_MEMORY_MMAP;
/// offset from the start of the device memory for this plane,
/// (or a "cookie" that should be passed to mmap() as offset)
/// @userptr:	for non-multiplanar buffers with memory == V4L2_MEMORY_USERPTR;
/// a userspace pointer pointing to this buffer
/// @fd:		for non-multiplanar buffers with memory == V4L2_MEMORY_DMABUF;
/// a userspace file descriptor associated with this buffer
/// @planes:	for multiplanar buffers; userspace pointer to the array of plane
/// info structs for this buffer
/// @m:		union of @offset, @userptr, @planes and @fd
/// @length:	size in bytes of the buffer (NOT its payload) for single-plane
/// buffers (when type != *_MPLANE); number of elements in the
/// planes array for multi-plane buffers
/// @reserved2:	drivers and applications must zero this field
/// @request_fd: fd of the request that this buffer should use
/// @reserved:	for backwards compatibility with applications that do not know
/// about @request_fd
///
/// Contains data exchanged by application and driver using one of the Streaming
/// I/O methods.
final class v4l2_buffer extends ffi.Struct {
  @__u32()
  external int index;

  @__u32()
  external int type;

  @__u32()
  external int bytesused;

  @__u32()
  external int flags;

  @__u32()
  external int field;

  external timeval timestamp;

  external v4l2_timecode timecode;

  @__u32()
  external int sequence;

  /// memory location
  @__u32()
  external int memory;

  external UnnamedUnion5 m;

  @__u32()
  external int length;

  @__u32()
  external int reserved2;

  external UnnamedUnion6 unnamed;
}

final class timeval extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__suseconds_t()
  external int tv_usec;
}

typedef __time_t = ffi.Long;
typedef Dart__time_t = int;
typedef __suseconds_t = ffi.Long;
typedef Dart__suseconds_t = int;

final class UnnamedUnion5 extends ffi.Union {
  @__u32()
  external int offset;

  @ffi.UnsignedLong()
  external int userptr;

  external ffi.Pointer<v4l2_plane> planes;

  @__s32()
  external int fd;
}

final class UnnamedUnion6 extends ffi.Union {
  @__s32()
  external int request_fd;

  @__u32()
  external int reserved;
}

/// struct v4l2_exportbuffer - export of video buffer as DMABUF file descriptor
///
/// @index:	id number of the buffer
/// @type:	enum v4l2_buf_type; buffer type (type == *_MPLANE for
/// multiplanar buffers);
/// @plane:	index of the plane to be exported, 0 for single plane queues
/// @flags:	flags for newly created file, currently only O_CLOEXEC is
/// supported, refer to manual of open syscall for more details
/// @fd:		file descriptor associated with DMABUF (set by driver)
/// @reserved:	drivers and applications must zero this array
///
/// Contains data used for exporting a video buffer as DMABUF file descriptor.
/// The buffer is identified by a 'cookie' returned by VIDIOC_QUERYBUF
/// (identical to the cookie used to mmap() the buffer to userspace). All
/// reserved fields must be set to zero. The field reserved0 is expected to
/// become a structure 'type' allowing an alternative layout of the structure
/// content. Therefore this field should not be used for any other extensions.
final class v4l2_exportbuffer extends ffi.Struct {
  /// enum v4l2_buf_type
  @__u32()
  external int type;

  @__u32()
  external int index;

  @__u32()
  external int plane;

  @__u32()
  external int flags;

  @__s32()
  external int fd;

  @ffi.Array.multi([11])
  external ffi.Array<__u32> reserved;
}

/// O V E R L A Y   P R E V I E W
final class v4l2_framebuffer extends ffi.Struct {
  @__u32()
  external int capability;

  @__u32()
  external int flags;

  /// FIXME: in theory we should pass something like PCI device + memory
  /// region + offset instead of some physical address
  external ffi.Pointer<ffi.Void> base;

  external UnnamedStruct1 fmt;
}

final class UnnamedStruct1 extends ffi.Struct {
  @__u32()
  external int width;

  @__u32()
  external int height;

  @__u32()
  external int pixelformat;

  /// enum v4l2_field
  @__u32()
  external int field;

  /// for padding, zero if unused
  @__u32()
  external int bytesperline;

  @__u32()
  external int sizeimage;

  /// enum v4l2_colorspace
  @__u32()
  external int colorspace;

  /// reserved field, set to 0
  @__u32()
  external int priv;
}

final class v4l2_clip extends ffi.Struct {
  external v4l2_rect c;

  external ffi.Pointer<v4l2_clip> next;
}

final class v4l2_window extends ffi.Struct {
  external v4l2_rect w;

  /// enum v4l2_field
  @__u32()
  external int field;

  @__u32()
  external int chromakey;

  external ffi.Pointer<v4l2_clip> clips;

  @__u32()
  external int clipcount;

  external ffi.Pointer<ffi.Void> bitmap;

  @__u8()
  external int global_alpha;
}

/// C A P T U R E   P A R A M E T E R S
final class v4l2_captureparm extends ffi.Struct {
  /// Supported modes
  @__u32()
  external int capability;

  /// Current mode
  @__u32()
  external int capturemode;

  /// Time per frame in seconds
  external v4l2_fract timeperframe;

  /// Driver-specific extensions
  @__u32()
  external int extendedmode;

  /// # of buffers for read
  @__u32()
  external int readbuffers;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> reserved;
}

final class v4l2_outputparm extends ffi.Struct {
  /// Supported modes
  @__u32()
  external int capability;

  /// Current mode
  @__u32()
  external int outputmode;

  /// Time per frame in seconds
  external v4l2_fract timeperframe;

  /// Driver-specific extensions
  @__u32()
  external int extendedmode;

  /// # of buffers for write
  @__u32()
  external int writebuffers;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> reserved;
}

/// I N P U T   I M A G E   C R O P P I N G
final class v4l2_cropcap extends ffi.Struct {
  /// enum v4l2_buf_type
  @__u32()
  external int type;

  external v4l2_rect bounds;

  external v4l2_rect defrect;

  external v4l2_fract pixelaspect;
}

final class v4l2_crop extends ffi.Struct {
  /// enum v4l2_buf_type
  @__u32()
  external int type;

  external v4l2_rect c;
}

/// struct v4l2_selection - selection info
/// @type:	buffer type (do not use *_MPLANE types)
/// @target:	Selection target, used to choose one of possible rectangles;
/// defined in v4l2-common.h; V4L2_SEL_TGT_* .
/// @flags:	constraints flags, defined in v4l2-common.h; V4L2_SEL_FLAG_*.
/// @r:		coordinates of selection window
/// @reserved:	for future use, rounds structure size to 64 bytes, set to zero
///
/// Hardware may use multiple helper windows to process a video stream.
/// The structure is used to exchange this selection areas between
/// an application and a driver.
final class v4l2_selection extends ffi.Struct {
  @__u32()
  external int type;

  @__u32()
  external int target;

  @__u32()
  external int flags;

  external v4l2_rect r;

  @ffi.Array.multi([9])
  external ffi.Array<__u32> reserved;
}

final class v4l2_standard extends ffi.Struct {
  @__u32()
  external int index;

  @v4l2_std_id()
  external int id;

  @ffi.Array.multi([24])
  external ffi.Array<__u8> name;

  /// Frames, not fields
  external v4l2_fract frameperiod;

  @__u32()
  external int framelines;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> reserved;
}

/// A N A L O G   V I D E O   S T A N D A R D
typedef v4l2_std_id = __u64;
typedef __u64 = ffi.UnsignedLongLong;
typedef Dart__u64 = int;

/// struct v4l2_bt_timings - BT.656/BT.1120 timing data
/// @width:	total width of the active video in pixels
/// @height:	total height of the active video in lines
/// @interlaced:	Interlaced or progressive
/// @polarities:	Positive or negative polarities
/// @pixelclock:	Pixel clock in HZ. Ex. 74.25MHz->74250000
/// @hfrontporch:Horizontal front porch in pixels
/// @hsync:	Horizontal Sync length in pixels
/// @hbackporch:	Horizontal back porch in pixels
/// @vfrontporch:Vertical front porch in lines
/// @vsync:	Vertical Sync length in lines
/// @vbackporch:	Vertical back porch in lines
/// @il_vfrontporch:Vertical front porch for the even field
/// (aka field 2) of interlaced field formats
/// @il_vsync:	Vertical Sync length for the even field
/// (aka field 2) of interlaced field formats
/// @il_vbackporch:Vertical back porch for the even field
/// (aka field 2) of interlaced field formats
/// @standards:	Standards the timing belongs to
/// @flags:	Flags
/// @picture_aspect: The picture aspect ratio (hor/vert).
/// @cea861_vic:	VIC code as per the CEA-861 standard.
/// @hdmi_vic:	VIC code as per the HDMI standard.
/// @reserved:	Reserved fields, must be zeroed.
///
/// A note regarding vertical interlaced timings: height refers to the total
/// height of the active video frame (= two fields). The blanking timings refer
/// to the blanking of each field. So the height of the total frame is
/// calculated as follows:
///
/// tot_height = height + vfrontporch + vsync + vbackporch +
/// il_vfrontporch + il_vsync + il_vbackporch
///
/// The active height of each field is height / 2.
@ffi.Packed(1)
final class v4l2_bt_timings extends ffi.Struct {
  @__u32()
  external int width;

  @__u32()
  external int height;

  @__u32()
  external int interlaced;

  @__u32()
  external int polarities;

  @__u64()
  external int pixelclock;

  @__u32()
  external int hfrontporch;

  @__u32()
  external int hsync;

  @__u32()
  external int hbackporch;

  @__u32()
  external int vfrontporch;

  @__u32()
  external int vsync;

  @__u32()
  external int vbackporch;

  @__u32()
  external int il_vfrontporch;

  @__u32()
  external int il_vsync;

  @__u32()
  external int il_vbackporch;

  @__u32()
  external int standards;

  @__u32()
  external int flags;

  external v4l2_fract picture_aspect;

  @__u8()
  external int cea861_vic;

  @__u8()
  external int hdmi_vic;

  @ffi.Array.multi([46])
  external ffi.Array<__u8> reserved;
}

/// struct v4l2_dv_timings - DV timings
/// @type:	the type of the timings
/// @bt:	BT656/1120 timings
@ffi.Packed(1)
final class v4l2_dv_timings extends ffi.Struct {
  @__u32()
  external int type;

  external UnnamedUnion7 unnamed;
}

final class UnnamedUnion7 extends ffi.Union {
  external v4l2_bt_timings bt;

  @ffi.Array.multi([32])
  external ffi.Array<__u32> reserved;
}

/// struct v4l2_enum_dv_timings - DV timings enumeration
/// @index:	enumeration index
/// @pad:	the pad number for which to enumerate timings (used with
/// v4l-subdev nodes only)
/// @reserved:	must be zeroed
/// @timings:	the timings for the given index
final class v4l2_enum_dv_timings extends ffi.Struct {
  @__u32()
  external int index;

  @__u32()
  external int pad;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;

  external v4l2_dv_timings timings;
}

/// struct v4l2_bt_timings_cap - BT.656/BT.1120 timing capabilities
/// @min_width:		width in pixels
/// @max_width:		width in pixels
/// @min_height:		height in lines
/// @max_height:		height in lines
/// @min_pixelclock:	Pixel clock in HZ. Ex. 74.25MHz->74250000
/// @max_pixelclock:	Pixel clock in HZ. Ex. 74.25MHz->74250000
/// @standards:		Supported standards
/// @capabilities:	Supported capabilities
/// @reserved:		Must be zeroed
@ffi.Packed(1)
final class v4l2_bt_timings_cap extends ffi.Struct {
  @__u32()
  external int min_width;

  @__u32()
  external int max_width;

  @__u32()
  external int min_height;

  @__u32()
  external int max_height;

  @__u64()
  external int min_pixelclock;

  @__u64()
  external int max_pixelclock;

  @__u32()
  external int standards;

  @__u32()
  external int capabilities;

  @ffi.Array.multi([16])
  external ffi.Array<__u32> reserved;
}

/// struct v4l2_dv_timings_cap - DV timings capabilities
/// @type:	the type of the timings (same as in struct v4l2_dv_timings)
/// @pad:	the pad number for which to query capabilities (used with
/// v4l-subdev nodes only)
/// @bt:		the BT656/1120 timings capabilities
final class v4l2_dv_timings_cap extends ffi.Struct {
  @__u32()
  external int type;

  @__u32()
  external int pad;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;

  external UnnamedUnion8 unnamed;
}

final class UnnamedUnion8 extends ffi.Union {
  external v4l2_bt_timings_cap bt;

  @ffi.Array.multi([32])
  external ffi.Array<__u32> raw_data;
}

/// V I D E O   I N P U T S
final class v4l2_input extends ffi.Struct {
  /// Which input
  @__u32()
  external int index;

  /// Label
  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  /// Type of input
  @__u32()
  external int type;

  /// Associated audios (bitfield)
  @__u32()
  external int audioset;

  /// Tuner index
  @__u32()
  external int tuner;

  @v4l2_std_id()
  external int std;

  @__u32()
  external int status;

  @__u32()
  external int capabilities;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

/// V I D E O   O U T P U T S
final class v4l2_output extends ffi.Struct {
  /// Which output
  @__u32()
  external int index;

  /// Label
  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  /// Type of output
  @__u32()
  external int type;

  /// Associated audios (bitfield)
  @__u32()
  external int audioset;

  /// Associated modulator
  @__u32()
  external int modulator;

  @v4l2_std_id()
  external int std;

  @__u32()
  external int capabilities;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

/// C O N T R O L S
final class v4l2_control extends ffi.Struct {
  @__u32()
  external int id;

  @__s32()
  external int value;
}

@ffi.Packed(1)
final class v4l2_ext_control extends ffi.Struct {
  @__u32()
  external int id;

  @__u32()
  external int size;

  @ffi.Array.multi([1])
  external ffi.Array<__u32> reserved2;

  external UnnamedUnion9 unnamed;
}

final class UnnamedUnion9 extends ffi.Union {
  @__s32()
  external int value;

  @__s64()
  external int value64;

  external ffi.Pointer<ffi.Char> string;

  external ffi.Pointer<__u8> p_u8;

  external ffi.Pointer<__u16> p_u16;

  external ffi.Pointer<__u32> p_u32;

  external ffi.Pointer<__s32> p_s32;

  external ffi.Pointer<__s64> p_s64;

  external ffi.Pointer<v4l2_area> p_area;

  external ffi.Pointer<v4l2_ctrl_h264_sps> p_h264_sps;

  external ffi.Pointer<v4l2_ctrl_h264_pps> p_h264_pps;

  external ffi.Pointer<v4l2_ctrl_h264_scaling_matrix> p_h264_scaling_matrix;

  external ffi.Pointer<v4l2_ctrl_h264_pred_weights> p_h264_pred_weights;

  external ffi.Pointer<v4l2_ctrl_h264_slice_params> p_h264_slice_params;

  external ffi.Pointer<v4l2_ctrl_h264_decode_params> p_h264_decode_params;

  external ffi.Pointer<v4l2_ctrl_fwht_params> p_fwht_params;

  external ffi.Pointer<v4l2_ctrl_vp8_frame> p_vp8_frame;

  external ffi.Pointer<v4l2_ctrl_mpeg2_sequence> p_mpeg2_sequence;

  external ffi.Pointer<v4l2_ctrl_mpeg2_picture> p_mpeg2_picture;

  external ffi.Pointer<v4l2_ctrl_mpeg2_quantisation> p_mpeg2_quantisation;

  external ffi.Pointer<v4l2_ctrl_vp9_compressed_hdr> p_vp9_compressed_hdr_probs;

  external ffi.Pointer<v4l2_ctrl_vp9_frame> p_vp9_frame;

  external ffi.Pointer<v4l2_ctrl_hevc_sps> p_hevc_sps;

  external ffi.Pointer<v4l2_ctrl_hevc_pps> p_hevc_pps;

  external ffi.Pointer<v4l2_ctrl_hevc_slice_params> p_hevc_slice_params;

  external ffi.Pointer<v4l2_ctrl_hevc_scaling_matrix> p_hevc_scaling_matrix;

  external ffi.Pointer<v4l2_ctrl_hevc_decode_params> p_hevc_decode_params;

  external ffi.Pointer<v4l2_ctrl_av1_sequence> p_av1_sequence;

  external ffi.Pointer<v4l2_ctrl_av1_tile_group_entry> p_av1_tile_group_entry;

  external ffi.Pointer<v4l2_ctrl_av1_frame> p_av1_frame;

  external ffi.Pointer<v4l2_ctrl_av1_film_grain> p_av1_film_grain;

  external ffi.Pointer<v4l2_ctrl_hdr10_cll_info> p_hdr10_cll_info;

  external ffi.Pointer<v4l2_ctrl_hdr10_mastering_display>
      p_hdr10_mastering_display;

  external ffi.Pointer<ffi.Void> ptr;
}

typedef __s64 = ffi.LongLong;
typedef Dart__s64 = int;
typedef __u16 = ffi.UnsignedShort;
typedef Dart__u16 = int;

final class v4l2_ctrl_h264_sps extends ffi.Struct {
  @__u8()
  external int profile_idc;

  @__u8()
  external int constraint_set_flags;

  @__u8()
  external int level_idc;

  @__u8()
  external int seq_parameter_set_id;

  @__u8()
  external int chroma_format_idc;

  @__u8()
  external int bit_depth_luma_minus8;

  @__u8()
  external int bit_depth_chroma_minus8;

  @__u8()
  external int log2_max_frame_num_minus4;

  @__u8()
  external int pic_order_cnt_type;

  @__u8()
  external int log2_max_pic_order_cnt_lsb_minus4;

  @__u8()
  external int max_num_ref_frames;

  @__u8()
  external int num_ref_frames_in_pic_order_cnt_cycle;

  @ffi.Array.multi([255])
  external ffi.Array<__s32> offset_for_ref_frame;

  @__s32()
  external int offset_for_non_ref_pic;

  @__s32()
  external int offset_for_top_to_bottom_field;

  @__u16()
  external int pic_width_in_mbs_minus1;

  @__u16()
  external int pic_height_in_map_units_minus1;

  @__u32()
  external int flags;
}

final class v4l2_ctrl_h264_pps extends ffi.Struct {
  @__u8()
  external int pic_parameter_set_id;

  @__u8()
  external int seq_parameter_set_id;

  @__u8()
  external int num_slice_groups_minus1;

  @__u8()
  external int num_ref_idx_l0_default_active_minus1;

  @__u8()
  external int num_ref_idx_l1_default_active_minus1;

  @__u8()
  external int weighted_bipred_idc;

  @__s8()
  external int pic_init_qp_minus26;

  @__s8()
  external int pic_init_qs_minus26;

  @__s8()
  external int chroma_qp_index_offset;

  @__s8()
  external int second_chroma_qp_index_offset;

  @__u16()
  external int flags;
}

typedef __s8 = ffi.SignedChar;
typedef Dart__s8 = int;

final class v4l2_ctrl_h264_scaling_matrix extends ffi.Struct {
  @ffi.Array.multi([6, 16])
  external ffi.Array<ffi.Array<__u8>> scaling_list_4x4;

  @ffi.Array.multi([6, 64])
  external ffi.Array<ffi.Array<__u8>> scaling_list_8x8;
}

final class v4l2_ctrl_h264_pred_weights extends ffi.Struct {
  @__u16()
  external int luma_log2_weight_denom;

  @__u16()
  external int chroma_log2_weight_denom;

  @ffi.Array.multi([2])
  external ffi.Array<v4l2_h264_weight_factors> weight_factors;
}

final class v4l2_h264_weight_factors extends ffi.Struct {
  @ffi.Array.multi([32])
  external ffi.Array<__s16> luma_weight;

  @ffi.Array.multi([32])
  external ffi.Array<__s16> luma_offset;

  @ffi.Array.multi([32, 2])
  external ffi.Array<ffi.Array<__s16>> chroma_weight;

  @ffi.Array.multi([32, 2])
  external ffi.Array<ffi.Array<__s16>> chroma_offset;
}

typedef __s16 = ffi.Short;
typedef Dart__s16 = int;

final class v4l2_ctrl_h264_slice_params extends ffi.Struct {
  @__u32()
  external int header_bit_size;

  @__u32()
  external int first_mb_in_slice;

  @__u8()
  external int slice_type;

  @__u8()
  external int colour_plane_id;

  @__u8()
  external int redundant_pic_cnt;

  @__u8()
  external int cabac_init_idc;

  @__s8()
  external int slice_qp_delta;

  @__s8()
  external int slice_qs_delta;

  @__u8()
  external int disable_deblocking_filter_idc;

  @__s8()
  external int slice_alpha_c0_offset_div2;

  @__s8()
  external int slice_beta_offset_div2;

  @__u8()
  external int num_ref_idx_l0_active_minus1;

  @__u8()
  external int num_ref_idx_l1_active_minus1;

  @__u8()
  external int reserved;

  @ffi.Array.multi([32])
  external ffi.Array<v4l2_h264_reference> ref_pic_list0;

  @ffi.Array.multi([32])
  external ffi.Array<v4l2_h264_reference> ref_pic_list1;

  @__u32()
  external int flags;
}

final class v4l2_h264_reference extends ffi.Struct {
  @__u8()
  external int fields;

  @__u8()
  external int index;
}

final class v4l2_ctrl_h264_decode_params extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<v4l2_h264_dpb_entry> dpb;

  @__u16()
  external int nal_ref_idc;

  @__u16()
  external int frame_num;

  @__s32()
  external int top_field_order_cnt;

  @__s32()
  external int bottom_field_order_cnt;

  @__u16()
  external int idr_pic_id;

  @__u16()
  external int pic_order_cnt_lsb;

  @__s32()
  external int delta_pic_order_cnt_bottom;

  @__s32()
  external int delta_pic_order_cnt0;

  @__s32()
  external int delta_pic_order_cnt1;

  @__u32()
  external int dec_ref_pic_marking_bit_size;

  @__u32()
  external int pic_order_cnt_bit_size;

  @__u32()
  external int slice_group_change_cycle;

  @__u32()
  external int reserved;

  @__u32()
  external int flags;
}

final class v4l2_h264_dpb_entry extends ffi.Struct {
  @__u64()
  external int reference_ts;

  @__u32()
  external int pic_num;

  @__u16()
  external int frame_num;

  @__u8()
  external int fields;

  @ffi.Array.multi([5])
  external ffi.Array<__u8> reserved;

  @__s32()
  external int top_field_order_cnt;

  @__s32()
  external int bottom_field_order_cnt;

  @__u32()
  external int flags;
}

final class v4l2_ctrl_fwht_params extends ffi.Struct {
  @__u64()
  external int backward_ref_ts;

  @__u32()
  external int version;

  @__u32()
  external int width;

  @__u32()
  external int height;

  @__u32()
  external int flags;

  @__u32()
  external int colorspace;

  @__u32()
  external int xfer_func;

  @__u32()
  external int ycbcr_enc;

  @__u32()
  external int quantization;
}

final class v4l2_ctrl_vp8_frame extends ffi.Struct {
  external v4l2_vp8_segment segment;

  external v4l2_vp8_loop_filter lf;

  external v4l2_vp8_quantization quant;

  external v4l2_vp8_entropy entropy;

  external v4l2_vp8_entropy_coder_state coder_state;

  @__u16()
  external int width;

  @__u16()
  external int height;

  @__u8()
  external int horizontal_scale;

  @__u8()
  external int vertical_scale;

  @__u8()
  external int version;

  @__u8()
  external int prob_skip_false;

  @__u8()
  external int prob_intra;

  @__u8()
  external int prob_last;

  @__u8()
  external int prob_gf;

  @__u8()
  external int num_dct_parts;

  @__u32()
  external int first_part_size;

  @__u32()
  external int first_part_header_bits;

  @ffi.Array.multi([8])
  external ffi.Array<__u32> dct_part_sizes;

  @__u64()
  external int last_frame_ts;

  @__u64()
  external int golden_frame_ts;

  @__u64()
  external int alt_frame_ts;

  @__u64()
  external int flags;
}

final class v4l2_vp8_segment extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__s8> quant_update;

  @ffi.Array.multi([4])
  external ffi.Array<__s8> lf_update;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> segment_probs;

  @__u8()
  external int padding;

  @__u32()
  external int flags;
}

final class v4l2_vp8_loop_filter extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__s8> ref_frm_delta;

  @ffi.Array.multi([4])
  external ffi.Array<__s8> mb_mode_delta;

  @__u8()
  external int sharpness_level;

  @__u8()
  external int level;

  @__u16()
  external int padding;

  @__u32()
  external int flags;
}

final class v4l2_vp8_quantization extends ffi.Struct {
  @__u8()
  external int y_ac_qi;

  @__s8()
  external int y_dc_delta;

  @__s8()
  external int y2_dc_delta;

  @__s8()
  external int y2_ac_delta;

  @__s8()
  external int uv_dc_delta;

  @__s8()
  external int uv_ac_delta;

  @__u16()
  external int padding;
}

final class v4l2_vp8_entropy extends ffi.Struct {
  @ffi.Array.multi([4, 8, 3, 11])
  external ffi.Array<ffi.Array<ffi.Array<ffi.Array<__u8>>>> coeff_probs;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> y_mode_probs;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> uv_mode_probs;

  @ffi.Array.multi([2, 19])
  external ffi.Array<ffi.Array<__u8>> mv_probs;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> padding;
}

final class v4l2_vp8_entropy_coder_state extends ffi.Struct {
  @__u8()
  external int range;

  @__u8()
  external int value;

  @__u8()
  external int bit_count;

  @__u8()
  external int padding;
}

final class v4l2_ctrl_mpeg2_sequence extends ffi.Struct {
  @__u16()
  external int horizontal_size;

  @__u16()
  external int vertical_size;

  @__u32()
  external int vbv_buffer_size;

  @__u16()
  external int profile_and_level_indication;

  @__u8()
  external int chroma_format;

  @__u8()
  external int flags;
}

final class v4l2_ctrl_mpeg2_picture extends ffi.Struct {
  @__u64()
  external int backward_ref_ts;

  @__u64()
  external int forward_ref_ts;

  @__u32()
  external int flags;

  @ffi.Array.multi([2, 2])
  external ffi.Array<ffi.Array<__u8>> f_code;

  @__u8()
  external int picture_coding_type;

  @__u8()
  external int picture_structure;

  @__u8()
  external int intra_dc_precision;

  @ffi.Array.multi([5])
  external ffi.Array<__u8> reserved;
}

final class v4l2_ctrl_mpeg2_quantisation extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__u8> intra_quantiser_matrix;

  @ffi.Array.multi([64])
  external ffi.Array<__u8> non_intra_quantiser_matrix;

  @ffi.Array.multi([64])
  external ffi.Array<__u8> chroma_intra_quantiser_matrix;

  @ffi.Array.multi([64])
  external ffi.Array<__u8> chroma_non_intra_quantiser_matrix;
}

final class v4l2_ctrl_vp9_compressed_hdr extends ffi.Struct {
  @__u8()
  external int tx_mode;

  @ffi.Array.multi([2, 1])
  external ffi.Array<ffi.Array<__u8>> tx8;

  @ffi.Array.multi([2, 2])
  external ffi.Array<ffi.Array<__u8>> tx16;

  @ffi.Array.multi([2, 3])
  external ffi.Array<ffi.Array<__u8>> tx32;

  @ffi.Array.multi([4, 2, 2, 6, 6, 3])
  external ffi
      .Array<ffi.Array<ffi.Array<ffi.Array<ffi.Array<ffi.Array<__u8>>>>>> coef;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> skip;

  @ffi.Array.multi([7, 3])
  external ffi.Array<ffi.Array<__u8>> inter_mode;

  @ffi.Array.multi([4, 2])
  external ffi.Array<ffi.Array<__u8>> interp_filter;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> is_inter;

  @ffi.Array.multi([5])
  external ffi.Array<__u8> comp_mode;

  @ffi.Array.multi([5, 2])
  external ffi.Array<ffi.Array<__u8>> single_ref;

  @ffi.Array.multi([5])
  external ffi.Array<__u8> comp_ref;

  @ffi.Array.multi([4, 9])
  external ffi.Array<ffi.Array<__u8>> y_mode;

  @ffi.Array.multi([10, 9])
  external ffi.Array<ffi.Array<__u8>> uv_mode;

  @ffi.Array.multi([16, 3])
  external ffi.Array<ffi.Array<__u8>> partition;

  external v4l2_vp9_mv_probs mv;
}

final class v4l2_vp9_mv_probs extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<__u8> joint;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> sign;

  @ffi.Array.multi([2, 10])
  external ffi.Array<ffi.Array<__u8>> classes;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> class0_bit;

  @ffi.Array.multi([2, 10])
  external ffi.Array<ffi.Array<__u8>> bits;

  @ffi.Array.multi([2, 2, 3])
  external ffi.Array<ffi.Array<ffi.Array<__u8>>> class0_fr;

  @ffi.Array.multi([2, 3])
  external ffi.Array<ffi.Array<__u8>> fr;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> class0_hp;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> hp;
}

final class v4l2_ctrl_vp9_frame extends ffi.Struct {
  external v4l2_vp9_loop_filter lf;

  external v4l2_vp9_quantization quant;

  external v4l2_vp9_segmentation seg;

  @__u32()
  external int flags;

  @__u16()
  external int compressed_header_size;

  @__u16()
  external int uncompressed_header_size;

  @__u16()
  external int frame_width_minus_1;

  @__u16()
  external int frame_height_minus_1;

  @__u16()
  external int render_width_minus_1;

  @__u16()
  external int render_height_minus_1;

  @__u64()
  external int last_frame_ts;

  @__u64()
  external int golden_frame_ts;

  @__u64()
  external int alt_frame_ts;

  @__u8()
  external int ref_frame_sign_bias;

  @__u8()
  external int reset_frame_context;

  @__u8()
  external int frame_context_idx;

  @__u8()
  external int profile;

  @__u8()
  external int bit_depth;

  @__u8()
  external int interpolation_filter;

  @__u8()
  external int tile_cols_log2;

  @__u8()
  external int tile_rows_log2;

  @__u8()
  external int reference_mode;

  @ffi.Array.multi([7])
  external ffi.Array<__u8> reserved;
}

final class v4l2_vp9_loop_filter extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__s8> ref_deltas;

  @ffi.Array.multi([2])
  external ffi.Array<__s8> mode_deltas;

  @__u8()
  external int level;

  @__u8()
  external int sharpness;

  @__u8()
  external int flags;

  @ffi.Array.multi([7])
  external ffi.Array<__u8> reserved;
}

final class v4l2_vp9_quantization extends ffi.Struct {
  @__u8()
  external int base_q_idx;

  @__s8()
  external int delta_q_y_dc;

  @__s8()
  external int delta_q_uv_dc;

  @__s8()
  external int delta_q_uv_ac;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> reserved;
}

final class v4l2_vp9_segmentation extends ffi.Struct {
  @ffi.Array.multi([8, 4])
  external ffi.Array<ffi.Array<__s16>> feature_data;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> feature_enabled;

  @ffi.Array.multi([7])
  external ffi.Array<__u8> tree_probs;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> pred_probs;

  @__u8()
  external int flags;

  @ffi.Array.multi([5])
  external ffi.Array<__u8> reserved;
}

final class v4l2_ctrl_hevc_sps extends ffi.Struct {
  @__u8()
  external int video_parameter_set_id;

  @__u8()
  external int seq_parameter_set_id;

  @__u16()
  external int pic_width_in_luma_samples;

  @__u16()
  external int pic_height_in_luma_samples;

  @__u8()
  external int bit_depth_luma_minus8;

  @__u8()
  external int bit_depth_chroma_minus8;

  @__u8()
  external int log2_max_pic_order_cnt_lsb_minus4;

  @__u8()
  external int sps_max_dec_pic_buffering_minus1;

  @__u8()
  external int sps_max_num_reorder_pics;

  @__u8()
  external int sps_max_latency_increase_plus1;

  @__u8()
  external int log2_min_luma_coding_block_size_minus3;

  @__u8()
  external int log2_diff_max_min_luma_coding_block_size;

  @__u8()
  external int log2_min_luma_transform_block_size_minus2;

  @__u8()
  external int log2_diff_max_min_luma_transform_block_size;

  @__u8()
  external int max_transform_hierarchy_depth_inter;

  @__u8()
  external int max_transform_hierarchy_depth_intra;

  @__u8()
  external int pcm_sample_bit_depth_luma_minus1;

  @__u8()
  external int pcm_sample_bit_depth_chroma_minus1;

  @__u8()
  external int log2_min_pcm_luma_coding_block_size_minus3;

  @__u8()
  external int log2_diff_max_min_pcm_luma_coding_block_size;

  @__u8()
  external int num_short_term_ref_pic_sets;

  @__u8()
  external int num_long_term_ref_pics_sps;

  @__u8()
  external int chroma_format_idc;

  @__u8()
  external int sps_max_sub_layers_minus1;

  @ffi.Array.multi([6])
  external ffi.Array<__u8> reserved;

  @__u64()
  external int flags;
}

final class v4l2_ctrl_hevc_pps extends ffi.Struct {
  @__u8()
  external int pic_parameter_set_id;

  @__u8()
  external int num_extra_slice_header_bits;

  @__u8()
  external int num_ref_idx_l0_default_active_minus1;

  @__u8()
  external int num_ref_idx_l1_default_active_minus1;

  @__s8()
  external int init_qp_minus26;

  @__u8()
  external int diff_cu_qp_delta_depth;

  @__s8()
  external int pps_cb_qp_offset;

  @__s8()
  external int pps_cr_qp_offset;

  @__u8()
  external int num_tile_columns_minus1;

  @__u8()
  external int num_tile_rows_minus1;

  @ffi.Array.multi([20])
  external ffi.Array<__u8> column_width_minus1;

  @ffi.Array.multi([22])
  external ffi.Array<__u8> row_height_minus1;

  @__s8()
  external int pps_beta_offset_div2;

  @__s8()
  external int pps_tc_offset_div2;

  @__u8()
  external int log2_parallel_merge_level_minus2;

  @__u8()
  external int reserved;

  @__u64()
  external int flags;
}

final class v4l2_ctrl_hevc_slice_params extends ffi.Struct {
  @__u32()
  external int bit_size;

  @__u32()
  external int data_byte_offset;

  @__u32()
  external int num_entry_point_offsets;

  @__u8()
  external int nal_unit_type;

  @__u8()
  external int nuh_temporal_id_plus1;

  @__u8()
  external int slice_type;

  @__u8()
  external int colour_plane_id;

  @__s32()
  external int slice_pic_order_cnt;

  @__u8()
  external int num_ref_idx_l0_active_minus1;

  @__u8()
  external int num_ref_idx_l1_active_minus1;

  @__u8()
  external int collocated_ref_idx;

  @__u8()
  external int five_minus_max_num_merge_cand;

  @__s8()
  external int slice_qp_delta;

  @__s8()
  external int slice_cb_qp_offset;

  @__s8()
  external int slice_cr_qp_offset;

  @__s8()
  external int slice_act_y_qp_offset;

  @__s8()
  external int slice_act_cb_qp_offset;

  @__s8()
  external int slice_act_cr_qp_offset;

  @__s8()
  external int slice_beta_offset_div2;

  @__s8()
  external int slice_tc_offset_div2;

  @__u8()
  external int pic_struct;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> reserved0;

  @__u32()
  external int slice_segment_addr;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> ref_idx_l0;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> ref_idx_l1;

  @__u16()
  external int short_term_ref_pic_set_size;

  @__u16()
  external int long_term_ref_pic_set_size;

  external v4l2_hevc_pred_weight_table pred_weight_table;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> reserved1;

  @__u64()
  external int flags;
}

final class v4l2_hevc_pred_weight_table extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__s8> delta_luma_weight_l0;

  @ffi.Array.multi([16])
  external ffi.Array<__s8> luma_offset_l0;

  @ffi.Array.multi([16, 2])
  external ffi.Array<ffi.Array<__s8>> delta_chroma_weight_l0;

  @ffi.Array.multi([16, 2])
  external ffi.Array<ffi.Array<__s8>> chroma_offset_l0;

  @ffi.Array.multi([16])
  external ffi.Array<__s8> delta_luma_weight_l1;

  @ffi.Array.multi([16])
  external ffi.Array<__s8> luma_offset_l1;

  @ffi.Array.multi([16, 2])
  external ffi.Array<ffi.Array<__s8>> delta_chroma_weight_l1;

  @ffi.Array.multi([16, 2])
  external ffi.Array<ffi.Array<__s8>> chroma_offset_l1;

  @__u8()
  external int luma_log2_weight_denom;

  @__s8()
  external int delta_chroma_log2_weight_denom;
}

final class v4l2_ctrl_hevc_scaling_matrix extends ffi.Struct {
  @ffi.Array.multi([6, 16])
  external ffi.Array<ffi.Array<__u8>> scaling_list_4x4;

  @ffi.Array.multi([6, 64])
  external ffi.Array<ffi.Array<__u8>> scaling_list_8x8;

  @ffi.Array.multi([6, 64])
  external ffi.Array<ffi.Array<__u8>> scaling_list_16x16;

  @ffi.Array.multi([2, 64])
  external ffi.Array<ffi.Array<__u8>> scaling_list_32x32;

  @ffi.Array.multi([6])
  external ffi.Array<__u8> scaling_list_dc_coef_16x16;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> scaling_list_dc_coef_32x32;
}

final class v4l2_ctrl_hevc_decode_params extends ffi.Struct {
  @__s32()
  external int pic_order_cnt_val;

  @__u16()
  external int short_term_ref_pic_set_size;

  @__u16()
  external int long_term_ref_pic_set_size;

  @__u8()
  external int num_active_dpb_entries;

  @__u8()
  external int num_poc_st_curr_before;

  @__u8()
  external int num_poc_st_curr_after;

  @__u8()
  external int num_poc_lt_curr;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> poc_st_curr_before;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> poc_st_curr_after;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> poc_lt_curr;

  @__u8()
  external int num_delta_pocs_of_ref_rps_idx;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> reserved;

  @ffi.Array.multi([16])
  external ffi.Array<v4l2_hevc_dpb_entry> dpb;

  @__u64()
  external int flags;
}

final class v4l2_hevc_dpb_entry extends ffi.Struct {
  @__u64()
  external int timestamp;

  @__u8()
  external int flags;

  @__u8()
  external int field_pic;

  @__u16()
  external int reserved;

  @__s32()
  external int pic_order_cnt_val;
}

final class v4l2_ctrl_av1_sequence extends ffi.Struct {
  @__u32()
  external int flags;

  @__u8()
  external int seq_profile;

  @__u8()
  external int order_hint_bits;

  @__u8()
  external int bit_depth;

  @__u8()
  external int reserved;

  @__u16()
  external int max_frame_width_minus_1;

  @__u16()
  external int max_frame_height_minus_1;
}

final class v4l2_ctrl_av1_tile_group_entry extends ffi.Struct {
  @__u32()
  external int tile_offset;

  @__u32()
  external int tile_size;

  @__u32()
  external int tile_row;

  @__u32()
  external int tile_col;
}

final class v4l2_ctrl_av1_frame extends ffi.Struct {
  external v4l2_av1_tile_info tile_info;

  external v4l2_av1_quantization quantization;

  @__u8()
  external int superres_denom;

  external v4l2_av1_segmentation segmentation;

  external v4l2_av1_loop_filter loop_filter;

  external v4l2_av1_cdef cdef;

  @ffi.Array.multi([2])
  external ffi.Array<__u8> skip_mode_frame;

  @__u8()
  external int primary_ref_frame;

  external v4l2_av1_loop_restoration loop_restoration;

  external v4l2_av1_global_motion global_motion;

  @__u32()
  external int flags;

  @ffi.UnsignedInt()
  external int frame_typeAsInt;

  v4l2_av1_frame_type get frame_type =>
      v4l2_av1_frame_type.fromValue(frame_typeAsInt);

  @__u32()
  external int order_hint;

  @__u32()
  external int upscaled_width;

  @ffi.UnsignedInt()
  external int interpolation_filterAsInt;

  v4l2_av1_interpolation_filter get interpolation_filter =>
      v4l2_av1_interpolation_filter.fromValue(interpolation_filterAsInt);

  @ffi.UnsignedInt()
  external int tx_modeAsInt;

  v4l2_av1_tx_mode get tx_mode => v4l2_av1_tx_mode.fromValue(tx_modeAsInt);

  @__u32()
  external int frame_width_minus_1;

  @__u32()
  external int frame_height_minus_1;

  @__u16()
  external int render_width_minus_1;

  @__u16()
  external int render_height_minus_1;

  @__u32()
  external int current_frame_id;

  @ffi.Array.multi([32])
  external ffi.Array<__u32> buffer_removal_time;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> reserved;

  @ffi.Array.multi([8])
  external ffi.Array<__u32> order_hints;

  @ffi.Array.multi([8])
  external ffi.Array<__u64> reference_frame_ts;

  @ffi.Array.multi([7])
  external ffi.Array<__s8> ref_frame_idx;

  @__u8()
  external int refresh_frame_flags;
}

final class v4l2_av1_tile_info extends ffi.Struct {
  @__u8()
  external int flags;

  @__u8()
  external int context_update_tile_id;

  @__u8()
  external int tile_cols;

  @__u8()
  external int tile_rows;

  @ffi.Array.multi([65])
  external ffi.Array<__u32> mi_col_starts;

  @ffi.Array.multi([65])
  external ffi.Array<__u32> mi_row_starts;

  @ffi.Array.multi([64])
  external ffi.Array<__u32> width_in_sbs_minus_1;

  @ffi.Array.multi([64])
  external ffi.Array<__u32> height_in_sbs_minus_1;

  @__u8()
  external int tile_size_bytes;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> reserved;
}

final class v4l2_av1_quantization extends ffi.Struct {
  @__u8()
  external int flags;

  @__u8()
  external int base_q_idx;

  @__s8()
  external int delta_q_y_dc;

  @__s8()
  external int delta_q_u_dc;

  @__s8()
  external int delta_q_u_ac;

  @__s8()
  external int delta_q_v_dc;

  @__s8()
  external int delta_q_v_ac;

  @__u8()
  external int qm_y;

  @__u8()
  external int qm_u;

  @__u8()
  external int qm_v;

  @__u8()
  external int delta_q_res;
}

final class v4l2_av1_segmentation extends ffi.Struct {
  @__u8()
  external int flags;

  @__u8()
  external int last_active_seg_id;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> feature_enabled;

  @ffi.Array.multi([8, 8])
  external ffi.Array<ffi.Array<__s16>> feature_data;
}

final class v4l2_av1_loop_filter extends ffi.Struct {
  @__u8()
  external int flags;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> level;

  @__u8()
  external int sharpness;

  @ffi.Array.multi([8])
  external ffi.Array<__s8> ref_deltas;

  @ffi.Array.multi([2])
  external ffi.Array<__s8> mode_deltas;

  @__u8()
  external int delta_lf_res;
}

final class v4l2_av1_cdef extends ffi.Struct {
  @__u8()
  external int damping_minus_3;

  @__u8()
  external int bits;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> y_pri_strength;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> y_sec_strength;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> uv_pri_strength;

  @ffi.Array.multi([8])
  external ffi.Array<__u8> uv_sec_strength;
}

final class v4l2_av1_loop_restoration extends ffi.Struct {
  @__u8()
  external int flags;

  @__u8()
  external int lr_unit_shift;

  @__u8()
  external int lr_uv_shift;

  @__u8()
  external int reserved;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedInt> frame_restoration_type;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> loop_restoration_size;
}

enum v4l2_av1_frame_restoration_type {
  V4L2_AV1_FRAME_RESTORE_NONE(0),
  V4L2_AV1_FRAME_RESTORE_WIENER(1),
  V4L2_AV1_FRAME_RESTORE_SGRPROJ(2),
  V4L2_AV1_FRAME_RESTORE_SWITCHABLE(3);

  final int value;
  const v4l2_av1_frame_restoration_type(this.value);

  static v4l2_av1_frame_restoration_type fromValue(int value) =>
      switch (value) {
        0 => V4L2_AV1_FRAME_RESTORE_NONE,
        1 => V4L2_AV1_FRAME_RESTORE_WIENER,
        2 => V4L2_AV1_FRAME_RESTORE_SGRPROJ,
        3 => V4L2_AV1_FRAME_RESTORE_SWITCHABLE,
        _ => throw ArgumentError(
            "Unknown value for v4l2_av1_frame_restoration_type: $value"),
      };
}

final class v4l2_av1_global_motion extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<__u8> flags;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedInt> type;

  @ffi.Array.multi([8, 6])
  external ffi.Array<ffi.Array<__s32>> params;

  @__u8()
  external int invalid;

  @ffi.Array.multi([3])
  external ffi.Array<__u8> reserved;
}

enum v4l2_av1_warp_model {
  V4L2_AV1_WARP_MODEL_IDENTITY(0),
  V4L2_AV1_WARP_MODEL_TRANSLATION(1),
  V4L2_AV1_WARP_MODEL_ROTZOOM(2),
  V4L2_AV1_WARP_MODEL_AFFINE(3);

  final int value;
  const v4l2_av1_warp_model(this.value);

  static v4l2_av1_warp_model fromValue(int value) => switch (value) {
        0 => V4L2_AV1_WARP_MODEL_IDENTITY,
        1 => V4L2_AV1_WARP_MODEL_TRANSLATION,
        2 => V4L2_AV1_WARP_MODEL_ROTZOOM,
        3 => V4L2_AV1_WARP_MODEL_AFFINE,
        _ =>
          throw ArgumentError("Unknown value for v4l2_av1_warp_model: $value"),
      };
}

enum v4l2_av1_frame_type {
  V4L2_AV1_KEY_FRAME(0),
  V4L2_AV1_INTER_FRAME(1),
  V4L2_AV1_INTRA_ONLY_FRAME(2),
  V4L2_AV1_SWITCH_FRAME(3);

  final int value;
  const v4l2_av1_frame_type(this.value);

  static v4l2_av1_frame_type fromValue(int value) => switch (value) {
        0 => V4L2_AV1_KEY_FRAME,
        1 => V4L2_AV1_INTER_FRAME,
        2 => V4L2_AV1_INTRA_ONLY_FRAME,
        3 => V4L2_AV1_SWITCH_FRAME,
        _ =>
          throw ArgumentError("Unknown value for v4l2_av1_frame_type: $value"),
      };
}

enum v4l2_av1_interpolation_filter {
  V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP(0),
  V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH(1),
  V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP(2),
  V4L2_AV1_INTERPOLATION_FILTER_BILINEAR(3),
  V4L2_AV1_INTERPOLATION_FILTER_SWITCHABLE(4);

  final int value;
  const v4l2_av1_interpolation_filter(this.value);

  static v4l2_av1_interpolation_filter fromValue(int value) => switch (value) {
        0 => V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP,
        1 => V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH,
        2 => V4L2_AV1_INTERPOLATION_FILTER_EIGHTTAP_SHARP,
        3 => V4L2_AV1_INTERPOLATION_FILTER_BILINEAR,
        4 => V4L2_AV1_INTERPOLATION_FILTER_SWITCHABLE,
        _ => throw ArgumentError(
            "Unknown value for v4l2_av1_interpolation_filter: $value"),
      };
}

enum v4l2_av1_tx_mode {
  V4L2_AV1_TX_MODE_ONLY_4X4(0),
  V4L2_AV1_TX_MODE_LARGEST(1),
  V4L2_AV1_TX_MODE_SELECT(2);

  final int value;
  const v4l2_av1_tx_mode(this.value);

  static v4l2_av1_tx_mode fromValue(int value) => switch (value) {
        0 => V4L2_AV1_TX_MODE_ONLY_4X4,
        1 => V4L2_AV1_TX_MODE_LARGEST,
        2 => V4L2_AV1_TX_MODE_SELECT,
        _ => throw ArgumentError("Unknown value for v4l2_av1_tx_mode: $value"),
      };
}

final class v4l2_ctrl_av1_film_grain extends ffi.Struct {
  @__u8()
  external int flags;

  @__u8()
  external int cr_mult;

  @__u16()
  external int grain_seed;

  @__u8()
  external int film_grain_params_ref_idx;

  @__u8()
  external int num_y_points;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_y_value;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_y_scaling;

  @__u8()
  external int num_cb_points;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_cb_value;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_cb_scaling;

  @__u8()
  external int num_cr_points;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_cr_value;

  @ffi.Array.multi([16])
  external ffi.Array<__u8> point_cr_scaling;

  @__u8()
  external int grain_scaling_minus_8;

  @__u8()
  external int ar_coeff_lag;

  @ffi.Array.multi([25])
  external ffi.Array<__u8> ar_coeffs_y_plus_128;

  @ffi.Array.multi([25])
  external ffi.Array<__u8> ar_coeffs_cb_plus_128;

  @ffi.Array.multi([25])
  external ffi.Array<__u8> ar_coeffs_cr_plus_128;

  @__u8()
  external int ar_coeff_shift_minus_6;

  @__u8()
  external int grain_scale_shift;

  @__u8()
  external int cb_mult;

  @__u8()
  external int cb_luma_mult;

  @__u8()
  external int cr_luma_mult;

  @__u16()
  external int cb_offset;

  @__u16()
  external int cr_offset;

  @ffi.Array.multi([4])
  external ffi.Array<__u8> reserved;
}

final class v4l2_ctrl_hdr10_cll_info extends ffi.Struct {
  @__u16()
  external int max_content_light_level;

  @__u16()
  external int max_pic_average_light_level;
}

final class v4l2_ctrl_hdr10_mastering_display extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<__u16> display_primaries_x;

  @ffi.Array.multi([3])
  external ffi.Array<__u16> display_primaries_y;

  @__u16()
  external int white_point_x;

  @__u16()
  external int white_point_y;

  @__u32()
  external int max_display_mastering_luminance;

  @__u32()
  external int min_display_mastering_luminance;
}

final class v4l2_ext_controls extends ffi.Struct {
  external UnnamedUnion10 unnamed;

  @__u32()
  external int count;

  @__u32()
  external int error_idx;

  @__s32()
  external int request_fd;

  @ffi.Array.multi([1])
  external ffi.Array<__u32> reserved;

  external ffi.Pointer<v4l2_ext_control> controls;
}

final class UnnamedUnion10 extends ffi.Union {
  @__u32()
  external int ctrl_class;

  @__u32()
  external int which;
}

enum v4l2_ctrl_type {
  V4L2_CTRL_TYPE_INTEGER(1),
  V4L2_CTRL_TYPE_BOOLEAN(2),
  V4L2_CTRL_TYPE_MENU(3),
  V4L2_CTRL_TYPE_BUTTON(4),
  V4L2_CTRL_TYPE_INTEGER64(5),
  V4L2_CTRL_TYPE_CTRL_CLASS(6),
  V4L2_CTRL_TYPE_STRING(7),
  V4L2_CTRL_TYPE_BITMASK(8),
  V4L2_CTRL_TYPE_INTEGER_MENU(9),

  /// Compound types are >= 0x0100
  V4L2_CTRL_COMPOUND_TYPES(256),
  V4L2_CTRL_TYPE_U16(257),
  V4L2_CTRL_TYPE_U32(258),
  V4L2_CTRL_TYPE_AREA(262),
  V4L2_CTRL_TYPE_HDR10_CLL_INFO(272),
  V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY(273),
  V4L2_CTRL_TYPE_H264_SPS(512),
  V4L2_CTRL_TYPE_H264_PPS(513),
  V4L2_CTRL_TYPE_H264_SCALING_MATRIX(514),
  V4L2_CTRL_TYPE_H264_SLICE_PARAMS(515),
  V4L2_CTRL_TYPE_H264_DECODE_PARAMS(516),
  V4L2_CTRL_TYPE_H264_PRED_WEIGHTS(517),
  V4L2_CTRL_TYPE_FWHT_PARAMS(544),
  V4L2_CTRL_TYPE_VP8_FRAME(576),
  V4L2_CTRL_TYPE_MPEG2_QUANTISATION(592),
  V4L2_CTRL_TYPE_MPEG2_SEQUENCE(593),
  V4L2_CTRL_TYPE_MPEG2_PICTURE(594),
  V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR(608),
  V4L2_CTRL_TYPE_VP9_FRAME(609),
  V4L2_CTRL_TYPE_HEVC_SPS(624),
  V4L2_CTRL_TYPE_HEVC_PPS(625),
  V4L2_CTRL_TYPE_HEVC_SLICE_PARAMS(626),
  V4L2_CTRL_TYPE_HEVC_SCALING_MATRIX(627),
  V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS(628),
  V4L2_CTRL_TYPE_AV1_SEQUENCE(640),
  V4L2_CTRL_TYPE_AV1_TILE_GROUP_ENTRY(641),
  V4L2_CTRL_TYPE_AV1_FRAME(642),
  V4L2_CTRL_TYPE_AV1_FILM_GRAIN(643);

  static const V4L2_CTRL_TYPE_U8 = V4L2_CTRL_COMPOUND_TYPES;

  final int value;
  const v4l2_ctrl_type(this.value);

  static v4l2_ctrl_type fromValue(int value) => switch (value) {
        1 => V4L2_CTRL_TYPE_INTEGER,
        2 => V4L2_CTRL_TYPE_BOOLEAN,
        3 => V4L2_CTRL_TYPE_MENU,
        4 => V4L2_CTRL_TYPE_BUTTON,
        5 => V4L2_CTRL_TYPE_INTEGER64,
        6 => V4L2_CTRL_TYPE_CTRL_CLASS,
        7 => V4L2_CTRL_TYPE_STRING,
        8 => V4L2_CTRL_TYPE_BITMASK,
        9 => V4L2_CTRL_TYPE_INTEGER_MENU,
        256 => V4L2_CTRL_COMPOUND_TYPES,
        257 => V4L2_CTRL_TYPE_U16,
        258 => V4L2_CTRL_TYPE_U32,
        262 => V4L2_CTRL_TYPE_AREA,
        272 => V4L2_CTRL_TYPE_HDR10_CLL_INFO,
        273 => V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY,
        512 => V4L2_CTRL_TYPE_H264_SPS,
        513 => V4L2_CTRL_TYPE_H264_PPS,
        514 => V4L2_CTRL_TYPE_H264_SCALING_MATRIX,
        515 => V4L2_CTRL_TYPE_H264_SLICE_PARAMS,
        516 => V4L2_CTRL_TYPE_H264_DECODE_PARAMS,
        517 => V4L2_CTRL_TYPE_H264_PRED_WEIGHTS,
        544 => V4L2_CTRL_TYPE_FWHT_PARAMS,
        576 => V4L2_CTRL_TYPE_VP8_FRAME,
        592 => V4L2_CTRL_TYPE_MPEG2_QUANTISATION,
        593 => V4L2_CTRL_TYPE_MPEG2_SEQUENCE,
        594 => V4L2_CTRL_TYPE_MPEG2_PICTURE,
        608 => V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR,
        609 => V4L2_CTRL_TYPE_VP9_FRAME,
        624 => V4L2_CTRL_TYPE_HEVC_SPS,
        625 => V4L2_CTRL_TYPE_HEVC_PPS,
        626 => V4L2_CTRL_TYPE_HEVC_SLICE_PARAMS,
        627 => V4L2_CTRL_TYPE_HEVC_SCALING_MATRIX,
        628 => V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS,
        640 => V4L2_CTRL_TYPE_AV1_SEQUENCE,
        641 => V4L2_CTRL_TYPE_AV1_TILE_GROUP_ENTRY,
        642 => V4L2_CTRL_TYPE_AV1_FRAME,
        643 => V4L2_CTRL_TYPE_AV1_FILM_GRAIN,
        _ => throw ArgumentError("Unknown value for v4l2_ctrl_type: $value"),
      };

  @override
  String toString() {
    if (this == V4L2_CTRL_COMPOUND_TYPES)
      return "v4l2_ctrl_type.V4L2_CTRL_COMPOUND_TYPES, v4l2_ctrl_type.V4L2_CTRL_TYPE_U8";
    return super.toString();
  }
}

/// Used in the VIDIOC_QUERYCTRL ioctl for querying controls
final class v4l2_queryctrl extends ffi.Struct {
  @__u32()
  external int id;

  /// enum v4l2_ctrl_type
  @__u32()
  external int type;

  /// Whatever
  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  /// Note signedness
  @__s32()
  external int minimum;

  @__s32()
  external int maximum;

  @__s32()
  external int step;

  @__s32()
  external int default_value;

  @__u32()
  external int flags;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

/// Used in the VIDIOC_QUERY_EXT_CTRL ioctl for querying extended controls
final class v4l2_query_ext_ctrl extends ffi.Struct {
  @__u32()
  external int id;

  @__u32()
  external int type;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;

  @__s64()
  external int minimum;

  @__s64()
  external int maximum;

  @__u64()
  external int step;

  @__s64()
  external int default_value;

  @__u32()
  external int flags;

  @__u32()
  external int elem_size;

  @__u32()
  external int elems;

  @__u32()
  external int nr_of_dims;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> dims;

  @ffi.Array.multi([32])
  external ffi.Array<__u32> reserved;
}

/// Used in the VIDIOC_QUERYMENU ioctl for querying menu items
@ffi.Packed(1)
final class v4l2_querymenu extends ffi.Struct {
  @__u32()
  external int id;

  @__u32()
  external int index;

  external UnnamedUnion11 unnamed;

  @__u32()
  external int reserved;
}

final class UnnamedUnion11 extends ffi.Union {
  /// Whatever
  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  @__s64()
  external int value;
}

/// T U N I N G
final class v4l2_tuner extends ffi.Struct {
  @__u32()
  external int index;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  /// enum v4l2_tuner_type
  @__u32()
  external int type;

  @__u32()
  external int capability;

  @__u32()
  external int rangelow;

  @__u32()
  external int rangehigh;

  @__u32()
  external int rxsubchans;

  @__u32()
  external int audmode;

  @__s32()
  external int signal;

  @__s32()
  external int afc;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> reserved;
}

final class v4l2_modulator extends ffi.Struct {
  @__u32()
  external int index;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  @__u32()
  external int capability;

  @__u32()
  external int rangelow;

  @__u32()
  external int rangehigh;

  @__u32()
  external int txsubchans;

  /// enum v4l2_tuner_type
  @__u32()
  external int type;

  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

final class v4l2_frequency extends ffi.Struct {
  @__u32()
  external int tuner;

  /// enum v4l2_tuner_type
  @__u32()
  external int type;

  @__u32()
  external int frequency;

  @ffi.Array.multi([8])
  external ffi.Array<__u32> reserved;
}

final class v4l2_frequency_band extends ffi.Struct {
  @__u32()
  external int tuner;

  /// enum v4l2_tuner_type
  @__u32()
  external int type;

  @__u32()
  external int index;

  @__u32()
  external int capability;

  @__u32()
  external int rangelow;

  @__u32()
  external int rangehigh;

  @__u32()
  external int modulation;

  @ffi.Array.multi([9])
  external ffi.Array<__u32> reserved;
}

final class v4l2_hw_freq_seek extends ffi.Struct {
  @__u32()
  external int tuner;

  /// enum v4l2_tuner_type
  @__u32()
  external int type;

  @__u32()
  external int seek_upward;

  @__u32()
  external int wrap_around;

  @__u32()
  external int spacing;

  @__u32()
  external int rangelow;

  @__u32()
  external int rangehigh;

  @ffi.Array.multi([5])
  external ffi.Array<__u32> reserved;
}

/// R D S
@ffi.Packed(1)
final class v4l2_rds_data extends ffi.Struct {
  @__u8()
  external int lsb;

  @__u8()
  external int msb;

  @__u8()
  external int block;
}

/// A U D I O
final class v4l2_audio extends ffi.Struct {
  @__u32()
  external int index;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  @__u32()
  external int capability;

  @__u32()
  external int mode;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class v4l2_audioout extends ffi.Struct {
  @__u32()
  external int index;

  @ffi.Array.multi([32])
  external ffi.Array<__u8> name;

  @__u32()
  external int capability;

  @__u32()
  external int mode;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class v4l2_enc_idx_entry extends ffi.Struct {
  @__u64()
  external int offset;

  @__u64()
  external int pts;

  @__u32()
  external int length;

  @__u32()
  external int flags;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class v4l2_enc_idx extends ffi.Struct {
  @__u32()
  external int entries;

  @__u32()
  external int entries_cap;

  @ffi.Array.multi([4])
  external ffi.Array<__u32> reserved;

  @ffi.Array.multi([64])
  external ffi.Array<v4l2_enc_idx_entry> entry;
}

final class v4l2_encoder_cmd extends ffi.Struct {
  @__u32()
  external int cmd;

  @__u32()
  external int flags;

  external UnnamedUnion12 unnamed;
}

final class UnnamedUnion12 extends ffi.Union {
  external UnnamedStruct2 raw;
}

final class UnnamedStruct2 extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<__u32> data;
}

/// The structure must be zeroed before use by the application
/// This ensures it can be extended safely in the future.
final class v4l2_decoder_cmd extends ffi.Struct {
  @__u32()
  external int cmd;

  @__u32()
  external int flags;

  external UnnamedUnion13 unnamed;
}

final class UnnamedUnion13 extends ffi.Union {
  external UnnamedStruct3 stop;

  external UnnamedStruct4 start;

  external UnnamedStruct5 raw;
}

final class UnnamedStruct3 extends ffi.Struct {
  @__u64()
  external int pts;
}

final class UnnamedStruct4 extends ffi.Struct {
  /// 0 or 1000 specifies normal speed,
  /// 1 specifies forward single stepping,
  /// -1 specifies backward single stepping,
  /// >1: playback at speed/1000 of the normal speed,
  /// <-1: reverse playback at (-speed/1000) of the normal speed.
  @__s32()
  external int speed;

  @__u32()
  external int format;
}

final class UnnamedStruct5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__u32> data;
}

/// Raw VBI
final class v4l2_vbi_format extends ffi.Struct {
  /// in 1 Hz
  @__u32()
  external int sampling_rate;

  @__u32()
  external int offset;

  @__u32()
  external int samples_per_line;

  /// V4L2_PIX_FMT_*
  @__u32()
  external int sample_format;

  @ffi.Array.multi([2])
  external ffi.Array<__s32> start;

  @ffi.Array.multi([2])
  external ffi.Array<__u32> count;

  /// V4L2_VBI_*
  @__u32()
  external int flags;

  /// must be zero
  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

/// Sliced VBI
///
/// This implements is a proposal V4L2 API to allow SLICED VBI
/// required for some hardware encoders. It should change without
/// notice in the definitive implementation.
final class v4l2_sliced_vbi_format extends ffi.Struct {
  @__u16()
  external int service_set;

  /// service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
  /// service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
  /// (equals frame lines 313-336 for 625 line video
  /// standards, 263-286 for 525 line standards)
  @ffi.Array.multi([2, 24])
  external ffi.Array<ffi.Array<__u16>> service_lines;

  @__u32()
  external int io_size;

  /// must be zero
  @ffi.Array.multi([2])
  external ffi.Array<__u32> reserved;
}

final class v4l2_sliced_vbi_cap extends ffi.Struct {
  @__u16()
  external int service_set;

  /// service_lines[0][...] specifies lines 0-23 (1-23 used) of the first field
  /// service_lines[1][...] specifies lines 0-23 (1-23 used) of the second field
  /// (equals frame lines 313-336 for 625 line video
  /// standards, 263-286 for 525 line standards)
  @ffi.Array.multi([2, 24])
  external ffi.Array<ffi.Array<__u16>> service_lines;

  /// enum v4l2_buf_type
  @__u32()
  external int type;

  /// must be 0
  @ffi.Array.multi([3])
  external ffi.Array<__u32> reserved;
}

final class v4l2_sliced_vbi_data extends ffi.Struct {
  @__u32()
  external int id;

  /// 0: first field, 1: second field
  @__u32()
  external int field;

  /// 1-23
  @__u32()
  external int line;

  /// must be 0
  @__u32()
  external int reserved;

  @ffi.Array.multi([48])
  external ffi.Array<__u8> data;
}

@ffi.Packed(1)
final class v4l2_mpeg_vbi_itv0_line extends ffi.Struct {
  /// One of V4L2_MPEG_VBI_IVTV_* above
  @__u8()
  external int id;

  /// Sliced VBI data for the line
  @ffi.Array.multi([42])
  external ffi.Array<__u8> data;
}

@ffi.Packed(1)
final class v4l2_mpeg_vbi_itv0 extends ffi.Struct {
  /// Bitmasks of VBI service lines present
  @ffi.Array.multi([2])
  external ffi.Array<__le32> linemask;

  @ffi.Array.multi([35])
  external ffi.Array<v4l2_mpeg_vbi_itv0_line> line;
}

typedef __le32 = __u32;

@ffi.Packed(1)
final class v4l2_mpeg_vbi_ITV0 extends ffi.Struct {
  @ffi.Array.multi([36])
  external ffi.Array<v4l2_mpeg_vbi_itv0_line> line;
}

@ffi.Packed(1)
final class v4l2_mpeg_vbi_fmt_ivtv extends ffi.Struct {
  @ffi.Array.multi([4])
  external ffi.Array<__u8> magic;

  external UnnamedUnion14 unnamed;
}

final class UnnamedUnion14 extends ffi.Union {
  external v4l2_mpeg_vbi_itv0 itv0;

  external v4l2_mpeg_vbi_ITV0 ITV0;
}

/// struct v4l2_plane_pix_format - additional, per-plane format definition
/// @sizeimage:		maximum size in bytes required for data, for which
/// this plane will be used
/// @bytesperline:	distance in bytes between the leftmost pixels in two
/// adjacent lines
/// @reserved:		drivers and applications must zero this array
@ffi.Packed(1)
final class v4l2_plane_pix_format extends ffi.Struct {
  @__u32()
  external int sizeimage;

  @__u32()
  external int bytesperline;

  @ffi.Array.multi([6])
  external ffi.Array<__u16> reserved;
}

/// struct v4l2_pix_format_mplane - multiplanar format definition
/// @width:		image width in pixels
/// @height:		image height in pixels
/// @pixelformat:	little endian four character code (fourcc)
/// @field:		enum v4l2_field; field order (for interlaced video)
/// @colorspace:		enum v4l2_colorspace; supplemental to pixelformat
/// @plane_fmt:		per-plane information
/// @num_planes:		number of planes for this format
/// @flags:		format flags (V4L2_PIX_FMT_FLAG_*)
/// @ycbcr_enc:		enum v4l2_ycbcr_encoding, Y'CbCr encoding
/// @hsv_enc:		enum v4l2_hsv_encoding, HSV encoding
/// @quantization:	enum v4l2_quantization, colorspace quantization
/// @xfer_func:		enum v4l2_xfer_func, colorspace transfer function
/// @reserved:		drivers and applications must zero this array
@ffi.Packed(1)
final class v4l2_pix_format_mplane extends ffi.Struct {
  @__u32()
  external int width;

  @__u32()
  external int height;

  @__u32()
  external int pixelformat;

  @__u32()
  external int field;

  @__u32()
  external int colorspace;

  @ffi.Array.multi([8])
  external ffi.Array<v4l2_plane_pix_format> plane_fmt;

  @__u8()
  external int num_planes;

  @__u8()
  external int flags;

  external UnnamedUnion15 unnamed;

  @__u8()
  external int quantization;

  @__u8()
  external int xfer_func;

  @ffi.Array.multi([7])
  external ffi.Array<__u8> reserved;
}

final class UnnamedUnion15 extends ffi.Union {
  @__u8()
  external int ycbcr_enc;

  @__u8()
  external int hsv_enc;
}

/// struct v4l2_sdr_format - SDR format definition
/// @pixelformat:	little endian four character code (fourcc)
/// @buffersize:		maximum size in bytes required for data
/// @reserved:		drivers and applications must zero this array
@ffi.Packed(1)
final class v4l2_sdr_format extends ffi.Struct {
  @__u32()
  external int pixelformat;

  @__u32()
  external int buffersize;

  @ffi.Array.multi([24])
  external ffi.Array<__u8> reserved;
}

/// struct v4l2_meta_format - metadata format definition
/// @dataformat:		little endian four character code (fourcc)
/// @buffersize:		maximum size in bytes required for data
@ffi.Packed(1)
final class v4l2_meta_format extends ffi.Struct {
  @__u32()
  external int dataformat;

  @__u32()
  external int buffersize;
}

/// struct v4l2_format - stream data format
/// @type:	enum v4l2_buf_type; type of the data stream
/// @pix:	definition of an image format
/// @pix_mp:	definition of a multiplanar image format
/// @win:	definition of an overlaid image
/// @vbi:	raw VBI capture or output parameters
/// @sliced:	sliced VBI capture or output parameters
/// @raw_data:	placeholder for future extensions and custom formats
/// @fmt:	union of @pix, @pix_mp, @win, @vbi, @sliced, @sdr, @meta
/// and @raw_data
final class v4l2_format extends ffi.Struct {
  @__u32()
  external int type;

  external UnnamedUnion16 fmt;
}

final class UnnamedUnion16 extends ffi.Union {
  /// V4L2_BUF_TYPE_VIDEO_CAPTURE
  external v4l2_pix_format pix;

  /// V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE
  external v4l2_pix_format_mplane pix_mp;

  /// V4L2_BUF_TYPE_VIDEO_OVERLAY
  external v4l2_window win;

  /// V4L2_BUF_TYPE_VBI_CAPTURE
  external v4l2_vbi_format vbi;

  /// V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
  external v4l2_sliced_vbi_format sliced;

  /// V4L2_BUF_TYPE_SDR_CAPTURE
  external v4l2_sdr_format sdr;

  /// V4L2_BUF_TYPE_META_CAPTURE
  external v4l2_meta_format meta;

  /// user-defined
  @ffi.Array.multi([200])
  external ffi.Array<__u8> raw_data;
}

/// Stream type-dependent parameters
final class v4l2_streamparm extends ffi.Struct {
  /// enum v4l2_buf_type
  @__u32()
  external int type;

  external UnnamedUnion17 parm;
}

final class UnnamedUnion17 extends ffi.Union {
  external v4l2_captureparm capture;

  external v4l2_outputparm output;

  /// user-defined
  @ffi.Array.multi([200])
  external ffi.Array<__u8> raw_data;
}

/// Payload for V4L2_EVENT_VSYNC
@ffi.Packed(1)
final class v4l2_event_vsync extends ffi.Struct {
  /// Can be V4L2_FIELD_ANY, _NONE, _TOP or _BOTTOM
  @__u8()
  external int field;
}

final class v4l2_event_ctrl extends ffi.Struct {
  @__u32()
  external int changes;

  @__u32()
  external int type;

  external UnnamedUnion18 unnamed;

  @__u32()
  external int flags;

  @__s32()
  external int minimum;

  @__s32()
  external int maximum;

  @__s32()
  external int step;

  @__s32()
  external int default_value;
}

final class UnnamedUnion18 extends ffi.Union {
  @__s32()
  external int value;

  @__s64()
  external int value64;
}

final class v4l2_event_frame_sync extends ffi.Struct {
  @__u32()
  external int frame_sequence;
}

final class v4l2_event_src_change extends ffi.Struct {
  @__u32()
  external int changes;
}

/// struct v4l2_event_motion_det - motion detection event
/// @flags:             if V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ is set, then the
/// frame_sequence field is valid.
/// @frame_sequence:    the frame sequence number associated with this event.
/// @region_mask:       which regions detected motion.
final class v4l2_event_motion_det extends ffi.Struct {
  @__u32()
  external int flags;

  @__u32()
  external int frame_sequence;

  @__u32()
  external int region_mask;
}

final class v4l2_event extends ffi.Struct {
  @__u32()
  external int type;

  external UnnamedUnion19 u;

  @__u32()
  external int pending;

  @__u32()
  external int sequence;

  external timespec timestamp;

  @__u32()
  external int id;

  @ffi.Array.multi([8])
  external ffi.Array<__u32> reserved;
}

final class UnnamedUnion19 extends ffi.Union {
  external v4l2_event_vsync vsync;

  external v4l2_event_ctrl ctrl;

  external v4l2_event_frame_sync frame_sync;

  external v4l2_event_src_change src_change;

  external v4l2_event_motion_det motion_det;

  @ffi.Array.multi([64])
  external ffi.Array<__u8> data;
}

final class timespec extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__syscall_slong_t()
  external int tv_nsec;
}

typedef __syscall_slong_t = ffi.Long;
typedef Dart__syscall_slong_t = int;

final class v4l2_event_subscription extends ffi.Struct {
  @__u32()
  external int type;

  @__u32()
  external int id;

  @__u32()
  external int flags;

  @ffi.Array.multi([5])
  external ffi.Array<__u32> reserved;
}

@ffi.Packed(1)
final class v4l2_dbg_match extends ffi.Struct {
  /// Match type
  @__u32()
  external int type;

  external UnnamedUnion20 unnamed;
}

final class UnnamedUnion20 extends ffi.Union {
  @__u32()
  external int addr;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;
}

@ffi.Packed(1)
final class v4l2_dbg_register extends ffi.Struct {
  external v4l2_dbg_match match;

  /// register size in bytes
  @__u32()
  external int size;

  @__u64()
  external int reg;

  @__u64()
  external int val;
}

/// VIDIOC_DBG_G_CHIP_INFO
@ffi.Packed(1)
final class v4l2_dbg_chip_info extends ffi.Struct {
  external v4l2_dbg_match match;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> name;

  @__u32()
  external int flags;

  @ffi.Array.multi([32])
  external ffi.Array<__u32> reserved;
}

/// struct v4l2_create_buffers - VIDIOC_CREATE_BUFS argument
/// @index:	on return, index of the first created buffer
/// @count:	entry: number of requested buffers,
/// return: number of created buffers
/// @memory:	enum v4l2_memory; buffer memory type
/// @format:	frame format, for which buffers are requested
/// @capabilities: capabilities of this buffer type.
/// @flags:	additional buffer management attributes (ignored unless the
/// queue has V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS capability
/// and configured for MMAP streaming I/O).
/// @max_num_buffers: if V4L2_BUF_CAP_SUPPORTS_MAX_NUM_BUFFERS capability flag is set
/// this field indicate the maximum possible number of buffers
/// for this queue.
/// @reserved:	future extensions
final class v4l2_create_buffers extends ffi.Struct {
  @__u32()
  external int index;

  @__u32()
  external int count;

  @__u32()
  external int memory;

  external v4l2_format format;

  @__u32()
  external int capabilities;

  @__u32()
  external int flags;

  @__u32()
  external int max_num_buffers;

  @ffi.Array.multi([5])
  external ffi.Array<__u32> reserved;
}

const int VIDEO_MAX_FRAME = 32;

const int VIDEO_MAX_PLANES = 8;

const int V4L2_TUNER_ADC = 4;

const int V4L2_COLORSPACE_ADOBERGB = 9;

const int V4L2_XFER_FUNC_ADOBERGB = 3;

const int V4L2_CAP_VIDEO_CAPTURE = 1;

const int V4L2_CAP_VIDEO_OUTPUT = 2;

const int V4L2_CAP_VIDEO_OVERLAY = 4;

const int V4L2_CAP_VBI_CAPTURE = 16;

const int V4L2_CAP_VBI_OUTPUT = 32;

const int V4L2_CAP_SLICED_VBI_CAPTURE = 64;

const int V4L2_CAP_SLICED_VBI_OUTPUT = 128;

const int V4L2_CAP_RDS_CAPTURE = 256;

const int V4L2_CAP_VIDEO_OUTPUT_OVERLAY = 512;

const int V4L2_CAP_HW_FREQ_SEEK = 1024;

const int V4L2_CAP_RDS_OUTPUT = 2048;

const int V4L2_CAP_VIDEO_CAPTURE_MPLANE = 4096;

const int V4L2_CAP_VIDEO_OUTPUT_MPLANE = 8192;

const int V4L2_CAP_VIDEO_M2M_MPLANE = 16384;

const int V4L2_CAP_VIDEO_M2M = 32768;

const int V4L2_CAP_TUNER = 65536;

const int V4L2_CAP_AUDIO = 131072;

const int V4L2_CAP_RADIO = 262144;

const int V4L2_CAP_MODULATOR = 524288;

const int V4L2_CAP_SDR_CAPTURE = 1048576;

const int V4L2_CAP_EXT_PIX_FORMAT = 2097152;

const int V4L2_CAP_SDR_OUTPUT = 4194304;

const int V4L2_CAP_META_CAPTURE = 8388608;

const int V4L2_CAP_READWRITE = 16777216;

const int V4L2_CAP_STREAMING = 67108864;

const int V4L2_CAP_META_OUTPUT = 134217728;

const int V4L2_CAP_TOUCH = 268435456;

const int V4L2_CAP_IO_MC = 536870912;

const int V4L2_CAP_DEVICE_CAPS = 2147483648;

const int V4L2_PIX_FMT_RGB332 = 826427218;

const int V4L2_PIX_FMT_RGB444 = 875836498;

const int V4L2_PIX_FMT_ARGB444 = 842093121;

const int V4L2_PIX_FMT_XRGB444 = 842093144;

const int V4L2_PIX_FMT_RGBA444 = 842088786;

const int V4L2_PIX_FMT_RGBX444 = 842094674;

const int V4L2_PIX_FMT_ABGR444 = 842089025;

const int V4L2_PIX_FMT_XBGR444 = 842089048;

const int V4L2_PIX_FMT_BGRA444 = 842088775;

const int V4L2_PIX_FMT_BGRX444 = 842094658;

const int V4L2_PIX_FMT_RGB555 = 1329743698;

const int V4L2_PIX_FMT_ARGB555 = 892424769;

const int V4L2_PIX_FMT_XRGB555 = 892424792;

const int V4L2_PIX_FMT_RGBA555 = 892420434;

const int V4L2_PIX_FMT_RGBX555 = 892426322;

const int V4L2_PIX_FMT_ABGR555 = 892420673;

const int V4L2_PIX_FMT_XBGR555 = 892420696;

const int V4L2_PIX_FMT_BGRA555 = 892420418;

const int V4L2_PIX_FMT_BGRX555 = 892426306;

const int V4L2_PIX_FMT_RGB565 = 1346520914;

const int V4L2_PIX_FMT_RGB555X = 1363298130;

const int V4L2_PIX_FMT_ARGB555X = 3039908417;

const int V4L2_PIX_FMT_XRGB555X = 3039908440;

const int V4L2_PIX_FMT_RGB565X = 1380075346;

const int V4L2_PIX_FMT_BGR666 = 1213351746;

const int V4L2_PIX_FMT_BGR24 = 861030210;

const int V4L2_PIX_FMT_RGB24 = 859981650;

const int V4L2_PIX_FMT_BGR32 = 877807426;

const int V4L2_PIX_FMT_ABGR32 = 875713089;

const int V4L2_PIX_FMT_XBGR32 = 875713112;

const int V4L2_PIX_FMT_BGRA32 = 875708754;

const int V4L2_PIX_FMT_BGRX32 = 875714642;

const int V4L2_PIX_FMT_RGB32 = 876758866;

const int V4L2_PIX_FMT_RGBA32 = 875708993;

const int V4L2_PIX_FMT_RGBX32 = 875709016;

const int V4L2_PIX_FMT_ARGB32 = 875708738;

const int V4L2_PIX_FMT_XRGB32 = 875714626;

const int V4L2_PIX_FMT_RGBX1010102 = 808671314;

const int V4L2_PIX_FMT_RGBA1010102 = 808665426;

const int V4L2_PIX_FMT_ARGB2101010 = 808669761;

const int V4L2_PIX_FMT_BGR48_12 = 842085186;

const int V4L2_PIX_FMT_ABGR64_12 = 842085442;

const int V4L2_PIX_FMT_GREY = 1497715271;

const int V4L2_PIX_FMT_Y4 = 540291161;

const int V4L2_PIX_FMT_Y6 = 540422233;

const int V4L2_PIX_FMT_Y10 = 540029273;

const int V4L2_PIX_FMT_Y12 = 540160345;

const int V4L2_PIX_FMT_Y012 = 842084441;

const int V4L2_PIX_FMT_Y14 = 540291417;

const int V4L2_PIX_FMT_Y16 = 540422489;

const int V4L2_PIX_FMT_Y16_BE = 2687906137;

const int V4L2_PIX_FMT_Y10BPACK = 1110454617;

const int V4L2_PIX_FMT_Y10P = 1345335641;

const int V4L2_PIX_FMT_IPU3_Y10 = 2033414249;

const int V4L2_PIX_FMT_PAL8 = 944521552;

const int V4L2_PIX_FMT_UV8 = 540563029;

const int V4L2_PIX_FMT_YUYV = 1448695129;

const int V4L2_PIX_FMT_YYUV = 1448434009;

const int V4L2_PIX_FMT_YVYU = 1431918169;

const int V4L2_PIX_FMT_UYVY = 1498831189;

const int V4L2_PIX_FMT_VYUY = 1498765654;

const int V4L2_PIX_FMT_Y41P = 1345401945;

const int V4L2_PIX_FMT_YUV444 = 875836505;

const int V4L2_PIX_FMT_YUV555 = 1331058009;

const int V4L2_PIX_FMT_YUV565 = 1347835225;

const int V4L2_PIX_FMT_YUV24 = 861295961;

const int V4L2_PIX_FMT_YUV32 = 878073177;

const int V4L2_PIX_FMT_AYUV32 = 1448433985;

const int V4L2_PIX_FMT_XYUV32 = 1448434008;

const int V4L2_PIX_FMT_VUYA32 = 1096373590;

const int V4L2_PIX_FMT_VUYX32 = 1482249558;

const int V4L2_PIX_FMT_YUVA32 = 1096176985;

const int V4L2_PIX_FMT_YUVX32 = 1482052953;

const int V4L2_PIX_FMT_M420 = 808596557;

const int V4L2_PIX_FMT_YUV48_12 = 842085209;

const int V4L2_PIX_FMT_Y210 = 808530521;

const int V4L2_PIX_FMT_Y212 = 842084953;

const int V4L2_PIX_FMT_Y216 = 909193817;

const int V4L2_PIX_FMT_NV12 = 842094158;

const int V4L2_PIX_FMT_NV21 = 825382478;

const int V4L2_PIX_FMT_NV16 = 909203022;

const int V4L2_PIX_FMT_NV61 = 825644622;

const int V4L2_PIX_FMT_NV24 = 875714126;

const int V4L2_PIX_FMT_NV42 = 842290766;

const int V4L2_PIX_FMT_P010 = 808530000;

const int V4L2_PIX_FMT_P012 = 842084432;

const int V4L2_PIX_FMT_NV12M = 842091854;

const int V4L2_PIX_FMT_NV21M = 825380174;

const int V4L2_PIX_FMT_NV16M = 909200718;

const int V4L2_PIX_FMT_NV61M = 825642318;

const int V4L2_PIX_FMT_P012M = 842091856;

const int V4L2_PIX_FMT_YUV410 = 961959257;

const int V4L2_PIX_FMT_YVU410 = 961893977;

const int V4L2_PIX_FMT_YUV411P = 1345401140;

const int V4L2_PIX_FMT_YUV420 = 842093913;

const int V4L2_PIX_FMT_YVU420 = 842094169;

const int V4L2_PIX_FMT_YUV422P = 1345466932;

const int V4L2_PIX_FMT_YUV420M = 842091865;

const int V4L2_PIX_FMT_YVU420M = 825380185;

const int V4L2_PIX_FMT_YUV422M = 909200729;

const int V4L2_PIX_FMT_YVU422M = 825642329;

const int V4L2_PIX_FMT_YUV444M = 875711833;

const int V4L2_PIX_FMT_YVU444M = 842288473;

const int V4L2_PIX_FMT_NV12_4L4 = 842093654;

const int V4L2_PIX_FMT_NV12_16L16 = 842091848;

const int V4L2_PIX_FMT_NV12_32L32 = 842093651;

const int V4L2_PIX_FMT_NV15_4L4 = 892425302;

const int V4L2_PIX_FMT_P010_4L4 = 808530004;

const int V4L2_PIX_FMT_NV12_8L128 = 842093633;

const int V4L2_PIX_FMT_NV12_10BE_8L128 = 2989578305;

const int V4L2_PIX_FMT_NV12MT = 842091860;

const int V4L2_PIX_FMT_NV12MT_16X16 = 842091862;

const int V4L2_PIX_FMT_NV12M_8L128 = 842088782;

const int V4L2_PIX_FMT_NV12M_10BE_8L128 = 2989577294;

const int V4L2_PIX_FMT_SBGGR8 = 825770306;

const int V4L2_PIX_FMT_SGBRG8 = 1196573255;

const int V4L2_PIX_FMT_SGRBG8 = 1195528775;

const int V4L2_PIX_FMT_SRGGB8 = 1111967570;

const int V4L2_PIX_FMT_SBGGR10 = 808535874;

const int V4L2_PIX_FMT_SGBRG10 = 808534599;

const int V4L2_PIX_FMT_SGRBG10 = 808534338;

const int V4L2_PIX_FMT_SRGGB10 = 808535890;

const int V4L2_PIX_FMT_SBGGR10P = 1094795888;

const int V4L2_PIX_FMT_SGBRG10P = 1094797168;

const int V4L2_PIX_FMT_SGRBG10P = 1094805360;

const int V4L2_PIX_FMT_SRGGB10P = 1094799984;

const int V4L2_PIX_FMT_SBGGR10ALAW8 = 943800929;

const int V4L2_PIX_FMT_SGBRG10ALAW8 = 943802209;

const int V4L2_PIX_FMT_SGRBG10ALAW8 = 943810401;

const int V4L2_PIX_FMT_SRGGB10ALAW8 = 943805025;

const int V4L2_PIX_FMT_SBGGR10DPCM8 = 943800930;

const int V4L2_PIX_FMT_SGBRG10DPCM8 = 943802210;

const int V4L2_PIX_FMT_SGRBG10DPCM8 = 808535106;

const int V4L2_PIX_FMT_SRGGB10DPCM8 = 943805026;

const int V4L2_PIX_FMT_SBGGR12 = 842090306;

const int V4L2_PIX_FMT_SGBRG12 = 842089031;

const int V4L2_PIX_FMT_SGRBG12 = 842088770;

const int V4L2_PIX_FMT_SRGGB12 = 842090322;

const int V4L2_PIX_FMT_SBGGR12P = 1128481392;

const int V4L2_PIX_FMT_SGBRG12P = 1128482672;

const int V4L2_PIX_FMT_SGRBG12P = 1128490864;

const int V4L2_PIX_FMT_SRGGB12P = 1128485488;

const int V4L2_PIX_FMT_SBGGR14 = 875644738;

const int V4L2_PIX_FMT_SGBRG14 = 875643463;

const int V4L2_PIX_FMT_SGRBG14 = 875647559;

const int V4L2_PIX_FMT_SRGGB14 = 875644754;

const int V4L2_PIX_FMT_SBGGR14P = 1162166896;

const int V4L2_PIX_FMT_SGBRG14P = 1162168176;

const int V4L2_PIX_FMT_SGRBG14P = 1162176368;

const int V4L2_PIX_FMT_SRGGB14P = 1162170992;

const int V4L2_PIX_FMT_SBGGR16 = 844257602;

const int V4L2_PIX_FMT_SGBRG16 = 909197895;

const int V4L2_PIX_FMT_SGRBG16 = 909201991;

const int V4L2_PIX_FMT_SRGGB16 = 909199186;

const int V4L2_PIX_FMT_HSV24 = 861295432;

const int V4L2_PIX_FMT_HSV32 = 878072648;

const int V4L2_PIX_FMT_MJPEG = 1196444237;

const int V4L2_PIX_FMT_JPEG = 1195724874;

const int V4L2_PIX_FMT_DV = 1685288548;

const int V4L2_PIX_FMT_MPEG = 1195724877;

const int V4L2_PIX_FMT_H264 = 875967048;

const int V4L2_PIX_FMT_H264_NO_SC = 826496577;

const int V4L2_PIX_FMT_H264_MVC = 875967053;

const int V4L2_PIX_FMT_H263 = 859189832;

const int V4L2_PIX_FMT_MPEG1 = 826757197;

const int V4L2_PIX_FMT_MPEG2 = 843534413;

const int V4L2_PIX_FMT_MPEG2_SLICE = 1395803981;

const int V4L2_PIX_FMT_MPEG4 = 877088845;

const int V4L2_PIX_FMT_XVID = 1145656920;

const int V4L2_PIX_FMT_VC1_ANNEX_G = 1194410838;

const int V4L2_PIX_FMT_VC1_ANNEX_L = 1278296918;

const int V4L2_PIX_FMT_VP8 = 808996950;

const int V4L2_PIX_FMT_VP8_FRAME = 1178095702;

const int V4L2_PIX_FMT_VP9 = 809062486;

const int V4L2_PIX_FMT_VP9_FRAME = 1178161238;

const int V4L2_PIX_FMT_HEVC = 1129727304;

const int V4L2_PIX_FMT_FWHT = 1414027078;

const int V4L2_PIX_FMT_FWHT_STATELESS = 1213679187;

const int V4L2_PIX_FMT_H264_SLICE = 875967059;

const int V4L2_PIX_FMT_HEVC_SLICE = 892744275;

const int V4L2_PIX_FMT_AV1_FRAME = 1177638465;

const int V4L2_PIX_FMT_SPK = 810242131;

const int V4L2_PIX_FMT_RV30 = 808670802;

const int V4L2_PIX_FMT_RV40 = 808736338;

const int V4L2_PIX_FMT_CPIA1 = 1095323715;

const int V4L2_PIX_FMT_WNVA = 1096175191;

const int V4L2_PIX_FMT_SN9C10X = 808532307;

const int V4L2_PIX_FMT_SN9C20X_I420 = 808597843;

const int V4L2_PIX_FMT_PWC1 = 826496848;

const int V4L2_PIX_FMT_PWC2 = 843274064;

const int V4L2_PIX_FMT_ET61X251 = 892483141;

const int V4L2_PIX_FMT_SPCA501 = 825242963;

const int V4L2_PIX_FMT_SPCA505 = 892351827;

const int V4L2_PIX_FMT_SPCA508 = 942683475;

const int V4L2_PIX_FMT_SPCA561 = 825636179;

const int V4L2_PIX_FMT_PAC207 = 925905488;

const int V4L2_PIX_FMT_MR97310A = 808530765;

const int V4L2_PIX_FMT_JL2005BCD = 808602698;

const int V4L2_PIX_FMT_SN9C2028 = 1481527123;

const int V4L2_PIX_FMT_SQ905C = 1127559225;

const int V4L2_PIX_FMT_PJPG = 1196444240;

const int V4L2_PIX_FMT_OV511 = 825308495;

const int V4L2_PIX_FMT_OV518 = 942749007;

const int V4L2_PIX_FMT_STV0680 = 808990291;

const int V4L2_PIX_FMT_TM6000 = 808865108;

const int V4L2_PIX_FMT_CIT_YYVYUY = 1448364355;

const int V4L2_PIX_FMT_KONICA420 = 1229868875;

const int V4L2_PIX_FMT_JPGL = 1279742026;

const int V4L2_PIX_FMT_SE401 = 825242707;

const int V4L2_PIX_FMT_S5C_UYVY_JPG = 1229141331;

const int V4L2_PIX_FMT_Y8I = 541669465;

const int V4L2_PIX_FMT_Y12I = 1228026201;

const int V4L2_PIX_FMT_Z16 = 540422490;

const int V4L2_PIX_FMT_MT21C = 825381965;

const int V4L2_PIX_FMT_MM21 = 825380173;

const int V4L2_PIX_FMT_MT2110T = 1412584525;

const int V4L2_PIX_FMT_MT2110R = 1379030093;

const int V4L2_PIX_FMT_INZI = 1230655049;

const int V4L2_PIX_FMT_CNF4 = 877022787;

const int V4L2_PIX_FMT_HI240 = 875710792;

const int V4L2_PIX_FMT_QC08C = 1127755857;

const int V4L2_PIX_FMT_QC10C = 1127231825;

const int V4L2_PIX_FMT_AJPG = 1196444225;

const int V4L2_PIX_FMT_HEXTILE = 1280596040;

const int V4L2_PIX_FMT_IPU3_SBGGR10 = 1647538281;

const int V4L2_PIX_FMT_IPU3_SGBRG10 = 1731424361;

const int V4L2_PIX_FMT_IPU3_SGRBG10 = 1194553449;

const int V4L2_PIX_FMT_IPU3_SRGGB10 = 1915973737;

const int V4L2_SDR_FMT_CU8 = 942691651;

const int V4L2_SDR_FMT_CU16LE = 909202755;

const int V4L2_SDR_FMT_CS8 = 942691139;

const int V4L2_SDR_FMT_CS14LE = 875647811;

const int V4L2_SDR_FMT_RU12LE = 842093906;

const int V4L2_SDR_FMT_PCU16BE = 909198160;

const int V4L2_SDR_FMT_PCU18BE = 942752592;

const int V4L2_SDR_FMT_PCU20BE = 808600400;

const int V4L2_TCH_FMT_DELTA_TD16 = 909198420;

const int V4L2_TCH_FMT_DELTA_TD08 = 942687316;

const int V4L2_TCH_FMT_TU16 = 909202772;

const int V4L2_TCH_FMT_TU08 = 942691668;

const int V4L2_META_FMT_VSP1_HGO = 1213223766;

const int V4L2_META_FMT_VSP1_HGT = 1414550358;

const int V4L2_META_FMT_UVC = 1212372565;

const int V4L2_META_FMT_D4XX = 1482175556;

const int V4L2_META_FMT_VIVID = 1146505558;

const int V4L2_META_FMT_RK_ISP1_PARAMS = 1345407826;

const int V4L2_META_FMT_RK_ISP1_STAT_3A = 1395739474;

const int V4L2_PIX_FMT_PRIV_MAGIC = 4276996862;

const int V4L2_PIX_FMT_FLAG_PREMUL_ALPHA = 1;

const int V4L2_PIX_FMT_FLAG_SET_CSC = 2;

const int V4L2_FMT_FLAG_COMPRESSED = 1;

const int V4L2_FMT_FLAG_EMULATED = 2;

const int V4L2_FMT_FLAG_CONTINUOUS_BYTESTREAM = 4;

const int V4L2_FMT_FLAG_DYN_RESOLUTION = 8;

const int V4L2_FMT_FLAG_ENC_CAP_FRAME_INTERVAL = 16;

const int V4L2_FMT_FLAG_CSC_COLORSPACE = 32;

const int V4L2_FMT_FLAG_CSC_XFER_FUNC = 64;

const int V4L2_FMT_FLAG_CSC_YCBCR_ENC = 128;

const int V4L2_FMT_FLAG_CSC_HSV_ENC = 128;

const int V4L2_FMT_FLAG_CSC_QUANTIZATION = 256;

const int V4L2_TC_TYPE_24FPS = 1;

const int V4L2_TC_TYPE_25FPS = 2;

const int V4L2_TC_TYPE_30FPS = 3;

const int V4L2_TC_TYPE_50FPS = 4;

const int V4L2_TC_TYPE_60FPS = 5;

const int V4L2_TC_FLAG_DROPFRAME = 1;

const int V4L2_TC_FLAG_COLORFRAME = 2;

const int V4L2_TC_USERBITS_field = 12;

const int V4L2_TC_USERBITS_USERDEFINED = 0;

const int V4L2_TC_USERBITS_8BITCHARS = 8;

const int V4L2_JPEG_MARKER_DHT = 8;

const int V4L2_JPEG_MARKER_DQT = 16;

const int V4L2_JPEG_MARKER_DRI = 32;

const int V4L2_JPEG_MARKER_COM = 64;

const int V4L2_JPEG_MARKER_APP = 128;

const int V4L2_MEMORY_FLAG_NON_COHERENT = 1;

const int V4L2_BUF_CAP_SUPPORTS_MMAP = 1;

const int V4L2_BUF_CAP_SUPPORTS_USERPTR = 2;

const int V4L2_BUF_CAP_SUPPORTS_DMABUF = 4;

const int V4L2_BUF_CAP_SUPPORTS_REQUESTS = 8;

const int V4L2_BUF_CAP_SUPPORTS_ORPHANED_BUFS = 16;

const int V4L2_BUF_CAP_SUPPORTS_M2M_HOLD_CAPTURE_BUF = 32;

const int V4L2_BUF_CAP_SUPPORTS_MMAP_CACHE_HINTS = 64;

const int V4L2_BUF_CAP_SUPPORTS_MAX_NUM_BUFFERS = 128;

const int V4L2_BUF_FLAG_MAPPED = 1;

const int V4L2_BUF_FLAG_QUEUED = 2;

const int V4L2_BUF_FLAG_DONE = 4;

const int V4L2_BUF_FLAG_KEYFRAME = 8;

const int V4L2_BUF_FLAG_PFRAME = 16;

const int V4L2_BUF_FLAG_BFRAME = 32;

const int V4L2_BUF_FLAG_ERROR = 64;

const int V4L2_BUF_FLAG_IN_REQUEST = 128;

const int V4L2_BUF_FLAG_TIMECODE = 256;

const int V4L2_BUF_FLAG_M2M_HOLD_CAPTURE_BUF = 512;

const int V4L2_BUF_FLAG_PREPARED = 1024;

const int V4L2_BUF_FLAG_NO_CACHE_INVALIDATE = 2048;

const int V4L2_BUF_FLAG_NO_CACHE_CLEAN = 4096;

const int V4L2_BUF_FLAG_TIMESTAMP_MASK = 57344;

const int V4L2_BUF_FLAG_TIMESTAMP_UNKNOWN = 0;

const int V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC = 8192;

const int V4L2_BUF_FLAG_TIMESTAMP_COPY = 16384;

const int V4L2_BUF_FLAG_TSTAMP_SRC_MASK = 458752;

const int V4L2_BUF_FLAG_TSTAMP_SRC_EOF = 0;

const int V4L2_BUF_FLAG_TSTAMP_SRC_SOE = 65536;

const int V4L2_BUF_FLAG_LAST = 1048576;

const int V4L2_BUF_FLAG_REQUEST_FD = 8388608;

const int V4L2_FBUF_CAP_EXTERNOVERLAY = 1;

const int V4L2_FBUF_CAP_CHROMAKEY = 2;

const int V4L2_FBUF_CAP_LIST_CLIPPING = 4;

const int V4L2_FBUF_CAP_BITMAP_CLIPPING = 8;

const int V4L2_FBUF_CAP_LOCAL_ALPHA = 16;

const int V4L2_FBUF_CAP_GLOBAL_ALPHA = 32;

const int V4L2_FBUF_CAP_LOCAL_INV_ALPHA = 64;

const int V4L2_FBUF_CAP_SRC_CHROMAKEY = 128;

const int V4L2_FBUF_FLAG_PRIMARY = 1;

const int V4L2_FBUF_FLAG_OVERLAY = 2;

const int V4L2_FBUF_FLAG_CHROMAKEY = 4;

const int V4L2_FBUF_FLAG_LOCAL_ALPHA = 8;

const int V4L2_FBUF_FLAG_GLOBAL_ALPHA = 16;

const int V4L2_FBUF_FLAG_LOCAL_INV_ALPHA = 32;

const int V4L2_FBUF_FLAG_SRC_CHROMAKEY = 64;

const int V4L2_MODE_HIGHQUALITY = 1;

const int V4L2_CAP_TIMEPERFRAME = 4096;

const int V4L2_STD_PAL_B = 1;

const int V4L2_STD_PAL_B1 = 2;

const int V4L2_STD_PAL_G = 4;

const int V4L2_STD_PAL_H = 8;

const int V4L2_STD_PAL_I = 16;

const int V4L2_STD_PAL_D = 32;

const int V4L2_STD_PAL_D1 = 64;

const int V4L2_STD_PAL_K = 128;

const int V4L2_STD_PAL_M = 256;

const int V4L2_STD_PAL_N = 512;

const int V4L2_STD_PAL_Nc = 1024;

const int V4L2_STD_PAL_60 = 2048;

const int V4L2_STD_NTSC_M = 4096;

const int V4L2_STD_NTSC_M_JP = 8192;

const int V4L2_STD_NTSC_443 = 16384;

const int V4L2_STD_NTSC_M_KR = 32768;

const int V4L2_STD_SECAM_B = 65536;

const int V4L2_STD_SECAM_D = 131072;

const int V4L2_STD_SECAM_G = 262144;

const int V4L2_STD_SECAM_H = 524288;

const int V4L2_STD_SECAM_K = 1048576;

const int V4L2_STD_SECAM_K1 = 2097152;

const int V4L2_STD_SECAM_L = 4194304;

const int V4L2_STD_SECAM_LC = 8388608;

const int V4L2_STD_ATSC_8_VSB = 16777216;

const int V4L2_STD_ATSC_16_VSB = 33554432;

const int V4L2_STD_NTSC = 45056;

const int V4L2_STD_SECAM_DK = 3276800;

const int V4L2_STD_SECAM = 16711680;

const int V4L2_STD_PAL_BG = 7;

const int V4L2_STD_PAL_DK = 224;

const int V4L2_STD_PAL = 255;

const int V4L2_STD_B = 65539;

const int V4L2_STD_G = 262148;

const int V4L2_STD_H = 524296;

const int V4L2_STD_L = 12582912;

const int V4L2_STD_GH = 786444;

const int V4L2_STD_DK = 3277024;

const int V4L2_STD_BG = 327687;

const int V4L2_STD_MN = 46848;

const int V4L2_STD_MTS = 5888;

const int V4L2_STD_525_60 = 63744;

const int V4L2_STD_625_50 = 16713471;

const int V4L2_STD_ATSC = 50331648;

const int V4L2_STD_UNKNOWN = 0;

const int V4L2_STD_ALL = 16777215;

const int V4L2_DV_PROGRESSIVE = 0;

const int V4L2_DV_INTERLACED = 1;

const int V4L2_DV_VSYNC_POS_POL = 1;

const int V4L2_DV_HSYNC_POS_POL = 2;

const int V4L2_DV_BT_STD_CEA861 = 1;

const int V4L2_DV_BT_STD_DMT = 2;

const int V4L2_DV_BT_STD_CVT = 4;

const int V4L2_DV_BT_STD_GTF = 8;

const int V4L2_DV_BT_STD_SDI = 16;

const int V4L2_DV_FL_REDUCED_BLANKING = 1;

const int V4L2_DV_FL_CAN_REDUCE_FPS = 2;

const int V4L2_DV_FL_REDUCED_FPS = 4;

const int V4L2_DV_FL_HALF_LINE = 8;

const int V4L2_DV_FL_IS_CE_VIDEO = 16;

const int V4L2_DV_FL_FIRST_FIELD_EXTRA_LINE = 32;

const int V4L2_DV_FL_HAS_PICTURE_ASPECT = 64;

const int V4L2_DV_FL_HAS_CEA861_VIC = 128;

const int V4L2_DV_FL_HAS_HDMI_VIC = 256;

const int V4L2_DV_FL_CAN_DETECT_REDUCED_FPS = 512;

const int V4L2_DV_BT_656_1120 = 0;

const int V4L2_DV_BT_CAP_INTERLACED = 1;

const int V4L2_DV_BT_CAP_PROGRESSIVE = 2;

const int V4L2_DV_BT_CAP_REDUCED_BLANKING = 4;

const int V4L2_DV_BT_CAP_CUSTOM = 8;

const int V4L2_INPUT_TYPE_TUNER = 1;

const int V4L2_INPUT_TYPE_CAMERA = 2;

const int V4L2_INPUT_TYPE_TOUCH = 3;

const int V4L2_IN_ST_NO_POWER = 1;

const int V4L2_IN_ST_NO_SIGNAL = 2;

const int V4L2_IN_ST_NO_COLOR = 4;

const int V4L2_IN_ST_HFLIP = 16;

const int V4L2_IN_ST_VFLIP = 32;

const int V4L2_IN_ST_NO_H_LOCK = 256;

const int V4L2_IN_ST_COLOR_KILL = 512;

const int V4L2_IN_ST_NO_V_LOCK = 1024;

const int V4L2_IN_ST_NO_STD_LOCK = 2048;

const int V4L2_IN_ST_NO_SYNC = 65536;

const int V4L2_IN_ST_NO_EQU = 131072;

const int V4L2_IN_ST_NO_CARRIER = 262144;

const int V4L2_IN_ST_MACROVISION = 16777216;

const int V4L2_IN_ST_NO_ACCESS = 33554432;

const int V4L2_IN_ST_VTR = 67108864;

const int V4L2_IN_CAP_DV_TIMINGS = 2;

const int V4L2_IN_CAP_CUSTOM_TIMINGS = 2;

const int V4L2_IN_CAP_STD = 4;

const int V4L2_IN_CAP_NATIVE_SIZE = 8;

const int V4L2_OUTPUT_TYPE_MODULATOR = 1;

const int V4L2_OUTPUT_TYPE_ANALOG = 2;

const int V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY = 3;

const int V4L2_OUT_CAP_DV_TIMINGS = 2;

const int V4L2_OUT_CAP_CUSTOM_TIMINGS = 2;

const int V4L2_OUT_CAP_STD = 4;

const int V4L2_OUT_CAP_NATIVE_SIZE = 8;

const int V4L2_CTRL_ID_MASK = 268435455;

const int V4L2_CTRL_MAX_DIMS = 4;

const int V4L2_CTRL_WHICH_CUR_VAL = 0;

const int V4L2_CTRL_WHICH_DEF_VAL = 251658240;

const int V4L2_CTRL_WHICH_REQUEST_VAL = 251723776;

const int V4L2_CTRL_FLAG_DISABLED = 1;

const int V4L2_CTRL_FLAG_GRABBED = 2;

const int V4L2_CTRL_FLAG_READ_ONLY = 4;

const int V4L2_CTRL_FLAG_UPDATE = 8;

const int V4L2_CTRL_FLAG_INACTIVE = 16;

const int V4L2_CTRL_FLAG_SLIDER = 32;

const int V4L2_CTRL_FLAG_WRITE_ONLY = 64;

const int V4L2_CTRL_FLAG_VOLATILE = 128;

const int V4L2_CTRL_FLAG_HAS_PAYLOAD = 256;

const int V4L2_CTRL_FLAG_EXECUTE_ON_WRITE = 512;

const int V4L2_CTRL_FLAG_MODIFY_LAYOUT = 1024;

const int V4L2_CTRL_FLAG_DYNAMIC_ARRAY = 2048;

const int V4L2_CTRL_FLAG_NEXT_CTRL = 2147483648;

const int V4L2_CTRL_FLAG_NEXT_COMPOUND = 1073741824;

const int V4L2_CID_MAX_CTRLS = 1024;

const int V4L2_CID_PRIVATE_BASE = 134217728;

const int V4L2_TUNER_CAP_LOW = 1;

const int V4L2_TUNER_CAP_NORM = 2;

const int V4L2_TUNER_CAP_HWSEEK_BOUNDED = 4;

const int V4L2_TUNER_CAP_HWSEEK_WRAP = 8;

const int V4L2_TUNER_CAP_STEREO = 16;

const int V4L2_TUNER_CAP_LANG2 = 32;

const int V4L2_TUNER_CAP_SAP = 32;

const int V4L2_TUNER_CAP_LANG1 = 64;

const int V4L2_TUNER_CAP_RDS = 128;

const int V4L2_TUNER_CAP_RDS_BLOCK_IO = 256;

const int V4L2_TUNER_CAP_RDS_CONTROLS = 512;

const int V4L2_TUNER_CAP_FREQ_BANDS = 1024;

const int V4L2_TUNER_CAP_HWSEEK_PROG_LIM = 2048;

const int V4L2_TUNER_CAP_1HZ = 4096;

const int V4L2_TUNER_SUB_MONO = 1;

const int V4L2_TUNER_SUB_STEREO = 2;

const int V4L2_TUNER_SUB_LANG2 = 4;

const int V4L2_TUNER_SUB_SAP = 4;

const int V4L2_TUNER_SUB_LANG1 = 8;

const int V4L2_TUNER_SUB_RDS = 16;

const int V4L2_TUNER_MODE_MONO = 0;

const int V4L2_TUNER_MODE_STEREO = 1;

const int V4L2_TUNER_MODE_LANG2 = 2;

const int V4L2_TUNER_MODE_SAP = 2;

const int V4L2_TUNER_MODE_LANG1 = 3;

const int V4L2_TUNER_MODE_LANG1_LANG2 = 4;

const int V4L2_BAND_MODULATION_VSB = 2;

const int V4L2_BAND_MODULATION_FM = 4;

const int V4L2_BAND_MODULATION_AM = 8;

const int V4L2_RDS_BLOCK_MSK = 7;

const int V4L2_RDS_BLOCK_A = 0;

const int V4L2_RDS_BLOCK_B = 1;

const int V4L2_RDS_BLOCK_C = 2;

const int V4L2_RDS_BLOCK_D = 3;

const int V4L2_RDS_BLOCK_C_ALT = 4;

const int V4L2_RDS_BLOCK_INVALID = 7;

const int V4L2_RDS_BLOCK_CORRECTED = 64;

const int V4L2_RDS_BLOCK_ERROR = 128;

const int V4L2_AUDCAP_STEREO = 1;

const int V4L2_AUDCAP_AVL = 2;

const int V4L2_AUDMODE_AVL = 1;

const int V4L2_ENC_IDX_FRAME_I = 0;

const int V4L2_ENC_IDX_FRAME_P = 1;

const int V4L2_ENC_IDX_FRAME_B = 2;

const int V4L2_ENC_IDX_FRAME_MASK = 15;

const int V4L2_ENC_IDX_ENTRIES = 64;

const int V4L2_ENC_CMD_START = 0;

const int V4L2_ENC_CMD_STOP = 1;

const int V4L2_ENC_CMD_PAUSE = 2;

const int V4L2_ENC_CMD_RESUME = 3;

const int V4L2_ENC_CMD_STOP_AT_GOP_END = 1;

const int V4L2_DEC_CMD_START = 0;

const int V4L2_DEC_CMD_STOP = 1;

const int V4L2_DEC_CMD_PAUSE = 2;

const int V4L2_DEC_CMD_RESUME = 3;

const int V4L2_DEC_CMD_FLUSH = 4;

const int V4L2_DEC_CMD_START_MUTE_AUDIO = 1;

const int V4L2_DEC_CMD_PAUSE_TO_BLACK = 1;

const int V4L2_DEC_CMD_STOP_TO_BLACK = 1;

const int V4L2_DEC_CMD_STOP_IMMEDIATELY = 2;

const int V4L2_DEC_START_FMT_NONE = 0;

const int V4L2_DEC_START_FMT_GOP = 1;

const int V4L2_VBI_UNSYNC = 1;

const int V4L2_VBI_INTERLACED = 2;

const int V4L2_VBI_ITU_525_F1_START = 1;

const int V4L2_VBI_ITU_525_F2_START = 264;

const int V4L2_VBI_ITU_625_F1_START = 1;

const int V4L2_VBI_ITU_625_F2_START = 314;

const int V4L2_SLICED_TELETEXT_B = 1;

const int V4L2_SLICED_VPS = 1024;

const int V4L2_SLICED_CAPTION_525 = 4096;

const int V4L2_SLICED_WSS_625 = 16384;

const int V4L2_SLICED_VBI_525 = 4096;

const int V4L2_SLICED_VBI_625 = 17409;

const int V4L2_MPEG_VBI_IVTV_TELETEXT_B = 1;

const int V4L2_MPEG_VBI_IVTV_CAPTION_525 = 4;

const int V4L2_MPEG_VBI_IVTV_WSS_625 = 5;

const int V4L2_MPEG_VBI_IVTV_VPS = 7;

const String V4L2_MPEG_VBI_IVTV_MAGIC0 = 'itv0';

const String V4L2_MPEG_VBI_IVTV_MAGIC1 = 'ITV0';

const int V4L2_EVENT_ALL = 0;

const int V4L2_EVENT_VSYNC = 1;

const int V4L2_EVENT_EOS = 2;

const int V4L2_EVENT_CTRL = 3;

const int V4L2_EVENT_FRAME_SYNC = 4;

const int V4L2_EVENT_SOURCE_CHANGE = 5;

const int V4L2_EVENT_MOTION_DET = 6;

const int V4L2_EVENT_PRIVATE_START = 134217728;

const int V4L2_EVENT_CTRL_CH_VALUE = 1;

const int V4L2_EVENT_CTRL_CH_FLAGS = 2;

const int V4L2_EVENT_CTRL_CH_RANGE = 4;

const int V4L2_EVENT_CTRL_CH_DIMENSIONS = 8;

const int V4L2_EVENT_SRC_CH_RESOLUTION = 1;

const int V4L2_EVENT_MD_FL_HAVE_FRAME_SEQ = 1;

const int V4L2_EVENT_SUB_FL_SEND_INITIAL = 1;

const int V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK = 2;

const int V4L2_CHIP_MATCH_BRIDGE = 0;

const int V4L2_CHIP_MATCH_SUBDEV = 4;

const int V4L2_CHIP_MATCH_HOST = 0;

const int V4L2_CHIP_MATCH_I2C_DRIVER = 1;

const int V4L2_CHIP_MATCH_I2C_ADDR = 2;

const int V4L2_CHIP_MATCH_AC97 = 3;

const int V4L2_CHIP_FL_READABLE = 1;

const int V4L2_CHIP_FL_WRITABLE = 2;

const int VIDIOC_QUERYCAP = 2154321408;

const int VIDIOC_ENUM_FMT = 3225441794;

const int VIDIOC_G_FMT = 3234878980;

const int VIDIOC_S_FMT = 3234878981;

const int VIDIOC_REQBUFS = 3222558216;

const int VIDIOC_QUERYBUF = 3227014665;

const int VIDIOC_G_FBUF = 2150651402;

const int VIDIOC_S_FBUF = 1076909579;

const int VIDIOC_OVERLAY = 1074025998;

const int VIDIOC_QBUF = 3227014671;

const int VIDIOC_EXPBUF = 3225441808;

const int VIDIOC_DQBUF = 3227014673;

const int VIDIOC_STREAMON = 1074026002;

const int VIDIOC_STREAMOFF = 1074026003;

const int VIDIOC_G_PARM = 3234616853;

const int VIDIOC_S_PARM = 3234616854;

const int VIDIOC_G_STD = 2148029975;

const int VIDIOC_S_STD = 1074288152;

const int VIDIOC_ENUMSTD = 3225966105;

const int VIDIOC_ENUMINPUT = 3226490394;

const int VIDIOC_G_CTRL = 3221771803;

const int VIDIOC_S_CTRL = 3221771804;

const int VIDIOC_G_TUNER = 3226752541;

const int VIDIOC_S_TUNER = 1079268894;

const int VIDIOC_G_AUDIO = 2150913569;

const int VIDIOC_S_AUDIO = 1077171746;

const int VIDIOC_QUERYCTRL = 3225703972;

const int VIDIOC_QUERYMENU = 3224131109;

const int VIDIOC_G_INPUT = 2147767846;

const int VIDIOC_S_INPUT = 3221509671;

const int VIDIOC_G_EDID = 3223868968;

const int VIDIOC_S_EDID = 3223868969;

const int VIDIOC_G_OUTPUT = 2147767854;

const int VIDIOC_S_OUTPUT = 3221509679;

const int VIDIOC_ENUMOUTPUT = 3225966128;

const int VIDIOC_G_AUDOUT = 2150913585;

const int VIDIOC_S_AUDOUT = 1077171762;

const int VIDIOC_G_MODULATOR = 3225703990;

const int VIDIOC_S_MODULATOR = 1078220343;

const int VIDIOC_G_FREQUENCY = 3224131128;

const int VIDIOC_S_FREQUENCY = 1076647481;

const int VIDIOC_CROPCAP = 3224131130;

const int VIDIOC_G_CROP = 3222558267;

const int VIDIOC_S_CROP = 1075074620;

const int VIDIOC_G_JPEGCOMP = 2156680765;

const int VIDIOC_S_JPEGCOMP = 1082938942;

const int VIDIOC_QUERYSTD = 2148030015;

const int VIDIOC_TRY_FMT = 3234879040;

const int VIDIOC_ENUMAUDIO = 3224655425;

const int VIDIOC_ENUMAUDOUT = 3224655426;

const int VIDIOC_G_PRIORITY = 2147767875;

const int VIDIOC_S_PRIORITY = 1074026052;

const int VIDIOC_G_SLICED_VBI_CAP = 3228849733;

const int VIDIOC_LOG_STATUS = 22086;

const int VIDIOC_G_EXT_CTRLS = 3223344711;

const int VIDIOC_S_EXT_CTRLS = 3223344712;

const int VIDIOC_TRY_EXT_CTRLS = 3223344713;

const int VIDIOC_ENUM_FRAMESIZES = 3224131146;

const int VIDIOC_ENUM_FRAMEINTERVALS = 3224655435;

const int VIDIOC_G_ENC_INDEX = 2283296332;

const int VIDIOC_ENCODER_CMD = 3223869005;

const int VIDIOC_TRY_ENCODER_CMD = 3223869006;

const int VIDIOC_DBG_S_REGISTER = 1077433935;

const int VIDIOC_DBG_G_REGISTER = 3224917584;

const int VIDIOC_S_HW_FREQ_SEEK = 1076909650;

const int VIDIOC_S_DV_TIMINGS = 3229898327;

const int VIDIOC_G_DV_TIMINGS = 3229898328;

const int VIDIOC_DQEVENT = 2156418649;

const int VIDIOC_SUBSCRIBE_EVENT = 1075861082;

const int VIDIOC_UNSUBSCRIBE_EVENT = 1075861083;

const int VIDIOC_CREATE_BUFS = 3238024796;

const int VIDIOC_PREPARE_BUF = 3227014749;

const int VIDIOC_G_SELECTION = 3225441886;

const int VIDIOC_S_SELECTION = 3225441887;

const int VIDIOC_DECODER_CMD = 3225966176;

const int VIDIOC_TRY_DECODER_CMD = 3225966177;

const int VIDIOC_ENUM_DV_TIMINGS = 3230946914;

const int VIDIOC_QUERY_DV_TIMINGS = 2156156515;

const int VIDIOC_DV_TIMINGS_CAP = 3230684772;

const int VIDIOC_ENUM_FREQ_BANDS = 3225441893;

const int VIDIOC_DBG_G_CHIP_INFO = 3234354790;

const int VIDIOC_QUERY_EXT_CTRL = 3236451943;

const int BASE_VIDIOC_PRIVATE = 192;

const int V4L2_PIX_FMT_HM12 = 842091848;

const int V4L2_PIX_FMT_SUNXI_TILED_NV12 = 842093651;

const int V4L2_CAP_ASYNCIO = 33554432;
