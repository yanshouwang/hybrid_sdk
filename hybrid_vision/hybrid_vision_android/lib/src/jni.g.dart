// ignore_for_file: use_super_parameters
// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

// Auto-generated initialization code.

final ffi.Pointer<T> Function<T extends ffi.NativeType>(String sym) jniLookup =
    ProtectedJniExtensions.initGeneratedLibrary("hybrid_vision_android");

/// from: android.graphics.Bitmap$CompressFormat
class Bitmap_CompressFormat extends jni.JObject {
  @override
  late final jni.JObjType<Bitmap_CompressFormat> $type = type;

  Bitmap_CompressFormat.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Bitmap_CompressFormatType();
  static final _get_JPEG =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_CompressFormat__JPEG")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$CompressFormat JPEG
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat get JPEG =>
      _get_JPEG().object(const $Bitmap_CompressFormatType());

  static final _get_PNG =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_CompressFormat__PNG")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$CompressFormat PNG
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat get PNG =>
      _get_PNG().object(const $Bitmap_CompressFormatType());

  static final _get_WEBP =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_CompressFormat__WEBP")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$CompressFormat WEBP
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat get WEBP =>
      _get_WEBP().object(const $Bitmap_CompressFormatType());

  static final _get_WEBP_LOSSY =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_CompressFormat__WEBP_LOSSY")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSY
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat get WEBP_LOSSY =>
      _get_WEBP_LOSSY().object(const $Bitmap_CompressFormatType());

  static final _get_WEBP_LOSSLESS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_CompressFormat__WEBP_LOSSLESS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSLESS
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat get WEBP_LOSSLESS =>
      _get_WEBP_LOSSLESS().object(const $Bitmap_CompressFormatType());

  static final _values =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Bitmap_CompressFormat__values")
          .asFunction<jni.JniResult Function()>();

  /// from: static public android.graphics.Bitmap$CompressFormat[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<Bitmap_CompressFormat> values() {
    return _values().object(const jni.JArrayType($Bitmap_CompressFormatType()));
  }

  static final _valueOf = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap_CompressFormat__valueOf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap$CompressFormat valueOf(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat valueOf(
    jni.JString string,
  ) {
    return _valueOf(string.reference.pointer)
        .object(const $Bitmap_CompressFormatType());
  }
}

final class $Bitmap_CompressFormatType
    extends jni.JObjType<Bitmap_CompressFormat> {
  const $Bitmap_CompressFormatType();

  @override
  String get signature => r"Landroid/graphics/Bitmap$CompressFormat;";

  @override
  Bitmap_CompressFormat fromReference(jni.JReference reference) =>
      Bitmap_CompressFormat.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Bitmap_CompressFormatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap_CompressFormatType) &&
        other is $Bitmap_CompressFormatType;
  }
}

/// from: android.graphics.Bitmap$Config
class Bitmap_Config extends jni.JObject {
  @override
  late final jni.JObjType<Bitmap_Config> $type = type;

  Bitmap_Config.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Bitmap_ConfigType();
  static final _get_ALPHA_8 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__ALPHA_8")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config ALPHA_8
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get ALPHA_8 =>
      _get_ALPHA_8().object(const $Bitmap_ConfigType());

  static final _get_RGB_565 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__RGB_565")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config RGB_565
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get RGB_565 =>
      _get_RGB_565().object(const $Bitmap_ConfigType());

  static final _get_ARGB_4444 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__ARGB_4444")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config ARGB_4444
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get ARGB_4444 =>
      _get_ARGB_4444().object(const $Bitmap_ConfigType());

  static final _get_ARGB_8888 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__ARGB_8888")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config ARGB_8888
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get ARGB_8888 =>
      _get_ARGB_8888().object(const $Bitmap_ConfigType());

  static final _get_RGBA_F16 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__RGBA_F16")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config RGBA_F16
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get RGBA_F16 =>
      _get_RGBA_F16().object(const $Bitmap_ConfigType());

  static final _get_HARDWARE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__HARDWARE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config HARDWARE
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get HARDWARE =>
      _get_HARDWARE().object(const $Bitmap_ConfigType());

  static final _get_RGBA_1010102 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__RGBA_1010102")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config RGBA_1010102
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get RGBA_1010102 =>
      _get_RGBA_1010102().object(const $Bitmap_ConfigType());

  static final _values =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Bitmap_Config__values")
          .asFunction<jni.JniResult Function()>();

  /// from: static public android.graphics.Bitmap$Config[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<Bitmap_Config> values() {
    return _values().object(const jni.JArrayType($Bitmap_ConfigType()));
  }

  static final _valueOf = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap_Config__valueOf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap$Config valueOf(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config valueOf(
    jni.JString string,
  ) {
    return _valueOf(string.reference.pointer)
        .object(const $Bitmap_ConfigType());
  }
}

final class $Bitmap_ConfigType extends jni.JObjType<Bitmap_Config> {
  const $Bitmap_ConfigType();

  @override
  String get signature => r"Landroid/graphics/Bitmap$Config;";

  @override
  Bitmap_Config fromReference(jni.JReference reference) =>
      Bitmap_Config.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Bitmap_ConfigType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap_ConfigType) &&
        other is $Bitmap_ConfigType;
  }
}

/// from: android.graphics.Bitmap
class Bitmap extends jni.JObject {
  @override
  late final jni.JObjType<Bitmap> $type = type;

  Bitmap.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $BitmapType();
  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _get_CREATOR().object(const jni.JObjectType());

  /// from: static public final int DENSITY_NONE
  static const DENSITY_NONE = 0;
  static final _getDensity = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getDensity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDensity()
  int getDensity() {
    return _getDensity(reference.pointer).integer;
  }

  static final _setDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__setDensity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setDensity(int i)
  void setDensity(
    int i,
  ) {
    _setDensity(reference.pointer, i).check();
  }

  static final _reconfigure = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Bitmap__reconfigure")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void reconfigure(int i, int i1, android.graphics.Bitmap$Config config)
  void reconfigure(
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    _reconfigure(reference.pointer, i, i1, config.reference.pointer).check();
  }

  static final _setWidth = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__setWidth")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setWidth(int i)
  void setWidth(
    int i,
  ) {
    _setWidth(reference.pointer, i).check();
  }

  static final _setHeight = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__setHeight")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHeight(int i)
  void setHeight(
    int i,
  ) {
    _setHeight(reference.pointer, i).check();
  }

  static final _setConfig = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__setConfig")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setConfig(android.graphics.Bitmap$Config config)
  void setConfig(
    Bitmap_Config config,
  ) {
    _setConfig(reference.pointer, config.reference.pointer).check();
  }

  static final _recycle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Bitmap__recycle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void recycle()
  void recycle() {
    _recycle(reference.pointer).check();
  }

  static final _isRecycled = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__isRecycled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRecycled()
  bool isRecycled() {
    return _isRecycled(reference.pointer).boolean;
  }

  static final _getGenerationId = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getGenerationId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getGenerationId()
  int getGenerationId() {
    return _getGenerationId(reference.pointer).integer;
  }

  static final _copyPixelsToBuffer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__copyPixelsToBuffer")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void copyPixelsToBuffer(java.nio.Buffer buffer)
  void copyPixelsToBuffer(
    jni.JBuffer buffer,
  ) {
    _copyPixelsToBuffer(reference.pointer, buffer.reference.pointer).check();
  }

  static final _copyPixelsFromBuffer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__copyPixelsFromBuffer")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void copyPixelsFromBuffer(java.nio.Buffer buffer)
  void copyPixelsFromBuffer(
    jni.JBuffer buffer,
  ) {
    _copyPixelsFromBuffer(reference.pointer, buffer.reference.pointer).check();
  }

  static final _copy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Bitmap__copy")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.Bitmap copy(android.graphics.Bitmap$Config config, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap copy(
    Bitmap_Config config,
    bool z,
  ) {
    return _copy(reference.pointer, config.reference.pointer, z ? 1 : 0)
        .object(const $BitmapType());
  }

  static final _asShared = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__asShared")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap asShared()
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap asShared() {
    return _asShared(reference.pointer).object(const $BitmapType());
  }

  static final _wrapHardwareBuffer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__wrapHardwareBuffer")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap wrapHardwareBuffer(android.hardware.HardwareBuffer hardwareBuffer, android.graphics.ColorSpace colorSpace)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap wrapHardwareBuffer(
    jni.JObject hardwareBuffer,
    jni.JObject colorSpace,
  ) {
    return _wrapHardwareBuffer(
            hardwareBuffer.reference.pointer, colorSpace.reference.pointer)
        .object(const $BitmapType());
  }

  static final _createScaledBitmap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Uint8)>>("Bitmap__createScaledBitmap")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: static public android.graphics.Bitmap createScaledBitmap(android.graphics.Bitmap bitmap, int i, int i1, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createScaledBitmap(
    Bitmap bitmap,
    int i,
    int i1,
    bool z,
  ) {
    return _createScaledBitmap(bitmap.reference.pointer, i, i1, z ? 1 : 0)
        .object(const $BitmapType());
  }

  static final _createBitmap = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__createBitmap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap(
    Bitmap bitmap,
  ) {
    return _createBitmap(bitmap.reference.pointer).object(const $BitmapType());
  }

  static final _createBitmap1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Bitmap__createBitmap1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap1(
    Bitmap bitmap,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _createBitmap1(bitmap.reference.pointer, i, i1, i2, i3)
        .object(const $BitmapType());
  }

  static final _createBitmap2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Bitmap__createBitmap2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3, android.graphics.Matrix matrix, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap2(
    Bitmap bitmap,
    int i,
    int i1,
    int i2,
    int i3,
    jni.JObject matrix,
    bool z,
  ) {
    return _createBitmap2(bitmap.reference.pointer, i, i1, i2, i3,
            matrix.reference.pointer, z ? 1 : 0)
        .object(const $BitmapType());
  }

  static final _createBitmap3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap3")
      .asFunction<jni.JniResult Function(int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap3(
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return _createBitmap3(i, i1, config.reference.pointer)
        .object(const $BitmapType());
  }

  static final _createBitmap4 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap4")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap4(
    jni.JObject displayMetrics,
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return _createBitmap4(
            displayMetrics.reference.pointer, i, i1, config.reference.pointer)
        .object(const $BitmapType());
  }

  static final _createBitmap5 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Int32,
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Bitmap__createBitmap5")
      .asFunction<
          jni.JniResult Function(int, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap5(
    int i,
    int i1,
    Bitmap_Config config,
    bool z,
  ) {
    return _createBitmap5(i, i1, config.reference.pointer, z ? 1 : 0)
        .object(const $BitmapType());
  }

  static final _createBitmap6 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap6")
      .asFunction<
          jni.JniResult Function(
              int, int, ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap6(
    int i,
    int i1,
    Bitmap_Config config,
    bool z,
    jni.JObject colorSpace,
  ) {
    return _createBitmap6(i, i1, config.reference.pointer, z ? 1 : 0,
            colorSpace.reference.pointer)
        .object(const $BitmapType());
  }

  static final _createBitmap7 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Bitmap__createBitmap7")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap7(
    jni.JObject displayMetrics,
    int i,
    int i1,
    Bitmap_Config config,
    bool z,
  ) {
    return _createBitmap7(displayMetrics.reference.pointer, i, i1,
            config.reference.pointer, z ? 1 : 0)
        .object(const $BitmapType());
  }

  static final _createBitmap8 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap8")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap8(
    jni.JObject displayMetrics,
    int i,
    int i1,
    Bitmap_Config config,
    bool z,
    jni.JObject colorSpace,
  ) {
    return _createBitmap8(displayMetrics.reference.pointer, i, i1,
            config.reference.pointer, z ? 1 : 0, colorSpace.reference.pointer)
        .object(const $BitmapType());
  }

  static final _createBitmap9 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap9")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap9(
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap_Config config,
  ) {
    return _createBitmap9(
            is0.reference.pointer, i, i1, i2, i3, config.reference.pointer)
        .object(const $BitmapType());
  }

  static final _createBitmap10 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap10")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap10(
    jni.JObject displayMetrics,
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap_Config config,
  ) {
    return _createBitmap10(displayMetrics.reference.pointer,
            is0.reference.pointer, i, i1, i2, i3, config.reference.pointer)
        .object(const $BitmapType());
  }

  static final _createBitmap11 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap11")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap11(
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return _createBitmap11(
            is0.reference.pointer, i, i1, config.reference.pointer)
        .object(const $BitmapType());
  }

  static final _createBitmap12 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap12")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap12(
    jni.JObject displayMetrics,
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return _createBitmap12(displayMetrics.reference.pointer,
            is0.reference.pointer, i, i1, config.reference.pointer)
        .object(const $BitmapType());
  }

  static final _createBitmap13 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__createBitmap13")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap13(
    jni.JObject picture,
  ) {
    return _createBitmap13(picture.reference.pointer)
        .object(const $BitmapType());
  }

  static final _createBitmap14 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap14")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture, int i, int i1, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap14(
    jni.JObject picture,
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return _createBitmap14(
            picture.reference.pointer, i, i1, config.reference.pointer)
        .object(const $BitmapType());
  }

  static final _getNinePatchChunk = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getNinePatchChunk")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] getNinePatchChunk()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getNinePatchChunk() {
    return _getNinePatchChunk(reference.pointer)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _compress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__compress")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean compress(android.graphics.Bitmap$CompressFormat compressFormat, int i, java.io.OutputStream outputStream)
  bool compress(
    Bitmap_CompressFormat compressFormat,
    int i,
    jni.JObject outputStream,
  ) {
    return _compress(reference.pointer, compressFormat.reference.pointer, i,
            outputStream.reference.pointer)
        .boolean;
  }

  static final _isMutable = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__isMutable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isMutable()
  bool isMutable() {
    return _isMutable(reference.pointer).boolean;
  }

  static final _isPremultiplied = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__isPremultiplied")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPremultiplied()
  bool isPremultiplied() {
    return _isPremultiplied(reference.pointer).boolean;
  }

  static final _setPremultiplied = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Bitmap__setPremultiplied")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPremultiplied(boolean z)
  void setPremultiplied(
    bool z,
  ) {
    _setPremultiplied(reference.pointer, z ? 1 : 0).check();
  }

  static final _getWidth = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getWidth")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getWidth()
  int getWidth() {
    return _getWidth(reference.pointer).integer;
  }

  static final _getHeight = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getHeight")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHeight()
  int getHeight() {
    return _getHeight(reference.pointer).integer;
  }

  static final _getScaledWidth = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__getScaledWidth")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getScaledWidth(android.graphics.Canvas canvas)
  int getScaledWidth(
    jni.JObject canvas,
  ) {
    return _getScaledWidth(reference.pointer, canvas.reference.pointer).integer;
  }

  static final _getScaledHeight = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__getScaledHeight")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getScaledHeight(android.graphics.Canvas canvas)
  int getScaledHeight(
    jni.JObject canvas,
  ) {
    return _getScaledHeight(reference.pointer, canvas.reference.pointer)
        .integer;
  }

  static final _getScaledWidth1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__getScaledWidth1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getScaledWidth(android.util.DisplayMetrics displayMetrics)
  int getScaledWidth1(
    jni.JObject displayMetrics,
  ) {
    return _getScaledWidth1(reference.pointer, displayMetrics.reference.pointer)
        .integer;
  }

  static final _getScaledHeight1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__getScaledHeight1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getScaledHeight(android.util.DisplayMetrics displayMetrics)
  int getScaledHeight1(
    jni.JObject displayMetrics,
  ) {
    return _getScaledHeight1(
            reference.pointer, displayMetrics.reference.pointer)
        .integer;
  }

  static final _getScaledWidth2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__getScaledWidth2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getScaledWidth(int i)
  int getScaledWidth2(
    int i,
  ) {
    return _getScaledWidth2(reference.pointer, i).integer;
  }

  static final _getScaledHeight2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Bitmap__getScaledHeight2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getScaledHeight(int i)
  int getScaledHeight2(
    int i,
  ) {
    return _getScaledHeight2(reference.pointer, i).integer;
  }

  static final _getRowBytes = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getRowBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRowBytes()
  int getRowBytes() {
    return _getRowBytes(reference.pointer).integer;
  }

  static final _getByteCount = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getByteCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getByteCount()
  int getByteCount() {
    return _getByteCount(reference.pointer).integer;
  }

  static final _getAllocationByteCount = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getAllocationByteCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getAllocationByteCount()
  int getAllocationByteCount() {
    return _getAllocationByteCount(reference.pointer).integer;
  }

  static final _getConfig = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getConfig")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap$Config getConfig()
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap_Config getConfig() {
    return _getConfig(reference.pointer).object(const $Bitmap_ConfigType());
  }

  static final _hasAlpha = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__hasAlpha")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasAlpha()
  bool hasAlpha() {
    return _hasAlpha(reference.pointer).boolean;
  }

  static final _setHasAlpha = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Bitmap__setHasAlpha")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHasAlpha(boolean z)
  void setHasAlpha(
    bool z,
  ) {
    _setHasAlpha(reference.pointer, z ? 1 : 0).check();
  }

  static final _hasMipMap = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__hasMipMap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasMipMap()
  bool hasMipMap() {
    return _hasMipMap(reference.pointer).boolean;
  }

  static final _setHasMipMap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Bitmap__setHasMipMap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHasMipMap(boolean z)
  void setHasMipMap(
    bool z,
  ) {
    _setHasMipMap(reference.pointer, z ? 1 : 0).check();
  }

  static final _getColorSpace = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getColorSpace")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.ColorSpace getColorSpace()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getColorSpace() {
    return _getColorSpace(reference.pointer).object(const jni.JObjectType());
  }

  static final _setColorSpace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__setColorSpace")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setColorSpace(android.graphics.ColorSpace colorSpace)
  void setColorSpace(
    jni.JObject colorSpace,
  ) {
    _setColorSpace(reference.pointer, colorSpace.reference.pointer).check();
  }

  static final _hasGainmap = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__hasGainmap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasGainmap()
  bool hasGainmap() {
    return _hasGainmap(reference.pointer).boolean;
  }

  static final _getGainmap = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getGainmap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Gainmap getGainmap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getGainmap() {
    return _getGainmap(reference.pointer).object(const jni.JObjectType());
  }

  static final _setGainmap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__setGainmap")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setGainmap(android.graphics.Gainmap gainmap)
  void setGainmap(
    jni.JObject gainmap,
  ) {
    _setGainmap(reference.pointer, gainmap.reference.pointer).check();
  }

  static final _eraseColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__eraseColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void eraseColor(int i)
  void eraseColor(
    int i,
  ) {
    _eraseColor(reference.pointer, i).check();
  }

  static final _eraseColor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int64)>>("Bitmap__eraseColor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void eraseColor(long j)
  void eraseColor1(
    int j,
  ) {
    _eraseColor1(reference.pointer, j).check();
  }

  static final _getPixel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Bitmap__getPixel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getPixel(int i, int i1)
  int getPixel(
    int i,
    int i1,
  ) {
    return _getPixel(reference.pointer, i, i1).integer;
  }

  static final _getColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Bitmap__getColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.graphics.Color getColor(int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getColor(
    int i,
    int i1,
  ) {
    return _getColor(reference.pointer, i, i1).object(const jni.JObjectType());
  }

  static final _getPixels = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("Bitmap__getPixels")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, int, int, int, int, int)>();

  /// from: public void getPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)
  void getPixels(
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    _getPixels(reference.pointer, is0.reference.pointer, i, i1, i2, i3, i4, i5)
        .check();
  }

  static final _setPixel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32)>>("Bitmap__setPixel")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void setPixel(int i, int i1, int i2)
  void setPixel(
    int i,
    int i1,
    int i2,
  ) {
    _setPixel(reference.pointer, i, i1, i2).check();
  }

  static final _setPixels = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("Bitmap__setPixels")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, int, int, int, int, int)>();

  /// from: public void setPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)
  void setPixels(
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    _setPixels(reference.pointer, is0.reference.pointer, i, i1, i2, i3, i4, i5)
        .check();
  }

  static final _describeContents = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    return _describeContents(reference.pointer).integer;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _writeToParcel(reference.pointer, parcel.reference.pointer, i).check();
  }

  static final _extractAlpha = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__extractAlpha")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap extractAlpha()
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap extractAlpha() {
    return _extractAlpha(reference.pointer).object(const $BitmapType());
  }

  static final _extractAlpha1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__extractAlpha1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap extractAlpha(android.graphics.Paint paint, int[] is)
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap extractAlpha1(
    jni.JObject paint,
    jni.JArray<jni.jint> is0,
  ) {
    return _extractAlpha1(
            reference.pointer, paint.reference.pointer, is0.reference.pointer)
        .object(const $BitmapType());
  }

  static final _sameAs = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__sameAs")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean sameAs(android.graphics.Bitmap bitmap)
  bool sameAs(
    Bitmap bitmap,
  ) {
    return _sameAs(reference.pointer, bitmap.reference.pointer).boolean;
  }

  static final _prepareToDraw = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__prepareToDraw")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void prepareToDraw()
  void prepareToDraw() {
    _prepareToDraw(reference.pointer).check();
  }

  static final _getHardwareBuffer = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getHardwareBuffer")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.hardware.HardwareBuffer getHardwareBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHardwareBuffer() {
    return _getHardwareBuffer(reference.pointer)
        .object(const jni.JObjectType());
  }
}

final class $BitmapType extends jni.JObjType<Bitmap> {
  const $BitmapType();

  @override
  String get signature => r"Landroid/graphics/Bitmap;";

  @override
  Bitmap fromReference(jni.JReference reference) =>
      Bitmap.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BitmapType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapType) && other is $BitmapType;
  }
}

/// from: android.graphics.BitmapFactory$Options
class BitmapFactory_Options extends jni.JObject {
  @override
  late final jni.JObjType<BitmapFactory_Options> $type = type;

  BitmapFactory_Options.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $BitmapFactory_OptionsType();
  static final _get_inBitmap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inBitmap")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inBitmap = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__inBitmap")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap inBitmap
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap get inBitmap =>
      _get_inBitmap(reference.pointer).object(const $BitmapType());

  /// from: public android.graphics.Bitmap inBitmap
  /// The returned object must be released after use, by calling the [release] method.
  set inBitmap(Bitmap value) =>
      _set_inBitmap(reference.pointer, value.reference.pointer).check();

  static final _get_inDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inDensity")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__inDensity")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int inDensity
  int get inDensity => _get_inDensity(reference.pointer).integer;

  /// from: public int inDensity
  set inDensity(int value) => _set_inDensity(reference.pointer, value).check();

  static final _get_inDither = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inDither")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inDither = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inDither")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inDither
  bool get inDither => _get_inDither(reference.pointer).boolean;

  /// from: public boolean inDither
  set inDither(bool value) =>
      _set_inDither(reference.pointer, value ? 1 : 0).check();

  static final _get_inInputShareable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inInputShareable")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inInputShareable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inInputShareable")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inInputShareable
  bool get inInputShareable => _get_inInputShareable(reference.pointer).boolean;

  /// from: public boolean inInputShareable
  set inInputShareable(bool value) =>
      _set_inInputShareable(reference.pointer, value ? 1 : 0).check();

  static final _get_inJustDecodeBounds = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inJustDecodeBounds")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inJustDecodeBounds = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inJustDecodeBounds")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inJustDecodeBounds
  bool get inJustDecodeBounds =>
      _get_inJustDecodeBounds(reference.pointer).boolean;

  /// from: public boolean inJustDecodeBounds
  set inJustDecodeBounds(bool value) =>
      _set_inJustDecodeBounds(reference.pointer, value ? 1 : 0).check();

  static final _get_inMutable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inMutable")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inMutable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inMutable")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inMutable
  bool get inMutable => _get_inMutable(reference.pointer).boolean;

  /// from: public boolean inMutable
  set inMutable(bool value) =>
      _set_inMutable(reference.pointer, value ? 1 : 0).check();

  static final _get_inPreferQualityOverSpeed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inPreferQualityOverSpeed")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inPreferQualityOverSpeed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(jni.JObjectPtr, ffi.Uint8)>>(
          "set_BitmapFactory_Options__inPreferQualityOverSpeed")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inPreferQualityOverSpeed
  bool get inPreferQualityOverSpeed =>
      _get_inPreferQualityOverSpeed(reference.pointer).boolean;

  /// from: public boolean inPreferQualityOverSpeed
  set inPreferQualityOverSpeed(bool value) =>
      _set_inPreferQualityOverSpeed(reference.pointer, value ? 1 : 0).check();

  static final _get_inPreferredColorSpace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inPreferredColorSpace")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inPreferredColorSpace = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__inPreferredColorSpace")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.ColorSpace inPreferredColorSpace
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get inPreferredColorSpace =>
      _get_inPreferredColorSpace(reference.pointer)
          .object(const jni.JObjectType());

  /// from: public android.graphics.ColorSpace inPreferredColorSpace
  /// The returned object must be released after use, by calling the [release] method.
  set inPreferredColorSpace(jni.JObject value) =>
      _set_inPreferredColorSpace(reference.pointer, value.reference.pointer)
          .check();

  static final _get_inPreferredConfig = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inPreferredConfig")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inPreferredConfig = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__inPreferredConfig")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap$Config inPreferredConfig
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap_Config get inPreferredConfig =>
      _get_inPreferredConfig(reference.pointer)
          .object(const $Bitmap_ConfigType());

  /// from: public android.graphics.Bitmap$Config inPreferredConfig
  /// The returned object must be released after use, by calling the [release] method.
  set inPreferredConfig(Bitmap_Config value) =>
      _set_inPreferredConfig(reference.pointer, value.reference.pointer)
          .check();

  static final _get_inPremultiplied = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inPremultiplied")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inPremultiplied = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inPremultiplied")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inPremultiplied
  bool get inPremultiplied => _get_inPremultiplied(reference.pointer).boolean;

  /// from: public boolean inPremultiplied
  set inPremultiplied(bool value) =>
      _set_inPremultiplied(reference.pointer, value ? 1 : 0).check();

  static final _get_inPurgeable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inPurgeable")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inPurgeable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inPurgeable")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inPurgeable
  bool get inPurgeable => _get_inPurgeable(reference.pointer).boolean;

  /// from: public boolean inPurgeable
  set inPurgeable(bool value) =>
      _set_inPurgeable(reference.pointer, value ? 1 : 0).check();

  static final _get_inSampleSize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inSampleSize")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inSampleSize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__inSampleSize")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int inSampleSize
  int get inSampleSize => _get_inSampleSize(reference.pointer).integer;

  /// from: public int inSampleSize
  set inSampleSize(int value) =>
      _set_inSampleSize(reference.pointer, value).check();

  static final _get_inScaled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inScaled")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inScaled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inScaled")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inScaled
  bool get inScaled => _get_inScaled(reference.pointer).boolean;

  /// from: public boolean inScaled
  set inScaled(bool value) =>
      _set_inScaled(reference.pointer, value ? 1 : 0).check();

  static final _get_inScreenDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inScreenDensity")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inScreenDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__inScreenDensity")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int inScreenDensity
  int get inScreenDensity => _get_inScreenDensity(reference.pointer).integer;

  /// from: public int inScreenDensity
  set inScreenDensity(int value) =>
      _set_inScreenDensity(reference.pointer, value).check();

  static final _get_inTargetDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inTargetDensity")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inTargetDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__inTargetDensity")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int inTargetDensity
  int get inTargetDensity => _get_inTargetDensity(reference.pointer).integer;

  /// from: public int inTargetDensity
  set inTargetDensity(int value) =>
      _set_inTargetDensity(reference.pointer, value).check();

  static final _get_inTempStorage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inTempStorage")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inTempStorage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__inTempStorage")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] inTempStorage
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> get inTempStorage =>
      _get_inTempStorage(reference.pointer)
          .object(const jni.JArrayType(jni.jbyteType()));

  /// from: public byte[] inTempStorage
  /// The returned object must be released after use, by calling the [release] method.
  set inTempStorage(jni.JArray<jni.jbyte> value) =>
      _set_inTempStorage(reference.pointer, value.reference.pointer).check();

  static final _get_mCancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__mCancel")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_mCancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__mCancel")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean mCancel
  bool get mCancel => _get_mCancel(reference.pointer).boolean;

  /// from: public boolean mCancel
  set mCancel(bool value) =>
      _set_mCancel(reference.pointer, value ? 1 : 0).check();

  static final _get_outColorSpace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__outColorSpace")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_outColorSpace = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__outColorSpace")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.ColorSpace outColorSpace
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get outColorSpace =>
      _get_outColorSpace(reference.pointer).object(const jni.JObjectType());

  /// from: public android.graphics.ColorSpace outColorSpace
  /// The returned object must be released after use, by calling the [release] method.
  set outColorSpace(jni.JObject value) =>
      _set_outColorSpace(reference.pointer, value.reference.pointer).check();

  static final _get_outConfig = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__outConfig")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_outConfig = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__outConfig")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap$Config outConfig
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap_Config get outConfig =>
      _get_outConfig(reference.pointer).object(const $Bitmap_ConfigType());

  /// from: public android.graphics.Bitmap$Config outConfig
  /// The returned object must be released after use, by calling the [release] method.
  set outConfig(Bitmap_Config value) =>
      _set_outConfig(reference.pointer, value.reference.pointer).check();

  static final _get_outHeight = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__outHeight")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_outHeight = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__outHeight")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int outHeight
  int get outHeight => _get_outHeight(reference.pointer).integer;

  /// from: public int outHeight
  set outHeight(int value) => _set_outHeight(reference.pointer, value).check();

  static final _get_outMimeType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__outMimeType")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_outMimeType = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__outMimeType")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String outMimeType
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString get outMimeType =>
      _get_outMimeType(reference.pointer).object(const jni.JStringType());

  /// from: public java.lang.String outMimeType
  /// The returned object must be released after use, by calling the [release] method.
  set outMimeType(jni.JString value) =>
      _set_outMimeType(reference.pointer, value.reference.pointer).check();

  static final _get_outWidth = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__outWidth")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_outWidth = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__outWidth")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int outWidth
  int get outWidth => _get_outWidth(reference.pointer).integer;

  /// from: public int outWidth
  set outWidth(int value) => _set_outWidth(reference.pointer, value).check();

  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "BitmapFactory_Options__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory BitmapFactory_Options() {
    return BitmapFactory_Options.fromReference(_new0().reference);
  }

  static final _requestCancelDecode = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory_Options__requestCancelDecode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void requestCancelDecode()
  void requestCancelDecode() {
    _requestCancelDecode(reference.pointer).check();
  }
}

final class $BitmapFactory_OptionsType
    extends jni.JObjType<BitmapFactory_Options> {
  const $BitmapFactory_OptionsType();

  @override
  String get signature => r"Landroid/graphics/BitmapFactory$Options;";

  @override
  BitmapFactory_Options fromReference(jni.JReference reference) =>
      BitmapFactory_Options.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BitmapFactory_OptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactory_OptionsType) &&
        other is $BitmapFactory_OptionsType;
  }
}

/// from: android.graphics.BitmapFactory
class BitmapFactory extends jni.JObject {
  @override
  late final jni.JObjType<BitmapFactory> $type = type;

  BitmapFactory.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $BitmapFactoryType();
  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "BitmapFactory__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory BitmapFactory() {
    return BitmapFactory.fromReference(_new0().reference);
  }

  static final _decodeFile = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("BitmapFactory__decodeFile")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeFile(java.lang.String string, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeFile(
    jni.JString string,
    BitmapFactory_Options options,
  ) {
    return _decodeFile(string.reference.pointer, options.reference.pointer)
        .object(const $BitmapType());
  }

  static final _decodeFile1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory__decodeFile1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeFile(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeFile1(
    jni.JString string,
  ) {
    return _decodeFile1(string.reference.pointer).object(const $BitmapType());
  }

  static final _decodeResourceStream = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory__decodeResourceStream")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeResourceStream(android.content.res.Resources resources, android.util.TypedValue typedValue, java.io.InputStream inputStream, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeResourceStream(
    jni.JObject resources,
    jni.JObject typedValue,
    jni.JObject inputStream,
    Rect rect,
    BitmapFactory_Options options,
  ) {
    return _decodeResourceStream(
            resources.reference.pointer,
            typedValue.reference.pointer,
            inputStream.reference.pointer,
            rect.reference.pointer,
            options.reference.pointer)
        .object(const $BitmapType());
  }

  static final _decodeResource = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("BitmapFactory__decodeResource")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeResource(android.content.res.Resources resources, int i, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeResource(
    jni.JObject resources,
    int i,
    BitmapFactory_Options options,
  ) {
    return _decodeResource(
            resources.reference.pointer, i, options.reference.pointer)
        .object(const $BitmapType());
  }

  static final _decodeResource1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("BitmapFactory__decodeResource1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.graphics.Bitmap decodeResource(android.content.res.Resources resources, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeResource1(
    jni.JObject resources,
    int i,
  ) {
    return _decodeResource1(resources.reference.pointer, i)
        .object(const $BitmapType());
  }

  static final _decodeByteArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("BitmapFactory__decodeByteArray")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeByteArray(byte[] bs, int i, int i1, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeByteArray(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    BitmapFactory_Options options,
  ) {
    return _decodeByteArray(
            bs.reference.pointer, i, i1, options.reference.pointer)
        .object(const $BitmapType());
  }

  static final _decodeByteArray1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("BitmapFactory__decodeByteArray1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public android.graphics.Bitmap decodeByteArray(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeByteArray1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return _decodeByteArray1(bs.reference.pointer, i, i1)
        .object(const $BitmapType());
  }

  static final _decodeStream = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("BitmapFactory__decodeStream")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeStream(java.io.InputStream inputStream, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeStream(
    jni.JObject inputStream,
    Rect rect,
    BitmapFactory_Options options,
  ) {
    return _decodeStream(inputStream.reference.pointer, rect.reference.pointer,
            options.reference.pointer)
        .object(const $BitmapType());
  }

  static final _decodeStream1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory__decodeStream1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeStream(java.io.InputStream inputStream)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeStream1(
    jni.JObject inputStream,
  ) {
    return _decodeStream1(inputStream.reference.pointer)
        .object(const $BitmapType());
  }

  static final _decodeFileDescriptor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory__decodeFileDescriptor")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeFileDescriptor(java.io.FileDescriptor fileDescriptor, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeFileDescriptor(
    jni.JObject fileDescriptor,
    Rect rect,
    BitmapFactory_Options options,
  ) {
    return _decodeFileDescriptor(fileDescriptor.reference.pointer,
            rect.reference.pointer, options.reference.pointer)
        .object(const $BitmapType());
  }

  static final _decodeFileDescriptor1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory__decodeFileDescriptor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeFileDescriptor(java.io.FileDescriptor fileDescriptor)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeFileDescriptor1(
    jni.JObject fileDescriptor,
  ) {
    return _decodeFileDescriptor1(fileDescriptor.reference.pointer)
        .object(const $BitmapType());
  }
}

final class $BitmapFactoryType extends jni.JObjType<BitmapFactory> {
  const $BitmapFactoryType();

  @override
  String get signature => r"Landroid/graphics/BitmapFactory;";

  @override
  BitmapFactory fromReference(jni.JReference reference) =>
      BitmapFactory.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BitmapFactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactoryType) &&
        other is $BitmapFactoryType;
  }
}

/// from: android.graphics.Point
class Point extends jni.JObject {
  @override
  late final jni.JObjType<Point> $type = type;

  Point.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $PointType();
  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Point__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _get_CREATOR().object(const jni.JObjectType());

  static final _get_x = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Point__x")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_x = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Point__x")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int x
  int get x => _get_x(reference.pointer).integer;

  /// from: public int x
  set x(int value) => _set_x(reference.pointer, value).check();

  static final _get_y = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Point__y")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_y = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Point__y")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int y
  int get y => _get_y(reference.pointer).integer;

  /// from: public int y
  set y(int value) => _set_y(reference.pointer, value).check();

  static final _new0 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Point__new0")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Point() {
    return Point.fromReference(_new0().reference);
  }

  static final _new1 = jniLookup<
              ffi.NativeFunction<jni.JniResult Function(ffi.Int32, ffi.Int32)>>(
          "Point__new1")
      .asFunction<jni.JniResult Function(int, int)>();

  /// from: public void <init>(int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Point.new1(
    int i,
    int i1,
  ) {
    return Point.fromReference(_new1(i, i1).reference);
  }

  static final _new2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Point__new2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.Point point)
  /// The returned object must be released after use, by calling the [release] method.
  factory Point.new2(
    Point point,
  ) {
    return Point.fromReference(_new2(point.reference.pointer).reference);
  }

  static final _set0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>("Point__set0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void set(int i, int i1)
  void set0(
    int i,
    int i1,
  ) {
    _set0(reference.pointer, i, i1).check();
  }

  static final _negate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Point__negate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void negate()
  void negate() {
    _negate(reference.pointer).check();
  }

  static final _offset = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Point__offset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final void offset(int i, int i1)
  void offset(
    int i,
    int i1,
  ) {
    _offset(reference.pointer, i, i1).check();
  }

  static final _equals = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Point__equals")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final boolean equals(int i, int i1)
  bool equals(
    int i,
    int i1,
  ) {
    return _equals(reference.pointer, i, i1).boolean;
  }

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Point__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return _equals1(reference.pointer, object.reference.pointer).boolean;
  }

  static final _hashCode1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Point__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer).integer;
  }

  static final _toString1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Point__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer).object(const jni.JStringType());
  }

  static final _describeContents = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Point__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    return _describeContents(reference.pointer).integer;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Point__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _writeToParcel(reference.pointer, parcel.reference.pointer, i).check();
  }

  static final _readFromParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Point__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel parcel)
  void readFromParcel(
    jni.JObject parcel,
  ) {
    _readFromParcel(reference.pointer, parcel.reference.pointer).check();
  }
}

final class $PointType extends jni.JObjType<Point> {
  const $PointType();

  @override
  String get signature => r"Landroid/graphics/Point;";

  @override
  Point fromReference(jni.JReference reference) =>
      Point.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PointType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PointType) && other is $PointType;
  }
}

/// from: android.graphics.Rect
class Rect extends jni.JObject {
  @override
  late final jni.JObjType<Rect> $type = type;

  Rect.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $RectType();
  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Rect__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _get_CREATOR().object(const jni.JObjectType());

  static final _get_bottom = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Rect__bottom")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_bottom = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Rect__bottom")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int bottom
  int get bottom => _get_bottom(reference.pointer).integer;

  /// from: public int bottom
  set bottom(int value) => _set_bottom(reference.pointer, value).check();

  static final _get_left = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Rect__left")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_left = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Rect__left")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int left
  int get left => _get_left(reference.pointer).integer;

  /// from: public int left
  set left(int value) => _set_left(reference.pointer, value).check();

  static final _get_right = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Rect__right")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_right = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Rect__right")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int right
  int get right => _get_right(reference.pointer).integer;

  /// from: public int right
  set right(int value) => _set_right(reference.pointer, value).check();

  static final _get_top = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Rect__top")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_top = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Rect__top")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int top
  int get top => _get_top(reference.pointer).integer;

  /// from: public int top
  set top(int value) => _set_top(reference.pointer, value).check();

  static final _new0 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Rect__new0")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Rect() {
    return Rect.fromReference(_new0().reference);
  }

  static final _new1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__new1")
      .asFunction<jni.JniResult Function(int, int, int, int)>();

  /// from: public void <init>(int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  factory Rect.new1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return Rect.fromReference(_new1(i, i1, i2, i3).reference);
  }

  static final _new2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__new2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.Rect rect)
  /// The returned object must be released after use, by calling the [release] method.
  factory Rect.new2(
    Rect rect,
  ) {
    return Rect.fromReference(_new2(rect.reference.pointer).reference);
  }

  static final _equals = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__equals")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, object.reference.pointer).boolean;
  }

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer).integer;
  }

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer).object(const jni.JStringType());
  }

  static final _toShortString = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__toShortString")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toShortString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toShortString() {
    return _toShortString(reference.pointer).object(const jni.JStringType());
  }

  static final _flattenToString = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__flattenToString")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String flattenToString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString flattenToString() {
    return _flattenToString(reference.pointer).object(const jni.JStringType());
  }

  static final _unflattenFromString = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__unflattenFromString")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Rect unflattenFromString(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Rect unflattenFromString(
    jni.JString string,
  ) {
    return _unflattenFromString(string.reference.pointer)
        .object(const $RectType());
  }

  static final _isEmpty = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__isEmpty")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEmpty()
  bool isEmpty() {
    return _isEmpty(reference.pointer).boolean;
  }

  static final _width = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__width")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int width()
  int width() {
    return _width(reference.pointer).integer;
  }

  static final _height = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__height")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int height()
  int height() {
    return _height(reference.pointer).integer;
  }

  static final _centerX = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__centerX")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int centerX()
  int centerX() {
    return _centerX(reference.pointer).integer;
  }

  static final _centerY = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__centerY")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int centerY()
  int centerY() {
    return _centerY(reference.pointer).integer;
  }

  static final _exactCenterX = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__exactCenterX")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float exactCenterX()
  double exactCenterX() {
    return _exactCenterX(reference.pointer).float;
  }

  static final _exactCenterY = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__exactCenterY")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float exactCenterY()
  double exactCenterY() {
    return _exactCenterY(reference.pointer).float;
  }

  static final _setEmpty = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__setEmpty")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void setEmpty()
  void setEmpty() {
    _setEmpty(reference.pointer).check();
  }

  static final _set0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__set0")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public void set(int i, int i1, int i2, int i3)
  void set0(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _set0(reference.pointer, i, i1, i2, i3).check();
  }

  static final _set1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Rect__set1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void set(android.graphics.Rect rect)
  void set1(
    Rect rect,
  ) {
    _set1(reference.pointer, rect.reference.pointer).check();
  }

  static final _offset = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>("Rect__offset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void offset(int i, int i1)
  void offset(
    int i,
    int i1,
  ) {
    _offset(reference.pointer, i, i1).check();
  }

  static final _offsetTo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Rect__offsetTo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void offsetTo(int i, int i1)
  void offsetTo(
    int i,
    int i1,
  ) {
    _offsetTo(reference.pointer, i, i1).check();
  }

  static final _inset = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>("Rect__inset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void inset(int i, int i1)
  void inset(
    int i,
    int i1,
  ) {
    _inset(reference.pointer, i, i1).check();
  }

  static final _inset1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__inset1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void inset(android.graphics.Insets insets)
  void inset1(
    jni.JObject insets,
  ) {
    _inset1(reference.pointer, insets.reference.pointer).check();
  }

  static final _inset2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__inset2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public void inset(int i, int i1, int i2, int i3)
  void inset2(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _inset2(reference.pointer, i, i1, i2, i3).check();
  }

  static final _contains = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Rect__contains")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public boolean contains(int i, int i1)
  bool contains(
    int i,
    int i1,
  ) {
    return _contains(reference.pointer, i, i1).boolean;
  }

  static final _contains1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__contains1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public boolean contains(int i, int i1, int i2, int i3)
  bool contains1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _contains1(reference.pointer, i, i1, i2, i3).boolean;
  }

  static final _contains2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__contains2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean contains(android.graphics.Rect rect)
  bool contains2(
    Rect rect,
  ) {
    return _contains2(reference.pointer, rect.reference.pointer).boolean;
  }

  static final _intersect = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__intersect")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public boolean intersect(int i, int i1, int i2, int i3)
  bool intersect(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _intersect(reference.pointer, i, i1, i2, i3).boolean;
  }

  static final _intersect1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__intersect1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean intersect(android.graphics.Rect rect)
  bool intersect1(
    Rect rect,
  ) {
    return _intersect1(reference.pointer, rect.reference.pointer).boolean;
  }

  static final _setIntersect = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__setIntersect")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean setIntersect(android.graphics.Rect rect, android.graphics.Rect rect1)
  bool setIntersect(
    Rect rect,
    Rect rect1,
  ) {
    return _setIntersect(
            reference.pointer, rect.reference.pointer, rect1.reference.pointer)
        .boolean;
  }

  static final _intersects = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__intersects")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public boolean intersects(int i, int i1, int i2, int i3)
  bool intersects(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _intersects(reference.pointer, i, i1, i2, i3).boolean;
  }

  static final _intersects1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__intersects1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean intersects(android.graphics.Rect rect, android.graphics.Rect rect1)
  static bool intersects1(
    Rect rect,
    Rect rect1,
  ) {
    return _intersects1(rect.reference.pointer, rect1.reference.pointer)
        .boolean;
  }

  static final _union = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__union")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public void union(int i, int i1, int i2, int i3)
  void union(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    _union(reference.pointer, i, i1, i2, i3).check();
  }

  static final _union1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__union1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void union(android.graphics.Rect rect)
  void union1(
    Rect rect,
  ) {
    _union1(reference.pointer, rect.reference.pointer).check();
  }

  static final _union2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>("Rect__union2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void union(int i, int i1)
  void union2(
    int i,
    int i1,
  ) {
    _union2(reference.pointer, i, i1).check();
  }

  static final _sort = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__sort")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void sort()
  void sort() {
    _sort(reference.pointer).check();
  }

  static final _describeContents = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    return _describeContents(reference.pointer).integer;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Rect__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _writeToParcel(reference.pointer, parcel.reference.pointer, i).check();
  }

  static final _readFromParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel parcel)
  void readFromParcel(
    jni.JObject parcel,
  ) {
    _readFromParcel(reference.pointer, parcel.reference.pointer).check();
  }
}

final class $RectType extends jni.JObjType<Rect> {
  const $RectType();

  @override
  String get signature => r"Landroid/graphics/Rect;";

  @override
  Rect fromReference(jni.JReference reference) => Rect.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RectType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RectType) && other is $RectType;
  }
}

/// from: android.net.Uri$Builder
class Uri_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Uri_Builder> $type = type;

  Uri_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Uri_BuilderType();
  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Uri_Builder__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Uri_Builder() {
    return Uri_Builder.fromReference(_new0().reference);
  }

  static final _scheme = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__scheme")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder scheme(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder scheme(
    jni.JString string,
  ) {
    return _scheme(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _opaquePart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__opaquePart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder opaquePart(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder opaquePart(
    jni.JString string,
  ) {
    return _opaquePart(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _encodedOpaquePart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__encodedOpaquePart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedOpaquePart(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedOpaquePart(
    jni.JString string,
  ) {
    return _encodedOpaquePart(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _authority = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__authority")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder authority(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder authority(
    jni.JString string,
  ) {
    return _authority(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _encodedAuthority = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__encodedAuthority")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedAuthority(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedAuthority(
    jni.JString string,
  ) {
    return _encodedAuthority(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _path = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__path")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder path(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder path(
    jni.JString string,
  ) {
    return _path(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _encodedPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__encodedPath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedPath(
    jni.JString string,
  ) {
    return _encodedPath(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _appendPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__appendPath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder appendPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder appendPath(
    jni.JString string,
  ) {
    return _appendPath(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _appendEncodedPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__appendEncodedPath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder appendEncodedPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder appendEncodedPath(
    jni.JString string,
  ) {
    return _appendEncodedPath(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _query = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__query")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder query(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder query(
    jni.JString string,
  ) {
    return _query(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _encodedQuery = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__encodedQuery")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedQuery(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedQuery(
    jni.JString string,
  ) {
    return _encodedQuery(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _fragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__fragment")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder fragment(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder fragment(
    jni.JString string,
  ) {
    return _fragment(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _encodedFragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__encodedFragment")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedFragment(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedFragment(
    jni.JString string,
  ) {
    return _encodedFragment(reference.pointer, string.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _appendQueryParameter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__appendQueryParameter")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder appendQueryParameter(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder appendQueryParameter(
    jni.JString string,
    jni.JString string1,
  ) {
    return _appendQueryParameter(reference.pointer, string.reference.pointer,
            string1.reference.pointer)
        .object(const $Uri_BuilderType());
  }

  static final _clearQuery = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri_Builder__clearQuery")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder clearQuery()
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder clearQuery() {
    return _clearQuery(reference.pointer).object(const $Uri_BuilderType());
  }

  static final _build = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri build()
  /// The returned object must be released after use, by calling the [release] method.
  Uri build() {
    return _build(reference.pointer).object(const $UriType());
  }

  static final _toString1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri_Builder__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer).object(const jni.JStringType());
  }
}

final class $Uri_BuilderType extends jni.JObjType<Uri_Builder> {
  const $Uri_BuilderType();

  @override
  String get signature => r"Landroid/net/Uri$Builder;";

  @override
  Uri_Builder fromReference(jni.JReference reference) =>
      Uri_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Uri_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Uri_BuilderType) && other is $Uri_BuilderType;
  }
}

/// from: android.net.Uri
class Uri extends jni.JObject {
  @override
  late final jni.JObjType<Uri> $type = type;

  Uri.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $UriType();
  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Uri__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _get_CREATOR().object(const jni.JObjectType());

  static final _get_EMPTY =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Uri__EMPTY")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.net.Uri EMPTY
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EMPTY => _get_EMPTY().object(const $UriType());

  static final _isHierarchical = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__isHierarchical")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isHierarchical()
  bool isHierarchical() {
    return _isHierarchical(reference.pointer).boolean;
  }

  static final _isOpaque = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__isOpaque")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isOpaque()
  bool isOpaque() {
    return _isOpaque(reference.pointer).boolean;
  }

  static final _isRelative = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__isRelative")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isRelative()
  bool isRelative() {
    return _isRelative(reference.pointer).boolean;
  }

  static final _isAbsolute = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__isAbsolute")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAbsolute()
  bool isAbsolute() {
    return _isAbsolute(reference.pointer).boolean;
  }

  static final _getScheme = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__getScheme")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getScheme()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getScheme() {
    return _getScheme(reference.pointer).object(const jni.JStringType());
  }

  static final _getSchemeSpecificPart = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getSchemeSpecificPart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getSchemeSpecificPart()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSchemeSpecificPart() {
    return _getSchemeSpecificPart(reference.pointer)
        .object(const jni.JStringType());
  }

  static final _getEncodedSchemeSpecificPart = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedSchemeSpecificPart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedSchemeSpecificPart()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedSchemeSpecificPart() {
    return _getEncodedSchemeSpecificPart(reference.pointer)
        .object(const jni.JStringType());
  }

  static final _getAuthority = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getAuthority")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getAuthority()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAuthority() {
    return _getAuthority(reference.pointer).object(const jni.JStringType());
  }

  static final _getEncodedAuthority = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedAuthority")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedAuthority()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedAuthority() {
    return _getEncodedAuthority(reference.pointer)
        .object(const jni.JStringType());
  }

  static final _getUserInfo = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getUserInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getUserInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUserInfo() {
    return _getUserInfo(reference.pointer).object(const jni.JStringType());
  }

  static final _getEncodedUserInfo = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedUserInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedUserInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedUserInfo() {
    return _getEncodedUserInfo(reference.pointer)
        .object(const jni.JStringType());
  }

  static final _getHost = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__getHost")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getHost()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getHost() {
    return _getHost(reference.pointer).object(const jni.JStringType());
  }

  static final _getPort = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__getPort")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getPort()
  int getPort() {
    return _getPort(reference.pointer).integer;
  }

  static final _getPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__getPath")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPath() {
    return _getPath(reference.pointer).object(const jni.JStringType());
  }

  static final _getEncodedPath = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedPath")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedPath() {
    return _getEncodedPath(reference.pointer).object(const jni.JStringType());
  }

  static final _getQuery = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__getQuery")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getQuery()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getQuery() {
    return _getQuery(reference.pointer).object(const jni.JStringType());
  }

  static final _getEncodedQuery = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedQuery")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedQuery()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedQuery() {
    return _getEncodedQuery(reference.pointer).object(const jni.JStringType());
  }

  static final _getFragment = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getFragment")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getFragment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFragment() {
    return _getFragment(reference.pointer).object(const jni.JStringType());
  }

  static final _getEncodedFragment = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedFragment")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedFragment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedFragment() {
    return _getEncodedFragment(reference.pointer)
        .object(const jni.JStringType());
  }

  static final _getPathSegments = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getPathSegments")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.util.List getPathSegments()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getPathSegments() {
    return _getPathSegments(reference.pointer)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _getLastPathSegment = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getLastPathSegment")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getLastPathSegment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLastPathSegment() {
    return _getLastPathSegment(reference.pointer)
        .object(const jni.JStringType());
  }

  static final _equals = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Uri__equals")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, object.reference.pointer).boolean;
  }

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer).integer;
  }

  static final _compareTo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__compareTo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(android.net.Uri uri)
  int compareTo(
    Uri uri,
  ) {
    return _compareTo(reference.pointer, uri.reference.pointer).integer;
  }

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer).object(const jni.JStringType());
  }

  static final _buildUpon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__buildUpon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.net.Uri$Builder buildUpon()
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder buildUpon() {
    return _buildUpon(reference.pointer).object(const $Uri_BuilderType());
  }

  static final _parse = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__parse")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri parse(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri parse(
    jni.JString string,
  ) {
    return _parse(string.reference.pointer).object(const $UriType());
  }

  static final _fromFile = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__fromFile")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri fromFile(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri fromFile(
    jni.JObject file,
  ) {
    return _fromFile(file.reference.pointer).object(const $UriType());
  }

  static final _fromParts = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__fromParts")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri fromParts(java.lang.String string, java.lang.String string1, java.lang.String string2)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri fromParts(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    return _fromParts(string.reference.pointer, string1.reference.pointer,
            string2.reference.pointer)
        .object(const $UriType());
  }

  static final _getQueryParameterNames = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getQueryParameterNames")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set getQueryParameterNames()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JString> getQueryParameterNames() {
    return _getQueryParameterNames(reference.pointer)
        .object(const jni.JSetType(jni.JStringType()));
  }

  static final _getQueryParameters = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__getQueryParameters")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getQueryParameters(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getQueryParameters(
    jni.JString string,
  ) {
    return _getQueryParameters(reference.pointer, string.reference.pointer)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _getQueryParameter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__getQueryParameter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getQueryParameter(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getQueryParameter(
    jni.JString string,
  ) {
    return _getQueryParameter(reference.pointer, string.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _getBooleanQueryParameter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Uri__getBooleanQueryParameter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean getBooleanQueryParameter(java.lang.String string, boolean z)
  bool getBooleanQueryParameter(
    jni.JString string,
    bool z,
  ) {
    return _getBooleanQueryParameter(
            reference.pointer, string.reference.pointer, z ? 1 : 0)
        .boolean;
  }

  static final _normalizeScheme = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__normalizeScheme")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri normalizeScheme()
  /// The returned object must be released after use, by calling the [release] method.
  Uri normalizeScheme() {
    return _normalizeScheme(reference.pointer).object(const $UriType());
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void writeToParcel(android.os.Parcel parcel, android.net.Uri uri)
  static void writeToParcel(
    jni.JObject parcel,
    Uri uri,
  ) {
    _writeToParcel(parcel.reference.pointer, uri.reference.pointer).check();
  }

  static final _encode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__encode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String encode(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString encode(
    jni.JString string,
  ) {
    return _encode(string.reference.pointer).object(const jni.JStringType());
  }

  static final _encode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__encode1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String encode(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString encode1(
    jni.JString string,
    jni.JString string1,
  ) {
    return _encode1(string.reference.pointer, string1.reference.pointer)
        .object(const jni.JStringType());
  }

  static final _decode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__decode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String decode(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString decode(
    jni.JString string,
  ) {
    return _decode(string.reference.pointer).object(const jni.JStringType());
  }

  static final _withAppendedPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__withAppendedPath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri withAppendedPath(android.net.Uri uri, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri withAppendedPath(
    Uri uri,
    jni.JString string,
  ) {
    return _withAppendedPath(uri.reference.pointer, string.reference.pointer)
        .object(const $UriType());
  }

  static final _compareTo1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__compareTo1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(java.lang.Object object)
  int compareTo1(
    jni.JObject object,
  ) {
    return _compareTo1(reference.pointer, object.reference.pointer).integer;
  }
}

final class $UriType extends jni.JObjType<Uri> {
  const $UriType();

  @override
  String get signature => r"Landroid/net/Uri;";

  @override
  Uri fromReference(jni.JReference reference) => Uri.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UriType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($UriType) && other is $UriType;
  }
}

/// from: com.google.android.gms.tasks.Task
class Task<$TResult extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<Task<$TResult>> $type = type(TResult);

  final jni.JObjType<$TResult> TResult;

  Task.fromReference(
    this.TResult,
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static $TaskType<$TResult> type<$TResult extends jni.JObject>(
    jni.JObjType<$TResult> TResult,
  ) {
    return $TaskType(
      TResult,
    );
  }

  static final _addOnCanceledListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCanceledListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCanceledListener(com.google.android.gms.tasks.OnCanceledListener onCanceledListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCanceledListener(
    OnCanceledListener onCanceledListener,
  ) {
    return _addOnCanceledListener(
            reference.pointer, onCanceledListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnCanceledListener1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCanceledListener1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCanceledListener(android.app.Activity activity, com.google.android.gms.tasks.OnCanceledListener onCanceledListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCanceledListener1(
    jni.JObject activity,
    OnCanceledListener onCanceledListener,
  ) {
    return _addOnCanceledListener1(reference.pointer,
            activity.reference.pointer, onCanceledListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnCanceledListener2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCanceledListener2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCanceledListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnCanceledListener onCanceledListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCanceledListener2(
    Executor executor,
    OnCanceledListener onCanceledListener,
  ) {
    return _addOnCanceledListener2(reference.pointer,
            executor.reference.pointer, onCanceledListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnCompleteListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCompleteListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCompleteListener(com.google.android.gms.tasks.OnCompleteListener onCompleteListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCompleteListener(
    OnCompleteListener<$TResult> onCompleteListener,
  ) {
    return _addOnCompleteListener(
            reference.pointer, onCompleteListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnCompleteListener1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCompleteListener1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCompleteListener(android.app.Activity activity, com.google.android.gms.tasks.OnCompleteListener onCompleteListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCompleteListener1(
    jni.JObject activity,
    OnCompleteListener<$TResult> onCompleteListener,
  ) {
    return _addOnCompleteListener1(reference.pointer,
            activity.reference.pointer, onCompleteListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnCompleteListener2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCompleteListener2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCompleteListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnCompleteListener onCompleteListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCompleteListener2(
    Executor executor,
    OnCompleteListener<$TResult> onCompleteListener,
  ) {
    return _addOnCompleteListener2(reference.pointer,
            executor.reference.pointer, onCompleteListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnFailureListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnFailureListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnFailureListener(com.google.android.gms.tasks.OnFailureListener onFailureListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnFailureListener(
    OnFailureListener onFailureListener,
  ) {
    return _addOnFailureListener(
            reference.pointer, onFailureListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnFailureListener1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnFailureListener1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnFailureListener(android.app.Activity activity, com.google.android.gms.tasks.OnFailureListener onFailureListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnFailureListener1(
    jni.JObject activity,
    OnFailureListener onFailureListener,
  ) {
    return _addOnFailureListener1(reference.pointer, activity.reference.pointer,
            onFailureListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnFailureListener2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnFailureListener2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnFailureListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnFailureListener onFailureListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnFailureListener2(
    Executor executor,
    OnFailureListener onFailureListener,
  ) {
    return _addOnFailureListener2(reference.pointer, executor.reference.pointer,
            onFailureListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnSuccessListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnSuccessListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnSuccessListener(com.google.android.gms.tasks.OnSuccessListener onSuccessListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnSuccessListener(
    OnSuccessListener<$TResult> onSuccessListener,
  ) {
    return _addOnSuccessListener(
            reference.pointer, onSuccessListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnSuccessListener1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnSuccessListener1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnSuccessListener(android.app.Activity activity, com.google.android.gms.tasks.OnSuccessListener onSuccessListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnSuccessListener1(
    jni.JObject activity,
    OnSuccessListener<$TResult> onSuccessListener,
  ) {
    return _addOnSuccessListener1(reference.pointer, activity.reference.pointer,
            onSuccessListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _addOnSuccessListener2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnSuccessListener2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnSuccessListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnSuccessListener onSuccessListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnSuccessListener2(
    Executor executor,
    OnSuccessListener<$TResult> onSuccessListener,
  ) {
    return _addOnSuccessListener2(reference.pointer, executor.reference.pointer,
            onSuccessListener.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _continueWith = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__continueWith")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWith(com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWith<$TContinuationResult extends jni.JObject>(
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _continueWith(reference.pointer, continuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _continueWith1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__continueWith1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWith(java.util.concurrent.Executor executor, com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWith1<$TContinuationResult extends jni.JObject>(
    Executor executor,
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _continueWith1(reference.pointer, executor.reference.pointer,
            continuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _continueWithTask = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__continueWithTask")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWithTask(com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWithTask<$TContinuationResult extends jni.JObject>(
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _continueWithTask(reference.pointer, continuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _continueWithTask1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__continueWithTask1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWithTask(java.util.concurrent.Executor executor, com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWithTask1<$TContinuationResult extends jni.JObject>(
    Executor executor,
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _continueWithTask1(reference.pointer, executor.reference.pointer,
            continuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _onSuccessTask = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__onSuccessTask")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task onSuccessTask(com.google.android.gms.tasks.SuccessContinuation successContinuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      onSuccessTask<$TContinuationResult extends jni.JObject>(
    jni.JObject successContinuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _onSuccessTask(
            reference.pointer, successContinuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _onSuccessTask1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__onSuccessTask1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task onSuccessTask(java.util.concurrent.Executor executor, com.google.android.gms.tasks.SuccessContinuation successContinuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      onSuccessTask1<$TContinuationResult extends jni.JObject>(
    Executor executor,
    jni.JObject successContinuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return _onSuccessTask1(reference.pointer, executor.reference.pointer,
            successContinuation.reference.pointer)
        .object($TaskType(TContinuationResult));
  }

  static final _getException = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Task__getException")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.Exception getException()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getException() {
    return _getException(reference.pointer).object(const jni.JObjectType());
  }

  static final _getResult = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Task__getResult")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract TResult getResult()
  /// The returned object must be released after use, by calling the [release] method.
  $TResult getResult() {
    return _getResult(reference.pointer).object(TResult);
  }

  static final _getResult1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__getResult1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract TResult getResult(java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  $TResult getResult1<$X extends jni.JObject>(
    jni.JObject class0, {
    required jni.JObjType<$X> X,
  }) {
    return _getResult1(reference.pointer, class0.reference.pointer)
        .object(TResult);
  }

  static final _new0 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Task__new0")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Task({
    required jni.JObjType<$TResult> TResult,
  }) {
    return Task.fromReference(TResult, _new0().reference);
  }

  static final _isCanceled = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Task__isCanceled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isCanceled()
  bool isCanceled() {
    return _isCanceled(reference.pointer).boolean;
  }

  static final _isComplete = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Task__isComplete")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isComplete()
  bool isComplete() {
    return _isComplete(reference.pointer).boolean;
  }

  static final _isSuccessful = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Task__isSuccessful")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isSuccessful()
  bool isSuccessful() {
    return _isSuccessful(reference.pointer).boolean;
  }
}

final class $TaskType<$TResult extends jni.JObject>
    extends jni.JObjType<Task<$TResult>> {
  final jni.JObjType<$TResult> TResult;

  const $TaskType(
    this.TResult,
  );

  @override
  String get signature => r"Lcom/google/android/gms/tasks/Task;";

  @override
  Task<$TResult> fromReference(jni.JReference reference) =>
      Task.fromReference(TResult, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($TaskType, TResult);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($TaskType<$TResult>) &&
        other is $TaskType<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: com.google.android.gms.tasks.Tasks
class Tasks extends jni.JObject {
  @override
  late final jni.JObjType<Tasks> $type = type;

  Tasks.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $TasksType();
  static final _call = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Tasks__call")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task call(java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$TResult> call<$TResult extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$TResult> TResult,
  }) {
    return _call(callable.reference.pointer).object($TaskType(TResult));
  }

  static final _call1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Tasks__call1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task call(java.util.concurrent.Executor executor, java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$TResult> call1<$TResult extends jni.JObject>(
    Executor executor,
    jni.JObject callable, {
    required jni.JObjType<$TResult> TResult,
  }) {
    return _call1(executor.reference.pointer, callable.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _forCanceled =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Tasks__forCanceled")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.google.android.gms.tasks.Task forCanceled()
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$TResult> forCanceled<$TResult extends jni.JObject>({
    required jni.JObjType<$TResult> TResult,
  }) {
    return _forCanceled().object($TaskType(TResult));
  }

  static final _forException = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__forException")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task forException(java.lang.Exception exception)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$TResult> forException<$TResult extends jni.JObject>(
    jni.JObject exception, {
    required jni.JObjType<$TResult> TResult,
  }) {
    return _forException(exception.reference.pointer)
        .object($TaskType(TResult));
  }

  static final _forResult = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__forResult")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task forResult(TResult object)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$TResult> forResult<$TResult extends jni.JObject>(
    $TResult object, {
    jni.JObjType<$TResult>? TResult,
  }) {
    TResult ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$TResult>;
    return _forResult(object.reference.pointer).object($TaskType(TResult));
  }

  static final _whenAll = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Tasks__whenAll")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAll(java.util.Collection collection)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JObject> whenAll(
    jni.JObject collection,
  ) {
    return _whenAll(collection.reference.pointer)
        .object(const $TaskType(jni.JObjectType()));
  }

  static final _whenAll1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Tasks__whenAll1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAll(java.lang.Object[] tasks)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JObject> whenAll1(
    jni.JArray<Task<jni.JObject>> tasks,
  ) {
    return _whenAll1(tasks.reference.pointer)
        .object(const $TaskType(jni.JObjectType()));
  }

  static final _whenAllComplete = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__whenAllComplete")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAllComplete(java.util.Collection collection)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JList<Task<jni.JObject>>> whenAllComplete(
    jni.JObject collection,
  ) {
    return _whenAllComplete(collection.reference.pointer)
        .object(const $TaskType(jni.JListType($TaskType(jni.JObjectType()))));
  }

  static final _whenAllComplete1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__whenAllComplete1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAllComplete(java.lang.Object[] tasks)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JList<Task<jni.JObject>>> whenAllComplete1(
    jni.JArray<Task<jni.JObject>> tasks,
  ) {
    return _whenAllComplete1(tasks.reference.pointer)
        .object(const $TaskType(jni.JListType($TaskType(jni.JObjectType()))));
  }

  static final _whenAllSuccess = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__whenAllSuccess")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAllSuccess(java.util.Collection collection)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JList<$TResult>> whenAllSuccess<$TResult extends jni.JObject>(
    jni.JObject collection, {
    required jni.JObjType<$TResult> TResult,
  }) {
    return _whenAllSuccess(collection.reference.pointer)
        .object($TaskType(jni.JListType(TResult)));
  }

  static final _whenAllSuccess1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__whenAllSuccess1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAllSuccess(java.lang.Object[] tasks)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JList<$TResult>>
      whenAllSuccess1<$TResult extends jni.JObject>(
    jni.JArray<Task<jni.JObject>> tasks, {
    required jni.JObjType<$TResult> TResult,
  }) {
    return _whenAllSuccess1(tasks.reference.pointer)
        .object($TaskType(jni.JListType(TResult)));
  }

  static final _withTimeout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("Tasks__withTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task withTimeout(com.google.android.gms.tasks.Task task, long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$T> withTimeout<$T extends jni.JObject>(
    Task<$T> task,
    int j,
    jni.JObject timeUnit, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      (task.$type as $TaskType).TResult,
    ]) as jni.JObjType<$T>;
    return _withTimeout(task.reference.pointer, j, timeUnit.reference.pointer)
        .object($TaskType(T));
  }

  static final _await0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Tasks__await0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public TResult await(com.google.android.gms.tasks.Task task)
  /// The returned object must be released after use, by calling the [release] method.
  static $TResult await0<$TResult extends jni.JObject>(
    Task<$TResult> task, {
    jni.JObjType<$TResult>? TResult,
  }) {
    TResult ??= jni.lowestCommonSuperType([
      (task.$type as $TaskType).TResult,
    ]) as jni.JObjType<$TResult>;
    return _await0(task.reference.pointer).object(TResult);
  }

  static final _await1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("Tasks__await1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public TResult await(com.google.android.gms.tasks.Task task, long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  static $TResult await1<$TResult extends jni.JObject>(
    Task<$TResult> task,
    int j,
    jni.JObject timeUnit, {
    jni.JObjType<$TResult>? TResult,
  }) {
    TResult ??= jni.lowestCommonSuperType([
      (task.$type as $TaskType).TResult,
    ]) as jni.JObjType<$TResult>;
    return _await1(task.reference.pointer, j, timeUnit.reference.pointer)
        .object(TResult);
  }
}

final class $TasksType extends jni.JObjType<Tasks> {
  const $TasksType();

  @override
  String get signature => r"Lcom/google/android/gms/tasks/Tasks;";

  @override
  Tasks fromReference(jni.JReference reference) =>
      Tasks.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($TasksType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($TasksType) && other is $TasksType;
  }
}

/// from: com.google.android.gms.tasks.OnCompleteListener
class OnCompleteListener<$TResult extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<OnCompleteListener<$TResult>> $type = type(TResult);

  final jni.JObjType<$TResult> TResult;

  OnCompleteListener.fromReference(
    this.TResult,
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static $OnCompleteListenerType<$TResult> type<$TResult extends jni.JObject>(
    jni.JObjType<$TResult> TResult,
  ) {
    return $OnCompleteListenerType(
      TResult,
    );
  }

  static final _onComplete = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OnCompleteListener__onComplete")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onComplete(com.google.android.gms.tasks.Task task)
  void onComplete(
    Task<$TResult> task,
  ) {
    _onComplete(reference.pointer, task.reference.pointer).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnCompleteListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onComplete(Lcom/google/android/gms/tasks/Task;)V") {
        _$impls[$p]!.onComplete(
          $a[0].castTo($TaskType(_$impls[$p]!.TResult), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory OnCompleteListener.implement(
    $OnCompleteListenerImpl<$TResult> $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnCompleteListener.fromReference(
      $impl.TResult,
      ProtectedJniExtensions.newPortProxy(
        r"com.google.android.gms.tasks.OnCompleteListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OnCompleteListenerImpl<$TResult extends jni.JObject> {
  factory $OnCompleteListenerImpl({
    required jni.JObjType<$TResult> TResult,
    required void Function(Task<$TResult> task) onComplete,
  }) = _$OnCompleteListenerImpl;

  jni.JObjType<$TResult> get TResult;

  void onComplete(Task<$TResult> task);
}

class _$OnCompleteListenerImpl<$TResult extends jni.JObject>
    implements $OnCompleteListenerImpl<$TResult> {
  _$OnCompleteListenerImpl({
    required this.TResult,
    required void Function(Task<$TResult> task) onComplete,
  }) : _onComplete = onComplete;

  @override
  final jni.JObjType<$TResult> TResult;

  final void Function(Task<$TResult> task) _onComplete;

  void onComplete(Task<$TResult> task) {
    return _onComplete(task);
  }
}

final class $OnCompleteListenerType<$TResult extends jni.JObject>
    extends jni.JObjType<OnCompleteListener<$TResult>> {
  final jni.JObjType<$TResult> TResult;

  const $OnCompleteListenerType(
    this.TResult,
  );

  @override
  String get signature => r"Lcom/google/android/gms/tasks/OnCompleteListener;";

  @override
  OnCompleteListener<$TResult> fromReference(jni.JReference reference) =>
      OnCompleteListener.fromReference(TResult, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($OnCompleteListenerType, TResult);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnCompleteListenerType<$TResult>) &&
        other is $OnCompleteListenerType<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: com.google.android.gms.tasks.OnSuccessListener
class OnSuccessListener<$TResult extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<OnSuccessListener<$TResult>> $type = type(TResult);

  final jni.JObjType<$TResult> TResult;

  OnSuccessListener.fromReference(
    this.TResult,
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static $OnSuccessListenerType<$TResult> type<$TResult extends jni.JObject>(
    jni.JObjType<$TResult> TResult,
  ) {
    return $OnSuccessListenerType(
      TResult,
    );
  }

  static final _onSuccess = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OnSuccessListener__onSuccess")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onSuccess(TResult object)
  void onSuccess(
    $TResult object,
  ) {
    _onSuccess(reference.pointer, object.reference.pointer).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnSuccessListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onSuccess(Ljava/lang/Object;)V") {
        _$impls[$p]!.onSuccess(
          $a[0].castTo(_$impls[$p]!.TResult, releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory OnSuccessListener.implement(
    $OnSuccessListenerImpl<$TResult> $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnSuccessListener.fromReference(
      $impl.TResult,
      ProtectedJniExtensions.newPortProxy(
        r"com.google.android.gms.tasks.OnSuccessListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OnSuccessListenerImpl<$TResult extends jni.JObject> {
  factory $OnSuccessListenerImpl({
    required jni.JObjType<$TResult> TResult,
    required void Function($TResult object) onSuccess,
  }) = _$OnSuccessListenerImpl;

  jni.JObjType<$TResult> get TResult;

  void onSuccess($TResult object);
}

class _$OnSuccessListenerImpl<$TResult extends jni.JObject>
    implements $OnSuccessListenerImpl<$TResult> {
  _$OnSuccessListenerImpl({
    required this.TResult,
    required void Function($TResult object) onSuccess,
  }) : _onSuccess = onSuccess;

  @override
  final jni.JObjType<$TResult> TResult;

  final void Function($TResult object) _onSuccess;

  void onSuccess($TResult object) {
    return _onSuccess(object);
  }
}

final class $OnSuccessListenerType<$TResult extends jni.JObject>
    extends jni.JObjType<OnSuccessListener<$TResult>> {
  final jni.JObjType<$TResult> TResult;

  const $OnSuccessListenerType(
    this.TResult,
  );

  @override
  String get signature => r"Lcom/google/android/gms/tasks/OnSuccessListener;";

  @override
  OnSuccessListener<$TResult> fromReference(jni.JReference reference) =>
      OnSuccessListener.fromReference(TResult, reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($OnSuccessListenerType, TResult);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnSuccessListenerType<$TResult>) &&
        other is $OnSuccessListenerType<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: com.google.android.gms.tasks.OnFailureListener
class OnFailureListener extends jni.JObject {
  @override
  late final jni.JObjType<OnFailureListener> $type = type;

  OnFailureListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $OnFailureListenerType();
  static final _onFailure = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OnFailureListener__onFailure")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onFailure(java.lang.Exception exception)
  void onFailure(
    jni.JObject exception,
  ) {
    _onFailure(reference.pointer, exception.reference.pointer).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnFailureListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onFailure(Ljava/lang/Exception;)V") {
        _$impls[$p]!.onFailure(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory OnFailureListener.implement(
    $OnFailureListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnFailureListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.android.gms.tasks.OnFailureListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OnFailureListenerImpl {
  factory $OnFailureListenerImpl({
    required void Function(jni.JObject exception) onFailure,
  }) = _$OnFailureListenerImpl;

  void onFailure(jni.JObject exception);
}

class _$OnFailureListenerImpl implements $OnFailureListenerImpl {
  _$OnFailureListenerImpl({
    required void Function(jni.JObject exception) onFailure,
  }) : _onFailure = onFailure;

  final void Function(jni.JObject exception) _onFailure;

  void onFailure(jni.JObject exception) {
    return _onFailure(exception);
  }
}

final class $OnFailureListenerType extends jni.JObjType<OnFailureListener> {
  const $OnFailureListenerType();

  @override
  String get signature => r"Lcom/google/android/gms/tasks/OnFailureListener;";

  @override
  OnFailureListener fromReference(jni.JReference reference) =>
      OnFailureListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OnFailureListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnFailureListenerType) &&
        other is $OnFailureListenerType;
  }
}

/// from: com.google.android.gms.tasks.OnCanceledListener
class OnCanceledListener extends jni.JObject {
  @override
  late final jni.JObjType<OnCanceledListener> $type = type;

  OnCanceledListener.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $OnCanceledListenerType();
  static final _onCanceled = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OnCanceledListener__onCanceled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onCanceled()
  void onCanceled() {
    _onCanceled(reference.pointer).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnCanceledListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onCanceled()V") {
        _$impls[$p]!.onCanceled();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory OnCanceledListener.implement(
    $OnCanceledListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnCanceledListener.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.android.gms.tasks.OnCanceledListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $OnCanceledListenerImpl {
  factory $OnCanceledListenerImpl({
    required void Function() onCanceled,
  }) = _$OnCanceledListenerImpl;

  void onCanceled();
}

class _$OnCanceledListenerImpl implements $OnCanceledListenerImpl {
  _$OnCanceledListenerImpl({
    required void Function() onCanceled,
  }) : _onCanceled = onCanceled;

  final void Function() _onCanceled;

  void onCanceled() {
    return _onCanceled();
  }
}

final class $OnCanceledListenerType extends jni.JObjType<OnCanceledListener> {
  const $OnCanceledListenerType();

  @override
  String get signature => r"Lcom/google/android/gms/tasks/OnCanceledListener;";

  @override
  OnCanceledListener fromReference(jni.JReference reference) =>
      OnCanceledListener.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OnCanceledListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnCanceledListenerType) &&
        other is $OnCanceledListenerType;
  }
}

/// from: com.google.mlkit.vision.common.InputImage$ImageFormat
class InputImage_ImageFormat extends jni.JObject {
  @override
  late final jni.JObjType<InputImage_ImageFormat> $type = type;

  InputImage_ImageFormat.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $InputImage_ImageFormatType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $InputImage_ImageFormatImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory InputImage_ImageFormat.implement(
    $InputImage_ImageFormatImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = InputImage_ImageFormat.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.common.InputImage$ImageFormat",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $InputImage_ImageFormatImpl {
  factory $InputImage_ImageFormatImpl() = _$InputImage_ImageFormatImpl;
}

class _$InputImage_ImageFormatImpl implements $InputImage_ImageFormatImpl {
  _$InputImage_ImageFormatImpl();
}

final class $InputImage_ImageFormatType
    extends jni.JObjType<InputImage_ImageFormat> {
  const $InputImage_ImageFormatType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/common/InputImage$ImageFormat;";

  @override
  InputImage_ImageFormat fromReference(jni.JReference reference) =>
      InputImage_ImageFormat.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($InputImage_ImageFormatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($InputImage_ImageFormatType) &&
        other is $InputImage_ImageFormatType;
  }
}

/// from: com.google.mlkit.vision.common.InputImage
class InputImage extends jni.JObject {
  @override
  late final jni.JObjType<InputImage> $type = type;

  InputImage.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $InputImageType();

  /// from: static public final int IMAGE_FORMAT_NV21
  static const IMAGE_FORMAT_NV21 = 17;

  /// from: static public final int IMAGE_FORMAT_YV12
  static const IMAGE_FORMAT_YV12 = 842094169;

  /// from: static public final int IMAGE_FORMAT_BITMAP
  static const IMAGE_FORMAT_BITMAP = -1;

  /// from: static public final int IMAGE_FORMAT_YUV_420_888
  static const IMAGE_FORMAT_YUV_420_888 = 35;
  static final _getFormat = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getFormat")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getFormat()
  int getFormat() {
    return _getFormat(reference.pointer).integer;
  }

  static final _getHeight = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getHeight")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHeight()
  int getHeight() {
    return _getHeight(reference.pointer).integer;
  }

  static final _getRotationDegrees = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getRotationDegrees")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRotationDegrees()
  int getRotationDegrees() {
    return _getRotationDegrees(reference.pointer).integer;
  }

  static final _getWidth = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getWidth")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getWidth()
  int getWidth() {
    return _getWidth(reference.pointer).integer;
  }

  static final _getBitmapInternal = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getBitmapInternal")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap getBitmapInternal()
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap getBitmapInternal() {
    return _getBitmapInternal(reference.pointer).object(const $BitmapType());
  }

  static final _getCoordinatesMatrix = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getCoordinatesMatrix")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Matrix getCoordinatesMatrix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCoordinatesMatrix() {
    return _getCoordinatesMatrix(reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _getMediaImage = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getMediaImage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.media.Image getMediaImage()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getMediaImage() {
    return _getMediaImage(reference.pointer).object(const jni.JObjectType());
  }

  static final _fromBitmap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("InputImage__fromBitmap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromBitmap(android.graphics.Bitmap bitmap, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromBitmap(
    Bitmap bitmap,
    int i,
  ) {
    return _fromBitmap(bitmap.reference.pointer, i)
        .object(const $InputImageType());
  }

  static final _fromByteArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("InputImage__fromByteArray")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromByteArray(byte[] bs, int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromByteArray(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _fromByteArray(bs.reference.pointer, i, i1, i2, i3)
        .object(const $InputImageType());
  }

  static final _fromByteBuffer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("InputImage__fromByteBuffer")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromByteBuffer(java.nio.ByteBuffer byteBuffer, int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromByteBuffer(
    jni.JByteBuffer byteBuffer,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _fromByteBuffer(byteBuffer.reference.pointer, i, i1, i2, i3)
        .object(const $InputImageType());
  }

  static final _fromFilePath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("InputImage__fromFilePath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromFilePath(android.content.Context context, android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromFilePath(
    jni.JObject context,
    Uri uri,
  ) {
    return _fromFilePath(context.reference.pointer, uri.reference.pointer)
        .object(const $InputImageType());
  }

  static final _fromMediaImage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("InputImage__fromMediaImage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromMediaImage(android.media.Image image, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromMediaImage(
    jni.JObject image,
    int i,
  ) {
    return _fromMediaImage(image.reference.pointer, i)
        .object(const $InputImageType());
  }

  static final _fromMediaImage1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("InputImage__fromMediaImage1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromMediaImage(android.media.Image image, int i, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromMediaImage1(
    jni.JObject image,
    int i,
    jni.JObject matrix,
  ) {
    return _fromMediaImage1(
            image.reference.pointer, i, matrix.reference.pointer)
        .object(const $InputImageType());
  }

  static final _getByteBuffer = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getByteBuffer")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.nio.ByteBuffer getByteBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JByteBuffer getByteBuffer() {
    return _getByteBuffer(reference.pointer)
        .object(const jni.JByteBufferType());
  }

  static final _getPlanes = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getPlanes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.media.Image$Plane[] getPlanes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> getPlanes() {
    return _getPlanes(reference.pointer)
        .object(const jni.JArrayType(jni.JObjectType()));
  }
}

final class $InputImageType extends jni.JObjType<InputImage> {
  const $InputImageType();

  @override
  String get signature => r"Lcom/google/mlkit/vision/common/InputImage;";

  @override
  InputImage fromReference(jni.JReference reference) =>
      InputImage.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($InputImageType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($InputImageType) && other is $InputImageType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScanner
class BarcodeScanner extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScanner> $type = type;

  BarcodeScanner.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScannerType();
  static final _process = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("BarcodeScanner__process")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(com.google.android.odml.image.MlImage mlImage)
  /// The returned object must be released after use, by calling the [release] method.
  Task<jni.JList<Barcode>> process(
    jni.JObject mlImage,
  ) {
    return _process(reference.pointer, mlImage.reference.pointer)
        .object(const $TaskType(jni.JListType($BarcodeType())));
  }

  static final _process1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("BarcodeScanner__process1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(com.google.mlkit.vision.common.InputImage inputImage)
  /// The returned object must be released after use, by calling the [release] method.
  Task<jni.JList<Barcode>> process1(
    InputImage inputImage,
  ) {
    return _process1(reference.pointer, inputImage.reference.pointer)
        .object(const $TaskType(jni.JListType($BarcodeType())));
  }

  static final _close = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScanner__close")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void close()
  void close() {
    _close(reference.pointer).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $BarcodeScannerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"process(Lcom/google/android/odml/image/MlImage;)Lcom/google/android/gms/tasks/Task;") {
        final $r = _$impls[$p]!.process(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d ==
          r"process(Lcom/google/mlkit/vision/common/InputImage;)Lcom/google/android/gms/tasks/Task;") {
        final $r = _$impls[$p]!.process1(
          $a[0].castTo(const $InputImageType(), releaseOriginal: true),
        );
        return ($r as jni.JObject)
            .castTo(const jni.JObjectType())
            .reference
            .toPointer();
      }
      if ($d == r"close()V") {
        _$impls[$p]!.close();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory BarcodeScanner.implement(
    $BarcodeScannerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = BarcodeScanner.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.BarcodeScanner",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $BarcodeScannerImpl {
  factory $BarcodeScannerImpl({
    required Task<jni.JList<Barcode>> Function(jni.JObject mlImage) process,
    required Task<jni.JList<Barcode>> Function(InputImage inputImage) process1,
    required void Function() close,
  }) = _$BarcodeScannerImpl;

  Task<jni.JList<Barcode>> process(jni.JObject mlImage);
  Task<jni.JList<Barcode>> process1(InputImage inputImage);
  void close();
}

class _$BarcodeScannerImpl implements $BarcodeScannerImpl {
  _$BarcodeScannerImpl({
    required Task<jni.JList<Barcode>> Function(jni.JObject mlImage) process,
    required Task<jni.JList<Barcode>> Function(InputImage inputImage) process1,
    required void Function() close,
  })  : _process = process,
        _process1 = process1,
        _close = close;

  final Task<jni.JList<Barcode>> Function(jni.JObject mlImage) _process;
  final Task<jni.JList<Barcode>> Function(InputImage inputImage) _process1;
  final void Function() _close;

  Task<jni.JList<Barcode>> process(jni.JObject mlImage) {
    return _process(mlImage);
  }

  Task<jni.JList<Barcode>> process1(InputImage inputImage) {
    return _process1(inputImage);
  }

  void close() {
    return _close();
  }
}

final class $BarcodeScannerType extends jni.JObjType<BarcodeScanner> {
  const $BarcodeScannerType();

  @override
  String get signature => r"Lcom/google/mlkit/vision/barcode/BarcodeScanner;";

  @override
  BarcodeScanner fromReference(jni.JReference reference) =>
      BarcodeScanner.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScannerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScannerType) &&
        other is $BarcodeScannerType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder
class BarcodeScannerOptions_Builder extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScannerOptions_Builder> $type = type;

  BarcodeScannerOptions_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScannerOptions_BuilderType();
  static final _enableAllPotentialBarcodes = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions_Builder__enableAllPotentialBarcodes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder enableAllPotentialBarcodes()
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder enableAllPotentialBarcodes() {
    return _enableAllPotentialBarcodes(reference.pointer)
        .object(const $BarcodeScannerOptions_BuilderType());
  }

  static final _setBarcodeFormats = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions_Builder__setBarcodeFormats")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder setBarcodeFormats(int i, int[] is)
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder setBarcodeFormats(
    int i,
    jni.JArray<jni.jint> is0,
  ) {
    return _setBarcodeFormats(reference.pointer, i, is0.reference.pointer)
        .object(const $BarcodeScannerOptions_BuilderType());
  }

  static final _setExecutor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions_Builder__setExecutor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder setExecutor(java.util.concurrent.Executor executor)
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder setExecutor(
    Executor executor,
  ) {
    return _setExecutor(reference.pointer, executor.reference.pointer)
        .object(const $BarcodeScannerOptions_BuilderType());
  }

  static final _setZoomSuggestionOptions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions_Builder__setZoomSuggestionOptions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder setZoomSuggestionOptions(com.google.mlkit.vision.barcode.ZoomSuggestionOptions zoomSuggestionOptions)
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder setZoomSuggestionOptions(
    ZoomSuggestionOptions zoomSuggestionOptions,
  ) {
    return _setZoomSuggestionOptions(
            reference.pointer, zoomSuggestionOptions.reference.pointer)
        .object(const $BarcodeScannerOptions_BuilderType());
  }

  static final _build = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions build()
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions build() {
    return _build(reference.pointer).object(const $BarcodeScannerOptionsType());
  }

  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "BarcodeScannerOptions_Builder__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory BarcodeScannerOptions_Builder() {
    return BarcodeScannerOptions_Builder.fromReference(_new0().reference);
  }
}

final class $BarcodeScannerOptions_BuilderType
    extends jni.JObjType<BarcodeScannerOptions_Builder> {
  const $BarcodeScannerOptions_BuilderType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions$Builder;";

  @override
  BarcodeScannerOptions_Builder fromReference(jni.JReference reference) =>
      BarcodeScannerOptions_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScannerOptions_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScannerOptions_BuilderType) &&
        other is $BarcodeScannerOptions_BuilderType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScannerOptions
class BarcodeScannerOptions extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScannerOptions> $type = type;

  BarcodeScannerOptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScannerOptionsType();
  static final _hashCode1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer).integer;
  }

  static final _equals = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("BarcodeScannerOptions__equals")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, object.reference.pointer).boolean;
  }

  static final _zza = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions__zza")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int zza()
  int zza() {
    return _zza(reference.pointer).integer;
  }

  static final _zzb = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions__zzb")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final com.google.mlkit.vision.barcode.ZoomSuggestionOptions zzb()
  /// The returned object must be released after use, by calling the [release] method.
  ZoomSuggestionOptions zzb() {
    return _zzb(reference.pointer).object(const $ZoomSuggestionOptionsType());
  }

  static final _zzc = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions__zzc")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.concurrent.Executor zzc()
  /// The returned object must be released after use, by calling the [release] method.
  Executor zzc() {
    return _zzc(reference.pointer).object(const $ExecutorType());
  }

  static final _zzd = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions__zzd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean zzd()
  bool zzd() {
    return _zzd(reference.pointer).boolean;
  }
}

final class $BarcodeScannerOptionsType
    extends jni.JObjType<BarcodeScannerOptions> {
  const $BarcodeScannerOptionsType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions;";

  @override
  BarcodeScannerOptions fromReference(jni.JReference reference) =>
      BarcodeScannerOptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScannerOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScannerOptionsType) &&
        other is $BarcodeScannerOptionsType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScanning
class BarcodeScanning extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScanning> $type = type;

  BarcodeScanning.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScanningType();
  static final _getClient =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "BarcodeScanning__getClient")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.google.mlkit.vision.barcode.BarcodeScanner getClient()
  /// The returned object must be released after use, by calling the [release] method.
  static BarcodeScanner getClient() {
    return _getClient().object(const $BarcodeScannerType());
  }

  static final _getClient1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScanning__getClient1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.mlkit.vision.barcode.BarcodeScanner getClient(com.google.mlkit.vision.barcode.BarcodeScannerOptions barcodeScannerOptions)
  /// The returned object must be released after use, by calling the [release] method.
  static BarcodeScanner getClient1(
    BarcodeScannerOptions barcodeScannerOptions,
  ) {
    return _getClient1(barcodeScannerOptions.reference.pointer)
        .object(const $BarcodeScannerType());
  }
}

final class $BarcodeScanningType extends jni.JObjType<BarcodeScanning> {
  const $BarcodeScanningType();

  @override
  String get signature => r"Lcom/google/mlkit/vision/barcode/BarcodeScanning;";

  @override
  BarcodeScanning fromReference(jni.JReference reference) =>
      BarcodeScanning.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScanningType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScanningType) &&
        other is $BarcodeScanningType;
  }
}

/// from: com.google.mlkit.vision.barcode.ZoomSuggestionOptions$Builder
class ZoomSuggestionOptions_Builder extends jni.JObject {
  @override
  late final jni.JObjType<ZoomSuggestionOptions_Builder> $type = type;

  ZoomSuggestionOptions_Builder.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $ZoomSuggestionOptions_BuilderType();
  static final _setMaxSupportedZoomRatio = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "ZoomSuggestionOptions_Builder__setMaxSupportedZoomRatio")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public com.google.mlkit.vision.barcode.ZoomSuggestionOptions$Builder setMaxSupportedZoomRatio(float f)
  /// The returned object must be released after use, by calling the [release] method.
  ZoomSuggestionOptions_Builder setMaxSupportedZoomRatio(
    double f,
  ) {
    return _setMaxSupportedZoomRatio(reference.pointer, f)
        .object(const $ZoomSuggestionOptions_BuilderType());
  }

  static final _build = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ZoomSuggestionOptions_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.ZoomSuggestionOptions build()
  /// The returned object must be released after use, by calling the [release] method.
  ZoomSuggestionOptions build() {
    return _build(reference.pointer).object(const $ZoomSuggestionOptionsType());
  }

  static final _new0 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ZoomSuggestionOptions_Builder__new0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.ZoomSuggestionOptions$ZoomCallback zoomCallback)
  /// The returned object must be released after use, by calling the [release] method.
  factory ZoomSuggestionOptions_Builder(
    ZoomSuggestionOptions_ZoomCallback zoomCallback,
  ) {
    return ZoomSuggestionOptions_Builder.fromReference(
        _new0(zoomCallback.reference.pointer).reference);
  }
}

final class $ZoomSuggestionOptions_BuilderType
    extends jni.JObjType<ZoomSuggestionOptions_Builder> {
  const $ZoomSuggestionOptions_BuilderType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/ZoomSuggestionOptions$Builder;";

  @override
  ZoomSuggestionOptions_Builder fromReference(jni.JReference reference) =>
      ZoomSuggestionOptions_Builder.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ZoomSuggestionOptions_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoomSuggestionOptions_BuilderType) &&
        other is $ZoomSuggestionOptions_BuilderType;
  }
}

/// from: com.google.mlkit.vision.barcode.ZoomSuggestionOptions$ZoomCallback
class ZoomSuggestionOptions_ZoomCallback extends jni.JObject {
  @override
  late final jni.JObjType<ZoomSuggestionOptions_ZoomCallback> $type = type;

  ZoomSuggestionOptions_ZoomCallback.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $ZoomSuggestionOptions_ZoomCallbackType();
  static final _setZoom = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("ZoomSuggestionOptions_ZoomCallback__setZoom")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public abstract boolean setZoom(float f)
  bool setZoom(
    double f,
  ) {
    return _setZoom(reference.pointer, f).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ZoomSuggestionOptions_ZoomCallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"setZoom(F)Z") {
        final $r = _$impls[$p]!.setZoom(
          $a[0]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
        );
        return jni.JBoolean($r).reference.toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory ZoomSuggestionOptions_ZoomCallback.implement(
    $ZoomSuggestionOptions_ZoomCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ZoomSuggestionOptions_ZoomCallback.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.ZoomSuggestionOptions$ZoomCallback",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ZoomSuggestionOptions_ZoomCallbackImpl {
  factory $ZoomSuggestionOptions_ZoomCallbackImpl({
    required bool Function(double f) setZoom,
  }) = _$ZoomSuggestionOptions_ZoomCallbackImpl;

  bool setZoom(double f);
}

class _$ZoomSuggestionOptions_ZoomCallbackImpl
    implements $ZoomSuggestionOptions_ZoomCallbackImpl {
  _$ZoomSuggestionOptions_ZoomCallbackImpl({
    required bool Function(double f) setZoom,
  }) : _setZoom = setZoom;

  final bool Function(double f) _setZoom;

  bool setZoom(double f) {
    return _setZoom(f);
  }
}

final class $ZoomSuggestionOptions_ZoomCallbackType
    extends jni.JObjType<ZoomSuggestionOptions_ZoomCallback> {
  const $ZoomSuggestionOptions_ZoomCallbackType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/ZoomSuggestionOptions$ZoomCallback;";

  @override
  ZoomSuggestionOptions_ZoomCallback fromReference(jni.JReference reference) =>
      ZoomSuggestionOptions_ZoomCallback.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ZoomSuggestionOptions_ZoomCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoomSuggestionOptions_ZoomCallbackType) &&
        other is $ZoomSuggestionOptions_ZoomCallbackType;
  }
}

/// from: com.google.mlkit.vision.barcode.ZoomSuggestionOptions
class ZoomSuggestionOptions extends jni.JObject {
  @override
  late final jni.JObjType<ZoomSuggestionOptions> $type = type;

  ZoomSuggestionOptions.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $ZoomSuggestionOptionsType();
  static final _hashCode1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ZoomSuggestionOptions__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference.pointer).integer;
  }

  static final _equals = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ZoomSuggestionOptions__equals")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, object.reference.pointer).boolean;
  }

  static final _zza = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ZoomSuggestionOptions__zza")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final float zza()
  double zza() {
    return _zza(reference.pointer).float;
  }

  static final _zzb = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ZoomSuggestionOptions__zzb")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final com.google.mlkit.vision.barcode.ZoomSuggestionOptions$ZoomCallback zzb()
  /// The returned object must be released after use, by calling the [release] method.
  ZoomSuggestionOptions_ZoomCallback zzb() {
    return _zzb(reference.pointer)
        .object(const $ZoomSuggestionOptions_ZoomCallbackType());
  }
}

final class $ZoomSuggestionOptionsType
    extends jni.JObjType<ZoomSuggestionOptions> {
  const $ZoomSuggestionOptionsType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/ZoomSuggestionOptions;";

  @override
  ZoomSuggestionOptions fromReference(jni.JReference reference) =>
      ZoomSuggestionOptions.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ZoomSuggestionOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoomSuggestionOptionsType) &&
        other is $ZoomSuggestionOptionsType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Address$AddressType
class Barcode_Address_AddressType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Address_AddressType> $type = type;

  Barcode_Address_AddressType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Address_AddressTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Address_AddressTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_Address_AddressType.implement(
    $Barcode_Address_AddressTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Address_AddressType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$Address$AddressType",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_Address_AddressTypeImpl {
  factory $Barcode_Address_AddressTypeImpl() =
      _$Barcode_Address_AddressTypeImpl;
}

class _$Barcode_Address_AddressTypeImpl
    implements $Barcode_Address_AddressTypeImpl {
  _$Barcode_Address_AddressTypeImpl();
}

final class $Barcode_Address_AddressTypeType
    extends jni.JObjType<Barcode_Address_AddressType> {
  const $Barcode_Address_AddressTypeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Address$AddressType;";

  @override
  Barcode_Address_AddressType fromReference(jni.JReference reference) =>
      Barcode_Address_AddressType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Address_AddressTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Address_AddressTypeType) &&
        other is $Barcode_Address_AddressTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Address
class Barcode_Address extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Address> $type = type;

  Barcode_Address.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_AddressType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;
  static final _getType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Address__getType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getType()
  int getType() {
    return _getType(reference.pointer).integer;
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Barcode_Address__new0")
      .asFunction<jni.JniResult Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Address(
    int i,
    jni.JArray<jni.JString> strings,
  ) {
    return Barcode_Address.fromReference(
        _new0(i, strings.reference.pointer).reference);
  }

  static final _getAddressLines = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Address__getAddressLines")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getAddressLines()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getAddressLines() {
    return _getAddressLines(reference.pointer)
        .object(const jni.JArrayType(jni.JStringType()));
  }
}

final class $Barcode_AddressType extends jni.JObjType<Barcode_Address> {
  const $Barcode_AddressType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Address;";

  @override
  Barcode_Address fromReference(jni.JReference reference) =>
      Barcode_Address.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_AddressType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_AddressType) &&
        other is $Barcode_AddressType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$BarcodeFormat
class Barcode_BarcodeFormat extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_BarcodeFormat> $type = type;

  Barcode_BarcodeFormat.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_BarcodeFormatType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_BarcodeFormatImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_BarcodeFormat.implement(
    $Barcode_BarcodeFormatImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_BarcodeFormat.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$BarcodeFormat",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_BarcodeFormatImpl {
  factory $Barcode_BarcodeFormatImpl() = _$Barcode_BarcodeFormatImpl;
}

class _$Barcode_BarcodeFormatImpl implements $Barcode_BarcodeFormatImpl {
  _$Barcode_BarcodeFormatImpl();
}

final class $Barcode_BarcodeFormatType
    extends jni.JObjType<Barcode_BarcodeFormat> {
  const $Barcode_BarcodeFormatType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$BarcodeFormat;";

  @override
  Barcode_BarcodeFormat fromReference(jni.JReference reference) =>
      Barcode_BarcodeFormat.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_BarcodeFormatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_BarcodeFormatType) &&
        other is $Barcode_BarcodeFormatType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$BarcodeValueType
class Barcode_BarcodeValueType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_BarcodeValueType> $type = type;

  Barcode_BarcodeValueType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_BarcodeValueTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_BarcodeValueTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_BarcodeValueType.implement(
    $Barcode_BarcodeValueTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_BarcodeValueType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$BarcodeValueType",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_BarcodeValueTypeImpl {
  factory $Barcode_BarcodeValueTypeImpl() = _$Barcode_BarcodeValueTypeImpl;
}

class _$Barcode_BarcodeValueTypeImpl implements $Barcode_BarcodeValueTypeImpl {
  _$Barcode_BarcodeValueTypeImpl();
}

final class $Barcode_BarcodeValueTypeType
    extends jni.JObjType<Barcode_BarcodeValueType> {
  const $Barcode_BarcodeValueTypeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$BarcodeValueType;";

  @override
  Barcode_BarcodeValueType fromReference(jni.JReference reference) =>
      Barcode_BarcodeValueType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_BarcodeValueTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_BarcodeValueTypeType) &&
        other is $Barcode_BarcodeValueTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime
class Barcode_CalendarDateTime extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_CalendarDateTime> $type = type;

  Barcode_CalendarDateTime.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_CalendarDateTimeType();
  static final _getDay = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getDay")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDay()
  int getDay() {
    return _getDay(reference.pointer).integer;
  }

  static final _getHours = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getHours")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHours()
  int getHours() {
    return _getHours(reference.pointer).integer;
  }

  static final _getMinutes = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getMinutes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMinutes()
  int getMinutes() {
    return _getMinutes(reference.pointer).integer;
  }

  static final _getMonth = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getMonth")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMonth()
  int getMonth() {
    return _getMonth(reference.pointer).integer;
  }

  static final _getSeconds = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getSeconds")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSeconds()
  int getSeconds() {
    return _getSeconds(reference.pointer).integer;
  }

  static final _getYear = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getYear")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getYear()
  int getYear() {
    return _getYear(reference.pointer).integer;
  }

  static final _getRawValue = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getRawValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getRawValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRawValue() {
    return _getRawValue(reference.pointer).object(const jni.JStringType());
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("Barcode_CalendarDateTime__new0")
      .asFunction<
          jni.JniResult Function(
              int, int, int, int, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, int i1, int i2, int i3, int i4, int i5, boolean z, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_CalendarDateTime(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    bool z,
    jni.JString string,
  ) {
    return Barcode_CalendarDateTime.fromReference(
        _new0(i, i1, i2, i3, i4, i5, z ? 1 : 0, string.reference.pointer)
            .reference);
  }

  static final _isUtc = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__isUtc")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUtc()
  bool isUtc() {
    return _isUtc(reference.pointer).boolean;
  }
}

final class $Barcode_CalendarDateTimeType
    extends jni.JObjType<Barcode_CalendarDateTime> {
  const $Barcode_CalendarDateTimeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;";

  @override
  Barcode_CalendarDateTime fromReference(jni.JReference reference) =>
      Barcode_CalendarDateTime.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_CalendarDateTimeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_CalendarDateTimeType) &&
        other is $Barcode_CalendarDateTimeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$CalendarEvent
class Barcode_CalendarEvent extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_CalendarEvent> $type = type;

  Barcode_CalendarEvent.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_CalendarEventType();
  static final _getEnd = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime getEnd()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarDateTime getEnd() {
    return _getEnd(reference.pointer)
        .object(const $Barcode_CalendarDateTimeType());
  }

  static final _getStart = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime getStart()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarDateTime getStart() {
    return _getStart(reference.pointer)
        .object(const $Barcode_CalendarDateTimeType());
  }

  static final _getDescription = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getDescription")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDescription()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDescription() {
    return _getDescription(reference.pointer).object(const jni.JStringType());
  }

  static final _getLocation = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getLocation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLocation()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLocation() {
    return _getLocation(reference.pointer).object(const jni.JStringType());
  }

  static final _getOrganizer = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getOrganizer")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getOrganizer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOrganizer() {
    return _getOrganizer(reference.pointer).object(const jni.JStringType());
  }

  static final _getStatus = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getStatus")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getStatus()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getStatus() {
    return _getStatus(reference.pointer).object(const jni.JStringType());
  }

  static final _getSummary = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getSummary")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSummary()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSummary() {
    return _getSummary(reference.pointer).object(const jni.JStringType());
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_CalendarEvent__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime calendarDateTime, com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime calendarDateTime1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_CalendarEvent(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    Barcode_CalendarDateTime calendarDateTime,
    Barcode_CalendarDateTime calendarDateTime1,
  ) {
    return Barcode_CalendarEvent.fromReference(_new0(
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            string3.reference.pointer,
            string4.reference.pointer,
            calendarDateTime.reference.pointer,
            calendarDateTime1.reference.pointer)
        .reference);
  }
}

final class $Barcode_CalendarEventType
    extends jni.JObjType<Barcode_CalendarEvent> {
  const $Barcode_CalendarEventType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarEvent;";

  @override
  Barcode_CalendarEvent fromReference(jni.JReference reference) =>
      Barcode_CalendarEvent.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_CalendarEventType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_CalendarEventType) &&
        other is $Barcode_CalendarEventType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$ContactInfo
class Barcode_ContactInfo extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_ContactInfo> $type = type;

  Barcode_ContactInfo.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_ContactInfoType();
  static final _getName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$PersonName getName()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_PersonName getName() {
    return _getName(reference.pointer).object(const $Barcode_PersonNameType());
  }

  static final _getOrganization = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getOrganization")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getOrganization()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOrganization() {
    return _getOrganization(reference.pointer).object(const jni.JStringType());
  }

  static final _getTitle = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTitle() {
    return _getTitle(reference.pointer).object(const jni.JStringType());
  }

  static final _getAddresses = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getAddresses")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getAddresses()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Address> getAddresses() {
    return _getAddresses(reference.pointer)
        .object(const jni.JListType($Barcode_AddressType()));
  }

  static final _getEmails = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getEmails")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getEmails()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Email> getEmails() {
    return _getEmails(reference.pointer)
        .object(const jni.JListType($Barcode_EmailType()));
  }

  static final _getPhones = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getPhones")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getPhones()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Phone> getPhones() {
    return _getPhones(reference.pointer)
        .object(const jni.JListType($Barcode_PhoneType()));
  }

  static final _getUrls = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getUrls")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getUrls()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getUrls() {
    return _getUrls(reference.pointer)
        .object(const jni.JListType(jni.JStringType()));
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_ContactInfo__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.Barcode$PersonName personName, java.lang.String string, java.lang.String string1, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_ContactInfo(
    Barcode_PersonName personName,
    jni.JString string,
    jni.JString string1,
    jni.JList<Barcode_Phone> list,
    jni.JList<Barcode_Email> list1,
    jni.JList<jni.JString> list2,
    jni.JList<Barcode_Address> list3,
  ) {
    return Barcode_ContactInfo.fromReference(_new0(
            personName.reference.pointer,
            string.reference.pointer,
            string1.reference.pointer,
            list.reference.pointer,
            list1.reference.pointer,
            list2.reference.pointer,
            list3.reference.pointer)
        .reference);
  }
}

final class $Barcode_ContactInfoType extends jni.JObjType<Barcode_ContactInfo> {
  const $Barcode_ContactInfoType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$ContactInfo;";

  @override
  Barcode_ContactInfo fromReference(jni.JReference reference) =>
      Barcode_ContactInfo.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_ContactInfoType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_ContactInfoType) &&
        other is $Barcode_ContactInfoType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$DriverLicense
class Barcode_DriverLicense extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_DriverLicense> $type = type;

  Barcode_DriverLicense.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_DriverLicenseType();
  static final _getAddressCity = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getAddressCity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAddressCity()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressCity() {
    return _getAddressCity(reference.pointer).object(const jni.JStringType());
  }

  static final _getAddressState = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getAddressState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAddressState()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressState() {
    return _getAddressState(reference.pointer).object(const jni.JStringType());
  }

  static final _getAddressStreet = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getAddressStreet")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAddressStreet()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressStreet() {
    return _getAddressStreet(reference.pointer).object(const jni.JStringType());
  }

  static final _getAddressZip = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getAddressZip")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAddressZip()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressZip() {
    return _getAddressZip(reference.pointer).object(const jni.JStringType());
  }

  static final _getBirthDate = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getBirthDate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getBirthDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getBirthDate() {
    return _getBirthDate(reference.pointer).object(const jni.JStringType());
  }

  static final _getDocumentType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getDocumentType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDocumentType()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDocumentType() {
    return _getDocumentType(reference.pointer).object(const jni.JStringType());
  }

  static final _getExpiryDate = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getExpiryDate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getExpiryDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getExpiryDate() {
    return _getExpiryDate(reference.pointer).object(const jni.JStringType());
  }

  static final _getFirstName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getFirstName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getFirstName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFirstName() {
    return _getFirstName(reference.pointer).object(const jni.JStringType());
  }

  static final _getGender = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getGender")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getGender()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getGender() {
    return _getGender(reference.pointer).object(const jni.JStringType());
  }

  static final _getIssueDate = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getIssueDate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getIssueDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getIssueDate() {
    return _getIssueDate(reference.pointer).object(const jni.JStringType());
  }

  static final _getIssuingCountry = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getIssuingCountry")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getIssuingCountry()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getIssuingCountry() {
    return _getIssuingCountry(reference.pointer)
        .object(const jni.JStringType());
  }

  static final _getLastName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getLastName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLastName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLastName() {
    return _getLastName(reference.pointer).object(const jni.JStringType());
  }

  static final _getLicenseNumber = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getLicenseNumber")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLicenseNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLicenseNumber() {
    return _getLicenseNumber(reference.pointer).object(const jni.JStringType());
  }

  static final _getMiddleName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getMiddleName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getMiddleName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMiddleName() {
    return _getMiddleName(reference.pointer).object(const jni.JStringType());
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_DriverLicense__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6, java.lang.String string7, java.lang.String string8, java.lang.String string9, java.lang.String string10, java.lang.String string11, java.lang.String string12, java.lang.String string13)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_DriverLicense(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    jni.JString string5,
    jni.JString string6,
    jni.JString string7,
    jni.JString string8,
    jni.JString string9,
    jni.JString string10,
    jni.JString string11,
    jni.JString string12,
    jni.JString string13,
  ) {
    return Barcode_DriverLicense.fromReference(_new0(
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            string3.reference.pointer,
            string4.reference.pointer,
            string5.reference.pointer,
            string6.reference.pointer,
            string7.reference.pointer,
            string8.reference.pointer,
            string9.reference.pointer,
            string10.reference.pointer,
            string11.reference.pointer,
            string12.reference.pointer,
            string13.reference.pointer)
        .reference);
  }
}

final class $Barcode_DriverLicenseType
    extends jni.JObjType<Barcode_DriverLicense> {
  const $Barcode_DriverLicenseType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$DriverLicense;";

  @override
  Barcode_DriverLicense fromReference(jni.JReference reference) =>
      Barcode_DriverLicense.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_DriverLicenseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_DriverLicenseType) &&
        other is $Barcode_DriverLicenseType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Email$FormatType
class Barcode_Email_FormatType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Email_FormatType> $type = type;

  Barcode_Email_FormatType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Email_FormatTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Email_FormatTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_Email_FormatType.implement(
    $Barcode_Email_FormatTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Email_FormatType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$Email$FormatType",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_Email_FormatTypeImpl {
  factory $Barcode_Email_FormatTypeImpl() = _$Barcode_Email_FormatTypeImpl;
}

class _$Barcode_Email_FormatTypeImpl implements $Barcode_Email_FormatTypeImpl {
  _$Barcode_Email_FormatTypeImpl();
}

final class $Barcode_Email_FormatTypeType
    extends jni.JObjType<Barcode_Email_FormatType> {
  const $Barcode_Email_FormatTypeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Email$FormatType;";

  @override
  Barcode_Email_FormatType fromReference(jni.JReference reference) =>
      Barcode_Email_FormatType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Email_FormatTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Email_FormatTypeType) &&
        other is $Barcode_Email_FormatTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Email
class Barcode_Email extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Email> $type = type;

  Barcode_Email.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_EmailType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;
  static final _getType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Email__getType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getType()
  int getType() {
    return _getType(reference.pointer).integer;
  }

  static final _getAddress = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Email__getAddress")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAddress()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddress() {
    return _getAddress(reference.pointer).object(const jni.JStringType());
  }

  static final _getBody = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Email__getBody")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getBody()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getBody() {
    return _getBody(reference.pointer).object(const jni.JStringType());
  }

  static final _getSubject = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Email__getSubject")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSubject()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSubject() {
    return _getSubject(reference.pointer).object(const jni.JStringType());
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_Email__new0")
      .asFunction<
          jni.JniResult Function(int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, java.lang.String string, java.lang.String string1, java.lang.String string2)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Email(
    int i,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    return Barcode_Email.fromReference(_new0(i, string.reference.pointer,
            string1.reference.pointer, string2.reference.pointer)
        .reference);
  }
}

final class $Barcode_EmailType extends jni.JObjType<Barcode_Email> {
  const $Barcode_EmailType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Email;";

  @override
  Barcode_Email fromReference(jni.JReference reference) =>
      Barcode_Email.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_EmailType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_EmailType) &&
        other is $Barcode_EmailType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$GeoPoint
class Barcode_GeoPoint extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_GeoPoint> $type = type;

  Barcode_GeoPoint.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_GeoPointType();
  static final _getLat = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_GeoPoint__getLat")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public double getLat()
  double getLat() {
    return _getLat(reference.pointer).doubleFloat;
  }

  static final _getLng = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_GeoPoint__getLng")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public double getLng()
  double getLng() {
    return _getLng(reference.pointer).doubleFloat;
  }

  static final _new0 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Double, ffi.Double)>>(
          "Barcode_GeoPoint__new0")
      .asFunction<jni.JniResult Function(double, double)>();

  /// from: public void <init>(double d, double d1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_GeoPoint(
    double d,
    double d1,
  ) {
    return Barcode_GeoPoint.fromReference(_new0(d, d1).reference);
  }
}

final class $Barcode_GeoPointType extends jni.JObjType<Barcode_GeoPoint> {
  const $Barcode_GeoPointType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$GeoPoint;";

  @override
  Barcode_GeoPoint fromReference(jni.JReference reference) =>
      Barcode_GeoPoint.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_GeoPointType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_GeoPointType) &&
        other is $Barcode_GeoPointType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$PersonName
class Barcode_PersonName extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_PersonName> $type = type;

  Barcode_PersonName.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_PersonNameType();
  static final _getFirst = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getFirst")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getFirst()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFirst() {
    return _getFirst(reference.pointer).object(const jni.JStringType());
  }

  static final _getFormattedName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getFormattedName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getFormattedName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFormattedName() {
    return _getFormattedName(reference.pointer).object(const jni.JStringType());
  }

  static final _getLast = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getLast")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLast()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLast() {
    return _getLast(reference.pointer).object(const jni.JStringType());
  }

  static final _getMiddle = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getMiddle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getMiddle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMiddle() {
    return _getMiddle(reference.pointer).object(const jni.JStringType());
  }

  static final _getPrefix = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getPrefix")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPrefix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPrefix() {
    return _getPrefix(reference.pointer).object(const jni.JStringType());
  }

  static final _getPronunciation = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getPronunciation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPronunciation()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPronunciation() {
    return _getPronunciation(reference.pointer).object(const jni.JStringType());
  }

  static final _getSuffix = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getSuffix")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuffix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSuffix() {
    return _getSuffix(reference.pointer).object(const jni.JStringType());
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_PersonName__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_PersonName(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    jni.JString string5,
    jni.JString string6,
  ) {
    return Barcode_PersonName.fromReference(_new0(
            string.reference.pointer,
            string1.reference.pointer,
            string2.reference.pointer,
            string3.reference.pointer,
            string4.reference.pointer,
            string5.reference.pointer,
            string6.reference.pointer)
        .reference);
  }
}

final class $Barcode_PersonNameType extends jni.JObjType<Barcode_PersonName> {
  const $Barcode_PersonNameType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$PersonName;";

  @override
  Barcode_PersonName fromReference(jni.JReference reference) =>
      Barcode_PersonName.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_PersonNameType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_PersonNameType) &&
        other is $Barcode_PersonNameType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Phone$FormatType
class Barcode_Phone_FormatType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Phone_FormatType> $type = type;

  Barcode_Phone_FormatType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Phone_FormatTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Phone_FormatTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_Phone_FormatType.implement(
    $Barcode_Phone_FormatTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Phone_FormatType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$Phone$FormatType",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_Phone_FormatTypeImpl {
  factory $Barcode_Phone_FormatTypeImpl() = _$Barcode_Phone_FormatTypeImpl;
}

class _$Barcode_Phone_FormatTypeImpl implements $Barcode_Phone_FormatTypeImpl {
  _$Barcode_Phone_FormatTypeImpl();
}

final class $Barcode_Phone_FormatTypeType
    extends jni.JObjType<Barcode_Phone_FormatType> {
  const $Barcode_Phone_FormatTypeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Phone$FormatType;";

  @override
  Barcode_Phone_FormatType fromReference(jni.JReference reference) =>
      Barcode_Phone_FormatType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Phone_FormatTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Phone_FormatTypeType) &&
        other is $Barcode_Phone_FormatTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Phone
class Barcode_Phone extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Phone> $type = type;

  Barcode_Phone.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_PhoneType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;

  /// from: static public final int TYPE_FAX
  static const TYPE_FAX = 3;

  /// from: static public final int TYPE_MOBILE
  static const TYPE_MOBILE = 4;
  static final _getType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Phone__getType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getType()
  int getType() {
    return _getType(reference.pointer).integer;
  }

  static final _getNumber = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Phone__getNumber")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getNumber() {
    return _getNumber(reference.pointer).object(const jni.JStringType());
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Barcode_Phone__new0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String string, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Phone(
    jni.JString string,
    int i,
  ) {
    return Barcode_Phone.fromReference(
        _new0(string.reference.pointer, i).reference);
  }
}

final class $Barcode_PhoneType extends jni.JObjType<Barcode_Phone> {
  const $Barcode_PhoneType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Phone;";

  @override
  Barcode_Phone fromReference(jni.JReference reference) =>
      Barcode_Phone.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_PhoneType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_PhoneType) &&
        other is $Barcode_PhoneType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Sms
class Barcode_Sms extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Sms> $type = type;

  Barcode_Sms.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_SmsType();
  static final _getMessage = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Sms__getMessage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getMessage()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMessage() {
    return _getMessage(reference.pointer).object(const jni.JStringType());
  }

  static final _getPhoneNumber = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Sms__getPhoneNumber")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPhoneNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPhoneNumber() {
    return _getPhoneNumber(reference.pointer).object(const jni.JStringType());
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_Sms__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Sms(
    jni.JString string,
    jni.JString string1,
  ) {
    return Barcode_Sms.fromReference(
        _new0(string.reference.pointer, string1.reference.pointer).reference);
  }
}

final class $Barcode_SmsType extends jni.JObjType<Barcode_Sms> {
  const $Barcode_SmsType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Sms;";

  @override
  Barcode_Sms fromReference(jni.JReference reference) =>
      Barcode_Sms.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_SmsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_SmsType) && other is $Barcode_SmsType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$UrlBookmark
class Barcode_UrlBookmark extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_UrlBookmark> $type = type;

  Barcode_UrlBookmark.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_UrlBookmarkType();
  static final _getTitle = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_UrlBookmark__getTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTitle() {
    return _getTitle(reference.pointer).object(const jni.JStringType());
  }

  static final _getUrl = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_UrlBookmark__getUrl")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUrl() {
    return _getUrl(reference.pointer).object(const jni.JStringType());
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_UrlBookmark__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_UrlBookmark(
    jni.JString string,
    jni.JString string1,
  ) {
    return Barcode_UrlBookmark.fromReference(
        _new0(string.reference.pointer, string1.reference.pointer).reference);
  }
}

final class $Barcode_UrlBookmarkType extends jni.JObjType<Barcode_UrlBookmark> {
  const $Barcode_UrlBookmarkType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$UrlBookmark;";

  @override
  Barcode_UrlBookmark fromReference(jni.JReference reference) =>
      Barcode_UrlBookmark.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_UrlBookmarkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_UrlBookmarkType) &&
        other is $Barcode_UrlBookmarkType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$WiFi$EncryptionType
class Barcode_WiFi_EncryptionType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_WiFi_EncryptionType> $type = type;

  Barcode_WiFi_EncryptionType.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_WiFi_EncryptionTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_WiFi_EncryptionTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_WiFi_EncryptionType.implement(
    $Barcode_WiFi_EncryptionTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_WiFi_EncryptionType.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$WiFi$EncryptionType",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $Barcode_WiFi_EncryptionTypeImpl {
  factory $Barcode_WiFi_EncryptionTypeImpl() =
      _$Barcode_WiFi_EncryptionTypeImpl;
}

class _$Barcode_WiFi_EncryptionTypeImpl
    implements $Barcode_WiFi_EncryptionTypeImpl {
  _$Barcode_WiFi_EncryptionTypeImpl();
}

final class $Barcode_WiFi_EncryptionTypeType
    extends jni.JObjType<Barcode_WiFi_EncryptionType> {
  const $Barcode_WiFi_EncryptionTypeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$WiFi$EncryptionType;";

  @override
  Barcode_WiFi_EncryptionType fromReference(jni.JReference reference) =>
      Barcode_WiFi_EncryptionType.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_WiFi_EncryptionTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_WiFi_EncryptionTypeType) &&
        other is $Barcode_WiFi_EncryptionTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$WiFi
class Barcode_WiFi extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_WiFi> $type = type;

  Barcode_WiFi.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_WiFiType();

  /// from: static public final int TYPE_OPEN
  static const TYPE_OPEN = 1;

  /// from: static public final int TYPE_WPA
  static const TYPE_WPA = 2;

  /// from: static public final int TYPE_WEP
  static const TYPE_WEP = 3;
  static final _getEncryptionType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_WiFi__getEncryptionType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getEncryptionType()
  int getEncryptionType() {
    return _getEncryptionType(reference.pointer).integer;
  }

  static final _getPassword = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_WiFi__getPassword")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPassword()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPassword() {
    return _getPassword(reference.pointer).object(const jni.JStringType());
  }

  static final _getSsid = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_WiFi__getSsid")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSsid()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSsid() {
    return _getSsid(reference.pointer).object(const jni.JStringType());
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Barcode_WiFi__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_WiFi(
    jni.JString string,
    jni.JString string1,
    int i,
  ) {
    return Barcode_WiFi.fromReference(
        _new0(string.reference.pointer, string1.reference.pointer, i)
            .reference);
  }
}

final class $Barcode_WiFiType extends jni.JObjType<Barcode_WiFi> {
  const $Barcode_WiFiType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$WiFi;";

  @override
  Barcode_WiFi fromReference(jni.JReference reference) =>
      Barcode_WiFi.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_WiFiType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_WiFiType) &&
        other is $Barcode_WiFiType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode
class Barcode extends jni.JObject {
  @override
  late final jni.JObjType<Barcode> $type = type;

  Barcode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeType();

  /// from: static public final int FORMAT_UNKNOWN
  static const FORMAT_UNKNOWN = -1;

  /// from: static public final int FORMAT_ALL_FORMATS
  static const FORMAT_ALL_FORMATS = 0;

  /// from: static public final int FORMAT_CODE_128
  static const FORMAT_CODE_128 = 1;

  /// from: static public final int FORMAT_CODE_39
  static const FORMAT_CODE_39 = 2;

  /// from: static public final int FORMAT_CODE_93
  static const FORMAT_CODE_93 = 4;

  /// from: static public final int FORMAT_CODABAR
  static const FORMAT_CODABAR = 8;

  /// from: static public final int FORMAT_DATA_MATRIX
  static const FORMAT_DATA_MATRIX = 16;

  /// from: static public final int FORMAT_EAN_13
  static const FORMAT_EAN_13 = 32;

  /// from: static public final int FORMAT_EAN_8
  static const FORMAT_EAN_8 = 64;

  /// from: static public final int FORMAT_ITF
  static const FORMAT_ITF = 128;

  /// from: static public final int FORMAT_QR_CODE
  static const FORMAT_QR_CODE = 256;

  /// from: static public final int FORMAT_UPC_A
  static const FORMAT_UPC_A = 512;

  /// from: static public final int FORMAT_UPC_E
  static const FORMAT_UPC_E = 1024;

  /// from: static public final int FORMAT_PDF417
  static const FORMAT_PDF417 = 2048;

  /// from: static public final int FORMAT_AZTEC
  static const FORMAT_AZTEC = 4096;

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_CONTACT_INFO
  static const TYPE_CONTACT_INFO = 1;

  /// from: static public final int TYPE_EMAIL
  static const TYPE_EMAIL = 2;

  /// from: static public final int TYPE_ISBN
  static const TYPE_ISBN = 3;

  /// from: static public final int TYPE_PHONE
  static const TYPE_PHONE = 4;

  /// from: static public final int TYPE_PRODUCT
  static const TYPE_PRODUCT = 5;

  /// from: static public final int TYPE_SMS
  static const TYPE_SMS = 6;

  /// from: static public final int TYPE_TEXT
  static const TYPE_TEXT = 7;

  /// from: static public final int TYPE_URL
  static const TYPE_URL = 8;

  /// from: static public final int TYPE_WIFI
  static const TYPE_WIFI = 9;

  /// from: static public final int TYPE_GEO
  static const TYPE_GEO = 10;

  /// from: static public final int TYPE_CALENDAR_EVENT
  static const TYPE_CALENDAR_EVENT = 11;

  /// from: static public final int TYPE_DRIVER_LICENSE
  static const TYPE_DRIVER_LICENSE = 12;
  static final _getFormat = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getFormat")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getFormat()
  int getFormat() {
    return _getFormat(reference.pointer).integer;
  }

  static final _getValueType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getValueType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getValueType()
  int getValueType() {
    return _getValueType(reference.pointer).integer;
  }

  static final _getBoundingBox = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getBoundingBox")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Rect getBoundingBox()
  /// The returned object must be released after use, by calling the [release] method.
  Rect getBoundingBox() {
    return _getBoundingBox(reference.pointer).object(const $RectType());
  }

  static final _getCalendarEvent = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getCalendarEvent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarEvent getCalendarEvent()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarEvent getCalendarEvent() {
    return _getCalendarEvent(reference.pointer)
        .object(const $Barcode_CalendarEventType());
  }

  static final _getContactInfo = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getContactInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$ContactInfo getContactInfo()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_ContactInfo getContactInfo() {
    return _getContactInfo(reference.pointer)
        .object(const $Barcode_ContactInfoType());
  }

  static final _getDriverLicense = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getDriverLicense")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$DriverLicense getDriverLicense()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_DriverLicense getDriverLicense() {
    return _getDriverLicense(reference.pointer)
        .object(const $Barcode_DriverLicenseType());
  }

  static final _getEmail = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getEmail")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Email getEmail()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Email getEmail() {
    return _getEmail(reference.pointer).object(const $Barcode_EmailType());
  }

  static final _getGeoPoint = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getGeoPoint")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$GeoPoint getGeoPoint()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_GeoPoint getGeoPoint() {
    return _getGeoPoint(reference.pointer)
        .object(const $Barcode_GeoPointType());
  }

  static final _getPhone = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getPhone")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Phone getPhone()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Phone getPhone() {
    return _getPhone(reference.pointer).object(const $Barcode_PhoneType());
  }

  static final _getSms = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Barcode__getSms")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Sms getSms()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Sms getSms() {
    return _getSms(reference.pointer).object(const $Barcode_SmsType());
  }

  static final _getUrl = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Barcode__getUrl")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$UrlBookmark getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_UrlBookmark getUrl() {
    return _getUrl(reference.pointer).object(const $Barcode_UrlBookmarkType());
  }

  static final _getWifi = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getWifi")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$WiFi getWifi()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_WiFi getWifi() {
    return _getWifi(reference.pointer).object(const $Barcode_WiFiType());
  }

  static final _getDisplayValue = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getDisplayValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDisplayValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDisplayValue() {
    return _getDisplayValue(reference.pointer).object(const jni.JStringType());
  }

  static final _getRawValue = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getRawValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getRawValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRawValue() {
    return _getRawValue(reference.pointer).object(const jni.JStringType());
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Barcode__new0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.internal.BarcodeSource barcodeSource)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode(
    jni.JObject barcodeSource,
  ) {
    return Barcode.fromReference(
        _new0(barcodeSource.reference.pointer).reference);
  }

  static final _new1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode__new1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.internal.BarcodeSource barcodeSource, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode.new1(
    jni.JObject barcodeSource,
    jni.JObject matrix,
  ) {
    return Barcode.fromReference(
        _new1(barcodeSource.reference.pointer, matrix.reference.pointer)
            .reference);
  }

  static final _getRawBytes = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getRawBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] getRawBytes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getRawBytes() {
    return _getRawBytes(reference.pointer)
        .object(const jni.JArrayType(jni.jbyteType()));
  }

  static final _getCornerPoints = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getCornerPoints")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Point[] getCornerPoints()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<Point> getCornerPoints() {
    return _getCornerPoints(reference.pointer)
        .object(const jni.JArrayType($PointType()));
  }
}

final class $BarcodeType extends jni.JObjType<Barcode> {
  const $BarcodeType();

  @override
  String get signature => r"Lcom/google/mlkit/vision/barcode/common/Barcode;";

  @override
  Barcode fromReference(jni.JReference reference) =>
      Barcode.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeType) && other is $BarcodeType;
  }
}

/// from: java.lang.Runnable
class Runnable extends jni.JObject {
  @override
  late final jni.JObjType<Runnable> $type = type;

  Runnable.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $RunnableType();
  static final _run = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Runnable__run")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void run()
  void run() {
    _run(reference.pointer).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $RunnableImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"run()V") {
        _$impls[$p]!.run();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Runnable.implement(
    $RunnableImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Runnable.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"java.lang.Runnable",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $RunnableImpl {
  factory $RunnableImpl({
    required void Function() run,
  }) = _$RunnableImpl;

  void run();
}

class _$RunnableImpl implements $RunnableImpl {
  _$RunnableImpl({
    required void Function() run,
  }) : _run = run;

  final void Function() _run;

  void run() {
    return _run();
  }
}

final class $RunnableType extends jni.JObjType<Runnable> {
  const $RunnableType();

  @override
  String get signature => r"Ljava/lang/Runnable;";

  @override
  Runnable fromReference(jni.JReference reference) =>
      Runnable.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RunnableType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RunnableType) && other is $RunnableType;
  }
}

/// from: java.util.concurrent.Executor
class Executor extends jni.JObject {
  @override
  late final jni.JObjType<Executor> $type = type;

  Executor.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $ExecutorType();
  static final _execute = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Executor__execute")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void execute(java.lang.Runnable runnable)
  void execute(
    Runnable runnable,
  ) {
    _execute(reference.pointer, runnable.reference.pointer).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ExecutorImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"execute(Ljava/lang/Runnable;)V") {
        _$impls[$p]!.execute(
          $a[0].castTo(const $RunnableType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Executor.implement(
    $ExecutorImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Executor.fromReference(
      ProtectedJniExtensions.newPortProxy(
        r"java.util.concurrent.Executor",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract interface class $ExecutorImpl {
  factory $ExecutorImpl({
    required void Function(Runnable runnable) execute,
  }) = _$ExecutorImpl;

  void execute(Runnable runnable);
}

class _$ExecutorImpl implements $ExecutorImpl {
  _$ExecutorImpl({
    required void Function(Runnable runnable) execute,
  }) : _execute = execute;

  final void Function(Runnable runnable) _execute;

  void execute(Runnable runnable) {
    return _execute(runnable);
  }
}

final class $ExecutorType extends jni.JObjType<Executor> {
  const $ExecutorType();

  @override
  String get signature => r"Ljava/util/concurrent/Executor;";

  @override
  Executor fromReference(jni.JReference reference) =>
      Executor.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExecutorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExecutorType) && other is $ExecutorType;
  }
}

/// from: java.util.concurrent.Executors
class Executors extends jni.JObject {
  @override
  late final jni.JObjType<Executors> $type = type;

  Executors.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  /// The type which includes information such as the signature of this class.
  static const type = $ExecutorsType();
  static final _newFixedThreadPool =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "Executors__newFixedThreadPool")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public java.util.concurrent.ExecutorService newFixedThreadPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newFixedThreadPool(
    int i,
  ) {
    return _newFixedThreadPool(i).object(const jni.JObjectType());
  }

  static final _newWorkStealingPool =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "Executors__newWorkStealingPool")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public java.util.concurrent.ExecutorService newWorkStealingPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newWorkStealingPool(
    int i,
  ) {
    return _newWorkStealingPool(i).object(const jni.JObjectType());
  }

  static final _newWorkStealingPool1 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__newWorkStealingPool1")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ExecutorService newWorkStealingPool()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newWorkStealingPool1() {
    return _newWorkStealingPool1().object(const jni.JObjectType());
  }

  static final _newFixedThreadPool1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Executors__newFixedThreadPool1")
      .asFunction<jni.JniResult Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService newFixedThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newFixedThreadPool1(
    int i,
    jni.JObject threadFactory,
  ) {
    return _newFixedThreadPool1(i, threadFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _newSingleThreadExecutor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__newSingleThreadExecutor")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ExecutorService newSingleThreadExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadExecutor() {
    return _newSingleThreadExecutor().object(const jni.JObjectType());
  }

  static final _newSingleThreadExecutor1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__newSingleThreadExecutor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService newSingleThreadExecutor(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadExecutor1(
    jni.JObject threadFactory,
  ) {
    return _newSingleThreadExecutor1(threadFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _newCachedThreadPool =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__newCachedThreadPool")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ExecutorService newCachedThreadPool()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newCachedThreadPool() {
    return _newCachedThreadPool().object(const jni.JObjectType());
  }

  static final _newCachedThreadPool1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__newCachedThreadPool1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService newCachedThreadPool(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newCachedThreadPool1(
    jni.JObject threadFactory,
  ) {
    return _newCachedThreadPool1(threadFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _newSingleThreadScheduledExecutor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__newSingleThreadScheduledExecutor")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadScheduledExecutor() {
    return _newSingleThreadScheduledExecutor().object(const jni.JObjectType());
  }

  static final _newSingleThreadScheduledExecutor1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__newSingleThreadScheduledExecutor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadScheduledExecutor1(
    jni.JObject threadFactory,
  ) {
    return _newSingleThreadScheduledExecutor1(threadFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _newScheduledThreadPool =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "Executors__newScheduledThreadPool")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newScheduledThreadPool(
    int i,
  ) {
    return _newScheduledThreadPool(i).object(const jni.JObjectType());
  }

  static final _newScheduledThreadPool1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Executors__newScheduledThreadPool1")
      .asFunction<jni.JniResult Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newScheduledThreadPool1(
    int i,
    jni.JObject threadFactory,
  ) {
    return _newScheduledThreadPool1(i, threadFactory.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _unconfigurableExecutorService = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__unconfigurableExecutorService")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService executorService)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject unconfigurableExecutorService(
    jni.JObject executorService,
  ) {
    return _unconfigurableExecutorService(executorService.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _unconfigurableScheduledExecutorService = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__unconfigurableScheduledExecutorService")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService scheduledExecutorService)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject unconfigurableScheduledExecutorService(
    jni.JObject scheduledExecutorService,
  ) {
    return _unconfigurableScheduledExecutorService(
            scheduledExecutorService.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _defaultThreadFactory =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__defaultThreadFactory")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ThreadFactory defaultThreadFactory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject defaultThreadFactory() {
    return _defaultThreadFactory().object(const jni.JObjectType());
  }

  static final _privilegedThreadFactory =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__privilegedThreadFactory")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ThreadFactory privilegedThreadFactory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject privilegedThreadFactory() {
    return _privilegedThreadFactory().object(const jni.JObjectType());
  }

  static final _callable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Executors__callable")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.lang.Runnable runnable, T object)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable<$T extends jni.JObject>(
    Runnable runnable,
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return _callable(runnable.reference.pointer, object.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _callable1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__callable1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.lang.Runnable runnable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable1(
    Runnable runnable,
  ) {
    return _callable1(runnable.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _callable2 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__callable2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.security.PrivilegedAction privilegedAction)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable2(
    jni.JObject privilegedAction,
  ) {
    return _callable2(privilegedAction.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _callable3 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__callable3")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.security.PrivilegedExceptionAction privilegedExceptionAction)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable3(
    jni.JObject privilegedExceptionAction,
  ) {
    return _callable3(privilegedExceptionAction.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _privilegedCallable = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__privilegedCallable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable privilegedCallable(java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject privilegedCallable<$T extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$T> T,
  }) {
    return _privilegedCallable(callable.reference.pointer)
        .object(const jni.JObjectType());
  }

  static final _privilegedCallableUsingCurrentClassLoader = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__privilegedCallableUsingCurrentClassLoader")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject
      privilegedCallableUsingCurrentClassLoader<$T extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$T> T,
  }) {
    return _privilegedCallableUsingCurrentClassLoader(
            callable.reference.pointer)
        .object(const jni.JObjectType());
  }
}

final class $ExecutorsType extends jni.JObjType<Executors> {
  const $ExecutorsType();

  @override
  String get signature => r"Ljava/util/concurrent/Executors;";

  @override
  Executors fromReference(jni.JReference reference) =>
      Executors.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExecutorsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExecutorsType) && other is $ExecutorsType;
  }
}
