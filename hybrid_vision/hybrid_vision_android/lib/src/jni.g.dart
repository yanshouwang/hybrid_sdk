// ignore_for_file: use_super_parameters
// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

// Auto-generated initialization code.

final ffi.Pointer<T> Function<T extends ffi.NativeType>(String sym) jniLookup =
    ProtectedJniExtensions.initGeneratedLibrary("hybrid_vision_android");

/// from: android.graphics.Bitmap$CompressFormat
class Bitmap_CompressFormat extends jni.JObject {
  @override
  late final jni.JObjType<Bitmap_CompressFormat> $type = type;

  Bitmap_CompressFormat.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Bitmap_CompressFormatType();
  static final _get_JPEG =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_CompressFormat__JPEG")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$CompressFormat JPEG
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat get JPEG =>
      const $Bitmap_CompressFormatType().fromRef(_get_JPEG().object);

  static final _get_PNG =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_CompressFormat__PNG")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$CompressFormat PNG
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat get PNG =>
      const $Bitmap_CompressFormatType().fromRef(_get_PNG().object);

  static final _get_WEBP =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_CompressFormat__WEBP")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$CompressFormat WEBP
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat get WEBP =>
      const $Bitmap_CompressFormatType().fromRef(_get_WEBP().object);

  static final _get_WEBP_LOSSY =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_CompressFormat__WEBP_LOSSY")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSY
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat get WEBP_LOSSY =>
      const $Bitmap_CompressFormatType().fromRef(_get_WEBP_LOSSY().object);

  static final _get_WEBP_LOSSLESS =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_CompressFormat__WEBP_LOSSLESS")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$CompressFormat WEBP_LOSSLESS
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat get WEBP_LOSSLESS =>
      const $Bitmap_CompressFormatType().fromRef(_get_WEBP_LOSSLESS().object);

  static final _values =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Bitmap_CompressFormat__values")
          .asFunction<jni.JniResult Function()>();

  /// from: static public android.graphics.Bitmap$CompressFormat[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<Bitmap_CompressFormat> values() {
    return const jni.JArrayType($Bitmap_CompressFormatType())
        .fromRef(_values().object);
  }

  static final _valueOf = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap_CompressFormat__valueOf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap$CompressFormat valueOf(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_CompressFormat valueOf(
    jni.JString string,
  ) {
    return const $Bitmap_CompressFormatType()
        .fromRef(_valueOf(string.reference).object);
  }
}

final class $Bitmap_CompressFormatType
    extends jni.JObjType<Bitmap_CompressFormat> {
  const $Bitmap_CompressFormatType();

  @override
  String get signature => r"Landroid/graphics/Bitmap$CompressFormat;";

  @override
  Bitmap_CompressFormat fromRef(jni.JObjectPtr ref) =>
      Bitmap_CompressFormat.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Bitmap_CompressFormatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap_CompressFormatType) &&
        other is $Bitmap_CompressFormatType;
  }
}

/// from: android.graphics.Bitmap$Config
class Bitmap_Config extends jni.JObject {
  @override
  late final jni.JObjType<Bitmap_Config> $type = type;

  Bitmap_Config.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Bitmap_ConfigType();
  static final _get_ALPHA_8 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__ALPHA_8")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config ALPHA_8
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get ALPHA_8 =>
      const $Bitmap_ConfigType().fromRef(_get_ALPHA_8().object);

  static final _get_RGB_565 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__RGB_565")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config RGB_565
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get RGB_565 =>
      const $Bitmap_ConfigType().fromRef(_get_RGB_565().object);

  static final _get_ARGB_4444 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__ARGB_4444")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config ARGB_4444
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get ARGB_4444 =>
      const $Bitmap_ConfigType().fromRef(_get_ARGB_4444().object);

  static final _get_ARGB_8888 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__ARGB_8888")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config ARGB_8888
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get ARGB_8888 =>
      const $Bitmap_ConfigType().fromRef(_get_ARGB_8888().object);

  static final _get_RGBA_F16 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__RGBA_F16")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config RGBA_F16
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get RGBA_F16 =>
      const $Bitmap_ConfigType().fromRef(_get_RGBA_F16().object);

  static final _get_HARDWARE =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__HARDWARE")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config HARDWARE
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get HARDWARE =>
      const $Bitmap_ConfigType().fromRef(_get_HARDWARE().object);

  static final _get_RGBA_1010102 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap_Config__RGBA_1010102")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.graphics.Bitmap$Config RGBA_1010102
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config get RGBA_1010102 =>
      const $Bitmap_ConfigType().fromRef(_get_RGBA_1010102().object);

  static final _values =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Bitmap_Config__values")
          .asFunction<jni.JniResult Function()>();

  /// from: static public android.graphics.Bitmap$Config[] values()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JArray<Bitmap_Config> values() {
    return const jni.JArrayType($Bitmap_ConfigType()).fromRef(_values().object);
  }

  static final _valueOf = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap_Config__valueOf")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap$Config valueOf(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap_Config valueOf(
    jni.JString string,
  ) {
    return const $Bitmap_ConfigType()
        .fromRef(_valueOf(string.reference).object);
  }
}

final class $Bitmap_ConfigType extends jni.JObjType<Bitmap_Config> {
  const $Bitmap_ConfigType();

  @override
  String get signature => r"Landroid/graphics/Bitmap$Config;";

  @override
  Bitmap_Config fromRef(jni.JObjectPtr ref) => Bitmap_Config.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Bitmap_ConfigType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Bitmap_ConfigType) &&
        other is $Bitmap_ConfigType;
  }
}

/// from: android.graphics.Bitmap
class Bitmap extends jni.JObject {
  @override
  late final jni.JObjType<Bitmap> $type = type;

  Bitmap.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $BitmapType();
  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Bitmap__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      const jni.JObjectType().fromRef(_get_CREATOR().object);

  /// from: static public final int DENSITY_NONE
  static const DENSITY_NONE = 0;

  static final _getDensity = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getDensity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDensity()
  int getDensity() {
    return _getDensity(reference).integer;
  }

  static final _setDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__setDensity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setDensity(int i)
  void setDensity(
    int i,
  ) {
    return _setDensity(reference, i).check();
  }

  static final _reconfigure = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Bitmap__reconfigure")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void reconfigure(int i, int i1, android.graphics.Bitmap$Config config)
  void reconfigure(
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return _reconfigure(reference, i, i1, config.reference).check();
  }

  static final _setWidth = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__setWidth")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setWidth(int i)
  void setWidth(
    int i,
  ) {
    return _setWidth(reference, i).check();
  }

  static final _setHeight = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__setHeight")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHeight(int i)
  void setHeight(
    int i,
  ) {
    return _setHeight(reference, i).check();
  }

  static final _setConfig = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__setConfig")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setConfig(android.graphics.Bitmap$Config config)
  void setConfig(
    Bitmap_Config config,
  ) {
    return _setConfig(reference, config.reference).check();
  }

  static final _recycle = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Bitmap__recycle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void recycle()
  void recycle() {
    return _recycle(reference).check();
  }

  static final _isRecycled = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__isRecycled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isRecycled()
  bool isRecycled() {
    return _isRecycled(reference).boolean;
  }

  static final _getGenerationId = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getGenerationId")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getGenerationId()
  int getGenerationId() {
    return _getGenerationId(reference).integer;
  }

  static final _copyPixelsToBuffer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__copyPixelsToBuffer")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void copyPixelsToBuffer(java.nio.Buffer buffer)
  void copyPixelsToBuffer(
    jni.JBuffer buffer,
  ) {
    return _copyPixelsToBuffer(reference, buffer.reference).check();
  }

  static final _copyPixelsFromBuffer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__copyPixelsFromBuffer")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void copyPixelsFromBuffer(java.nio.Buffer buffer)
  void copyPixelsFromBuffer(
    jni.JBuffer buffer,
  ) {
    return _copyPixelsFromBuffer(reference, buffer.reference).check();
  }

  static final _copy = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Bitmap__copy")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public android.graphics.Bitmap copy(android.graphics.Bitmap$Config config, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap copy(
    Bitmap_Config config,
    bool z,
  ) {
    return const $BitmapType()
        .fromRef(_copy(reference, config.reference, z ? 1 : 0).object);
  }

  static final _asShared = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__asShared")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap asShared()
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap asShared() {
    return const $BitmapType().fromRef(_asShared(reference).object);
  }

  static final _wrapHardwareBuffer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__wrapHardwareBuffer")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap wrapHardwareBuffer(android.hardware.HardwareBuffer hardwareBuffer, android.graphics.ColorSpace colorSpace)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap wrapHardwareBuffer(
    jni.JObject hardwareBuffer,
    jni.JObject colorSpace,
  ) {
    return const $BitmapType().fromRef(
        _wrapHardwareBuffer(hardwareBuffer.reference, colorSpace.reference)
            .object);
  }

  static final _createScaledBitmap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Uint8)>>("Bitmap__createScaledBitmap")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: static public android.graphics.Bitmap createScaledBitmap(android.graphics.Bitmap bitmap, int i, int i1, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createScaledBitmap(
    Bitmap bitmap,
    int i,
    int i1,
    bool z,
  ) {
    return const $BitmapType().fromRef(
        _createScaledBitmap(bitmap.reference, i, i1, z ? 1 : 0).object);
  }

  static final _createBitmap = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__createBitmap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap(
    Bitmap bitmap,
  ) {
    return const $BitmapType().fromRef(_createBitmap(bitmap.reference).object);
  }

  static final _createBitmap1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Bitmap__createBitmap1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap1(
    Bitmap bitmap,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return const $BitmapType()
        .fromRef(_createBitmap1(bitmap.reference, i, i1, i2, i3).object);
  }

  static final _createBitmap2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Bitmap__createBitmap2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Bitmap bitmap, int i, int i1, int i2, int i3, android.graphics.Matrix matrix, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap2(
    Bitmap bitmap,
    int i,
    int i1,
    int i2,
    int i3,
    jni.JObject matrix,
    bool z,
  ) {
    return const $BitmapType().fromRef(_createBitmap2(
            bitmap.reference, i, i1, i2, i3, matrix.reference, z ? 1 : 0)
        .object);
  }

  static final _createBitmap3 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap3")
      .asFunction<jni.JniResult Function(int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap3(
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return const $BitmapType()
        .fromRef(_createBitmap3(i, i1, config.reference).object);
  }

  static final _createBitmap4 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap4")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap4(
    jni.JObject displayMetrics,
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return const $BitmapType().fromRef(
        _createBitmap4(displayMetrics.reference, i, i1, config.reference)
            .object);
  }

  static final _createBitmap5 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32, ffi.Int32,
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Bitmap__createBitmap5")
      .asFunction<
          jni.JniResult Function(int, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap5(
    int i,
    int i1,
    Bitmap_Config config,
    bool z,
  ) {
    return const $BitmapType()
        .fromRef(_createBitmap5(i, i1, config.reference, z ? 1 : 0).object);
  }

  static final _createBitmap6 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap6")
      .asFunction<
          jni.JniResult Function(
              int, int, ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap6(
    int i,
    int i1,
    Bitmap_Config config,
    bool z,
    jni.JObject colorSpace,
  ) {
    return const $BitmapType().fromRef(
        _createBitmap6(i, i1, config.reference, z ? 1 : 0, colorSpace.reference)
            .object);
  }

  static final _createBitmap7 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Bitmap__createBitmap7")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap7(
    jni.JObject displayMetrics,
    int i,
    int i1,
    Bitmap_Config config,
    bool z,
  ) {
    return const $BitmapType().fromRef(_createBitmap7(
            displayMetrics.reference, i, i1, config.reference, z ? 1 : 0)
        .object);
  }

  static final _createBitmap8 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap8")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int,
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int i, int i1, android.graphics.Bitmap$Config config, boolean z, android.graphics.ColorSpace colorSpace)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap8(
    jni.JObject displayMetrics,
    int i,
    int i1,
    Bitmap_Config config,
    bool z,
    jni.JObject colorSpace,
  ) {
    return const $BitmapType().fromRef(_createBitmap8(displayMetrics.reference,
            i, i1, config.reference, z ? 1 : 0, colorSpace.reference)
        .object);
  }

  static final _createBitmap9 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap9")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap9(
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap_Config config,
  ) {
    return const $BitmapType().fromRef(
        _createBitmap9(is0.reference, i, i1, i2, i3, config.reference).object);
  }

  static final _createBitmap10 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap10")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, int i2, int i3, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap10(
    jni.JObject displayMetrics,
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    int i2,
    int i3,
    Bitmap_Config config,
  ) {
    return const $BitmapType().fromRef(_createBitmap10(displayMetrics.reference,
            is0.reference, i, i1, i2, i3, config.reference)
        .object);
  }

  static final _createBitmap11 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap11")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(int[] is, int i, int i1, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap11(
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return const $BitmapType().fromRef(
        _createBitmap11(is0.reference, i, i1, config.reference).object);
  }

  static final _createBitmap12 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap12")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.util.DisplayMetrics displayMetrics, int[] is, int i, int i1, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap12(
    jni.JObject displayMetrics,
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return const $BitmapType().fromRef(_createBitmap12(
            displayMetrics.reference, is0.reference, i, i1, config.reference)
        .object);
  }

  static final _createBitmap13 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__createBitmap13")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap13(
    jni.JObject picture,
  ) {
    return const $BitmapType()
        .fromRef(_createBitmap13(picture.reference).object);
  }

  static final _createBitmap14 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Bitmap__createBitmap14")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap createBitmap(android.graphics.Picture picture, int i, int i1, android.graphics.Bitmap$Config config)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap createBitmap14(
    jni.JObject picture,
    int i,
    int i1,
    Bitmap_Config config,
  ) {
    return const $BitmapType().fromRef(
        _createBitmap14(picture.reference, i, i1, config.reference).object);
  }

  static final _getNinePatchChunk = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getNinePatchChunk")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] getNinePatchChunk()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getNinePatchChunk() {
    return const jni.JArrayType(jni.jbyteType())
        .fromRef(_getNinePatchChunk(reference).object);
  }

  static final _compress = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__compress")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean compress(android.graphics.Bitmap$CompressFormat compressFormat, int i, java.io.OutputStream outputStream)
  bool compress(
    Bitmap_CompressFormat compressFormat,
    int i,
    jni.JObject outputStream,
  ) {
    return _compress(
            reference, compressFormat.reference, i, outputStream.reference)
        .boolean;
  }

  static final _isMutable = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__isMutable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isMutable()
  bool isMutable() {
    return _isMutable(reference).boolean;
  }

  static final _isPremultiplied = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__isPremultiplied")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isPremultiplied()
  bool isPremultiplied() {
    return _isPremultiplied(reference).boolean;
  }

  static final _setPremultiplied = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Bitmap__setPremultiplied")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setPremultiplied(boolean z)
  void setPremultiplied(
    bool z,
  ) {
    return _setPremultiplied(reference, z ? 1 : 0).check();
  }

  static final _getWidth = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getWidth")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getWidth()
  int getWidth() {
    return _getWidth(reference).integer;
  }

  static final _getHeight = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getHeight")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHeight()
  int getHeight() {
    return _getHeight(reference).integer;
  }

  static final _getScaledWidth = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__getScaledWidth")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getScaledWidth(android.graphics.Canvas canvas)
  int getScaledWidth(
    jni.JObject canvas,
  ) {
    return _getScaledWidth(reference, canvas.reference).integer;
  }

  static final _getScaledHeight = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__getScaledHeight")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getScaledHeight(android.graphics.Canvas canvas)
  int getScaledHeight(
    jni.JObject canvas,
  ) {
    return _getScaledHeight(reference, canvas.reference).integer;
  }

  static final _getScaledWidth1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__getScaledWidth1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getScaledWidth(android.util.DisplayMetrics displayMetrics)
  int getScaledWidth1(
    jni.JObject displayMetrics,
  ) {
    return _getScaledWidth1(reference, displayMetrics.reference).integer;
  }

  static final _getScaledHeight1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__getScaledHeight1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int getScaledHeight(android.util.DisplayMetrics displayMetrics)
  int getScaledHeight1(
    jni.JObject displayMetrics,
  ) {
    return _getScaledHeight1(reference, displayMetrics.reference).integer;
  }

  static final _getScaledWidth2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__getScaledWidth2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getScaledWidth(int i)
  int getScaledWidth2(
    int i,
  ) {
    return _getScaledWidth2(reference, i).integer;
  }

  static final _getScaledHeight2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("Bitmap__getScaledHeight2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public int getScaledHeight(int i)
  int getScaledHeight2(
    int i,
  ) {
    return _getScaledHeight2(reference, i).integer;
  }

  static final _getRowBytes = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getRowBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRowBytes()
  int getRowBytes() {
    return _getRowBytes(reference).integer;
  }

  static final _getByteCount = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getByteCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getByteCount()
  int getByteCount() {
    return _getByteCount(reference).integer;
  }

  static final _getAllocationByteCount = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getAllocationByteCount")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getAllocationByteCount()
  int getAllocationByteCount() {
    return _getAllocationByteCount(reference).integer;
  }

  static final _getConfig = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getConfig")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap$Config getConfig()
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap_Config getConfig() {
    return const $Bitmap_ConfigType().fromRef(_getConfig(reference).object);
  }

  static final _hasAlpha = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__hasAlpha")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasAlpha()
  bool hasAlpha() {
    return _hasAlpha(reference).boolean;
  }

  static final _setHasAlpha = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Bitmap__setHasAlpha")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHasAlpha(boolean z)
  void setHasAlpha(
    bool z,
  ) {
    return _setHasAlpha(reference, z ? 1 : 0).check();
  }

  static final _hasMipMap = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__hasMipMap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasMipMap()
  bool hasMipMap() {
    return _hasMipMap(reference).boolean;
  }

  static final _setHasMipMap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Uint8)>>("Bitmap__setHasMipMap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void setHasMipMap(boolean z)
  void setHasMipMap(
    bool z,
  ) {
    return _setHasMipMap(reference, z ? 1 : 0).check();
  }

  static final _getColorSpace = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getColorSpace")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.ColorSpace getColorSpace()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getColorSpace() {
    return const jni.JObjectType().fromRef(_getColorSpace(reference).object);
  }

  static final _setColorSpace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__setColorSpace")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setColorSpace(android.graphics.ColorSpace colorSpace)
  void setColorSpace(
    jni.JObject colorSpace,
  ) {
    return _setColorSpace(reference, colorSpace.reference).check();
  }

  static final _hasGainmap = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__hasGainmap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean hasGainmap()
  bool hasGainmap() {
    return _hasGainmap(reference).boolean;
  }

  static final _getGainmap = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getGainmap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Gainmap getGainmap()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getGainmap() {
    return const jni.JObjectType().fromRef(_getGainmap(reference).object);
  }

  static final _setGainmap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__setGainmap")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void setGainmap(android.graphics.Gainmap gainmap)
  void setGainmap(
    jni.JObject gainmap,
  ) {
    return _setGainmap(reference, gainmap.reference).check();
  }

  static final _eraseColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__eraseColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void eraseColor(int i)
  void eraseColor(
    int i,
  ) {
    return _eraseColor(reference, i).check();
  }

  static final _eraseColor1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int64)>>("Bitmap__eraseColor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void eraseColor(long j)
  void eraseColor1(
    int j,
  ) {
    return _eraseColor1(reference, j).check();
  }

  static final _getPixel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Bitmap__getPixel")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public int getPixel(int i, int i1)
  int getPixel(
    int i,
    int i1,
  ) {
    return _getPixel(reference, i, i1).integer;
  }

  static final _getColor = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Bitmap__getColor")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public android.graphics.Color getColor(int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getColor(
    int i,
    int i1,
  ) {
    return const jni.JObjectType().fromRef(_getColor(reference, i, i1).object);
  }

  static final _getPixels = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("Bitmap__getPixels")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, int, int, int, int, int)>();

  /// from: public void getPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)
  void getPixels(
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    return _getPixels(reference, is0.reference, i, i1, i2, i3, i4, i5).check();
  }

  static final _setPixel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32)>>("Bitmap__setPixel")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  /// from: public void setPixel(int i, int i1, int i2)
  void setPixel(
    int i,
    int i1,
    int i2,
  ) {
    return _setPixel(reference, i, i1, i2).check();
  }

  static final _setPixels = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("Bitmap__setPixels")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              int, int, int, int, int, int)>();

  /// from: public void setPixels(int[] is, int i, int i1, int i2, int i3, int i4, int i5)
  void setPixels(
    jni.JArray<jni.jint> is0,
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
  ) {
    return _setPixels(reference, is0.reference, i, i1, i2, i3, i4, i5).check();
  }

  static final _describeContents = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    return _describeContents(reference).integer;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Bitmap__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    return _writeToParcel(reference, parcel.reference, i).check();
  }

  static final _extractAlpha = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__extractAlpha")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap extractAlpha()
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap extractAlpha() {
    return const $BitmapType().fromRef(_extractAlpha(reference).object);
  }

  static final _extractAlpha1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__extractAlpha1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap extractAlpha(android.graphics.Paint paint, int[] is)
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap extractAlpha1(
    jni.JObject paint,
    jni.JArray<jni.jint> is0,
  ) {
    return const $BitmapType().fromRef(
        _extractAlpha1(reference, paint.reference, is0.reference).object);
  }

  static final _sameAs = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Bitmap__sameAs")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean sameAs(android.graphics.Bitmap bitmap)
  bool sameAs(
    Bitmap bitmap,
  ) {
    return _sameAs(reference, bitmap.reference).boolean;
  }

  static final _prepareToDraw = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__prepareToDraw")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void prepareToDraw()
  void prepareToDraw() {
    return _prepareToDraw(reference).check();
  }

  static final _getHardwareBuffer = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Bitmap__getHardwareBuffer")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.hardware.HardwareBuffer getHardwareBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getHardwareBuffer() {
    return const jni.JObjectType()
        .fromRef(_getHardwareBuffer(reference).object);
  }
}

final class $BitmapType extends jni.JObjType<Bitmap> {
  const $BitmapType();

  @override
  String get signature => r"Landroid/graphics/Bitmap;";

  @override
  Bitmap fromRef(jni.JObjectPtr ref) => Bitmap.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BitmapType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapType) && other is $BitmapType;
  }
}

/// from: android.graphics.BitmapFactory$Options
class BitmapFactory_Options extends jni.JObject {
  @override
  late final jni.JObjType<BitmapFactory_Options> $type = type;

  BitmapFactory_Options.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $BitmapFactory_OptionsType();
  static final _get_inBitmap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inBitmap")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inBitmap = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__inBitmap")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap inBitmap
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap get inBitmap =>
      const $BitmapType().fromRef(_get_inBitmap(reference).object);

  /// from: public android.graphics.Bitmap inBitmap
  /// The returned object must be released after use, by calling the [release] method.
  set inBitmap(Bitmap value) =>
      _set_inBitmap(reference, value.reference).check();

  static final _get_inDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inDensity")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__inDensity")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int inDensity
  int get inDensity => _get_inDensity(reference).integer;

  /// from: public int inDensity
  set inDensity(int value) => _set_inDensity(reference, value).check();

  static final _get_inDither = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inDither")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inDither = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inDither")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inDither
  bool get inDither => _get_inDither(reference).boolean;

  /// from: public boolean inDither
  set inDither(bool value) => _set_inDither(reference, value ? 1 : 0).check();

  static final _get_inInputShareable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inInputShareable")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inInputShareable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inInputShareable")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inInputShareable
  bool get inInputShareable => _get_inInputShareable(reference).boolean;

  /// from: public boolean inInputShareable
  set inInputShareable(bool value) =>
      _set_inInputShareable(reference, value ? 1 : 0).check();

  static final _get_inJustDecodeBounds = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inJustDecodeBounds")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inJustDecodeBounds = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inJustDecodeBounds")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inJustDecodeBounds
  bool get inJustDecodeBounds => _get_inJustDecodeBounds(reference).boolean;

  /// from: public boolean inJustDecodeBounds
  set inJustDecodeBounds(bool value) =>
      _set_inJustDecodeBounds(reference, value ? 1 : 0).check();

  static final _get_inMutable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inMutable")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inMutable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inMutable")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inMutable
  bool get inMutable => _get_inMutable(reference).boolean;

  /// from: public boolean inMutable
  set inMutable(bool value) => _set_inMutable(reference, value ? 1 : 0).check();

  static final _get_inPreferQualityOverSpeed = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inPreferQualityOverSpeed")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inPreferQualityOverSpeed = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(jni.JObjectPtr, ffi.Uint8)>>(
          "set_BitmapFactory_Options__inPreferQualityOverSpeed")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inPreferQualityOverSpeed
  bool get inPreferQualityOverSpeed =>
      _get_inPreferQualityOverSpeed(reference).boolean;

  /// from: public boolean inPreferQualityOverSpeed
  set inPreferQualityOverSpeed(bool value) =>
      _set_inPreferQualityOverSpeed(reference, value ? 1 : 0).check();

  static final _get_inPreferredColorSpace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inPreferredColorSpace")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inPreferredColorSpace = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__inPreferredColorSpace")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.ColorSpace inPreferredColorSpace
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get inPreferredColorSpace => const jni.JObjectType()
      .fromRef(_get_inPreferredColorSpace(reference).object);

  /// from: public android.graphics.ColorSpace inPreferredColorSpace
  /// The returned object must be released after use, by calling the [release] method.
  set inPreferredColorSpace(jni.JObject value) =>
      _set_inPreferredColorSpace(reference, value.reference).check();

  static final _get_inPreferredConfig = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inPreferredConfig")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inPreferredConfig = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__inPreferredConfig")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap$Config inPreferredConfig
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap_Config get inPreferredConfig => const $Bitmap_ConfigType()
      .fromRef(_get_inPreferredConfig(reference).object);

  /// from: public android.graphics.Bitmap$Config inPreferredConfig
  /// The returned object must be released after use, by calling the [release] method.
  set inPreferredConfig(Bitmap_Config value) =>
      _set_inPreferredConfig(reference, value.reference).check();

  static final _get_inPremultiplied = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inPremultiplied")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inPremultiplied = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inPremultiplied")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inPremultiplied
  bool get inPremultiplied => _get_inPremultiplied(reference).boolean;

  /// from: public boolean inPremultiplied
  set inPremultiplied(bool value) =>
      _set_inPremultiplied(reference, value ? 1 : 0).check();

  static final _get_inPurgeable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inPurgeable")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inPurgeable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inPurgeable")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inPurgeable
  bool get inPurgeable => _get_inPurgeable(reference).boolean;

  /// from: public boolean inPurgeable
  set inPurgeable(bool value) =>
      _set_inPurgeable(reference, value ? 1 : 0).check();

  static final _get_inSampleSize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inSampleSize")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inSampleSize = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__inSampleSize")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int inSampleSize
  int get inSampleSize => _get_inSampleSize(reference).integer;

  /// from: public int inSampleSize
  set inSampleSize(int value) => _set_inSampleSize(reference, value).check();

  static final _get_inScaled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inScaled")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inScaled = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__inScaled")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean inScaled
  bool get inScaled => _get_inScaled(reference).boolean;

  /// from: public boolean inScaled
  set inScaled(bool value) => _set_inScaled(reference, value ? 1 : 0).check();

  static final _get_inScreenDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inScreenDensity")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inScreenDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__inScreenDensity")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int inScreenDensity
  int get inScreenDensity => _get_inScreenDensity(reference).integer;

  /// from: public int inScreenDensity
  set inScreenDensity(int value) =>
      _set_inScreenDensity(reference, value).check();

  static final _get_inTargetDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inTargetDensity")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inTargetDensity = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__inTargetDensity")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int inTargetDensity
  int get inTargetDensity => _get_inTargetDensity(reference).integer;

  /// from: public int inTargetDensity
  set inTargetDensity(int value) =>
      _set_inTargetDensity(reference, value).check();

  static final _get_inTempStorage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__inTempStorage")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_inTempStorage = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__inTempStorage")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] inTempStorage
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> get inTempStorage =>
      const jni.JArrayType(jni.jbyteType())
          .fromRef(_get_inTempStorage(reference).object);

  /// from: public byte[] inTempStorage
  /// The returned object must be released after use, by calling the [release] method.
  set inTempStorage(jni.JArray<jni.jbyte> value) =>
      _set_inTempStorage(reference, value.reference).check();

  static final _get_mCancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__mCancel")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_mCancel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Uint8)>>("set_BitmapFactory_Options__mCancel")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public boolean mCancel
  bool get mCancel => _get_mCancel(reference).boolean;

  /// from: public boolean mCancel
  set mCancel(bool value) => _set_mCancel(reference, value ? 1 : 0).check();

  static final _get_outColorSpace = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__outColorSpace")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_outColorSpace = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__outColorSpace")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.ColorSpace outColorSpace
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject get outColorSpace =>
      const jni.JObjectType().fromRef(_get_outColorSpace(reference).object);

  /// from: public android.graphics.ColorSpace outColorSpace
  /// The returned object must be released after use, by calling the [release] method.
  set outColorSpace(jni.JObject value) =>
      _set_outColorSpace(reference, value.reference).check();

  static final _get_outConfig = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__outConfig")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_outConfig = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__outConfig")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap$Config outConfig
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap_Config get outConfig =>
      const $Bitmap_ConfigType().fromRef(_get_outConfig(reference).object);

  /// from: public android.graphics.Bitmap$Config outConfig
  /// The returned object must be released after use, by calling the [release] method.
  set outConfig(Bitmap_Config value) =>
      _set_outConfig(reference, value.reference).check();

  static final _get_outHeight = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__outHeight")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_outHeight = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__outHeight")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int outHeight
  int get outHeight => _get_outHeight(reference).integer;

  /// from: public int outHeight
  set outHeight(int value) => _set_outHeight(reference, value).check();

  static final _get_outMimeType = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__outMimeType")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_outMimeType = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      jni.JObjectPtr, ffi.Pointer<ffi.Void>)>>(
          "set_BitmapFactory_Options__outMimeType")
      .asFunction<
          jni.JniResult Function(jni.JObjectPtr, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String outMimeType
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString get outMimeType =>
      const jni.JStringType().fromRef(_get_outMimeType(reference).object);

  /// from: public java.lang.String outMimeType
  /// The returned object must be released after use, by calling the [release] method.
  set outMimeType(jni.JString value) =>
      _set_outMimeType(reference, value.reference).check();

  static final _get_outWidth = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_BitmapFactory_Options__outWidth")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_outWidth = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(jni.JObjectPtr,
                  ffi.Int32)>>("set_BitmapFactory_Options__outWidth")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int outWidth
  int get outWidth => _get_outWidth(reference).integer;

  /// from: public int outWidth
  set outWidth(int value) => _set_outWidth(reference, value).check();

  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "BitmapFactory_Options__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory BitmapFactory_Options() {
    return BitmapFactory_Options.fromRef(_new0().object);
  }

  static final _requestCancelDecode = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory_Options__requestCancelDecode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void requestCancelDecode()
  void requestCancelDecode() {
    return _requestCancelDecode(reference).check();
  }
}

final class $BitmapFactory_OptionsType
    extends jni.JObjType<BitmapFactory_Options> {
  const $BitmapFactory_OptionsType();

  @override
  String get signature => r"Landroid/graphics/BitmapFactory$Options;";

  @override
  BitmapFactory_Options fromRef(jni.JObjectPtr ref) =>
      BitmapFactory_Options.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BitmapFactory_OptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactory_OptionsType) &&
        other is $BitmapFactory_OptionsType;
  }
}

/// from: android.graphics.BitmapFactory
class BitmapFactory extends jni.JObject {
  @override
  late final jni.JObjType<BitmapFactory> $type = type;

  BitmapFactory.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $BitmapFactoryType();
  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "BitmapFactory__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory BitmapFactory() {
    return BitmapFactory.fromRef(_new0().object);
  }

  static final _decodeFile = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("BitmapFactory__decodeFile")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeFile(java.lang.String string, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeFile(
    jni.JString string,
    BitmapFactory_Options options,
  ) {
    return const $BitmapType()
        .fromRef(_decodeFile(string.reference, options.reference).object);
  }

  static final _decodeFile1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory__decodeFile1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeFile(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeFile1(
    jni.JString string,
  ) {
    return const $BitmapType().fromRef(_decodeFile1(string.reference).object);
  }

  static final _decodeResourceStream = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory__decodeResourceStream")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeResourceStream(android.content.res.Resources resources, android.util.TypedValue typedValue, java.io.InputStream inputStream, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeResourceStream(
    jni.JObject resources,
    jni.JObject typedValue,
    jni.JObject inputStream,
    Rect rect,
    BitmapFactory_Options options,
  ) {
    return const $BitmapType().fromRef(_decodeResourceStream(
            resources.reference,
            typedValue.reference,
            inputStream.reference,
            rect.reference,
            options.reference)
        .object);
  }

  static final _decodeResource = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("BitmapFactory__decodeResource")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeResource(android.content.res.Resources resources, int i, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeResource(
    jni.JObject resources,
    int i,
    BitmapFactory_Options options,
  ) {
    return const $BitmapType().fromRef(
        _decodeResource(resources.reference, i, options.reference).object);
  }

  static final _decodeResource1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("BitmapFactory__decodeResource1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public android.graphics.Bitmap decodeResource(android.content.res.Resources resources, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeResource1(
    jni.JObject resources,
    int i,
  ) {
    return const $BitmapType()
        .fromRef(_decodeResource1(resources.reference, i).object);
  }

  static final _decodeByteArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("BitmapFactory__decodeByteArray")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeByteArray(byte[] bs, int i, int i1, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeByteArray(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    BitmapFactory_Options options,
  ) {
    return const $BitmapType().fromRef(
        _decodeByteArray(bs.reference, i, i1, options.reference).object);
  }

  static final _decodeByteArray1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("BitmapFactory__decodeByteArray1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: static public android.graphics.Bitmap decodeByteArray(byte[] bs, int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeByteArray1(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
  ) {
    return const $BitmapType()
        .fromRef(_decodeByteArray1(bs.reference, i, i1).object);
  }

  static final _decodeStream = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("BitmapFactory__decodeStream")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeStream(java.io.InputStream inputStream, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeStream(
    jni.JObject inputStream,
    Rect rect,
    BitmapFactory_Options options,
  ) {
    return const $BitmapType().fromRef(
        _decodeStream(inputStream.reference, rect.reference, options.reference)
            .object);
  }

  static final _decodeStream1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory__decodeStream1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeStream(java.io.InputStream inputStream)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeStream1(
    jni.JObject inputStream,
  ) {
    return const $BitmapType()
        .fromRef(_decodeStream1(inputStream.reference).object);
  }

  static final _decodeFileDescriptor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory__decodeFileDescriptor")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeFileDescriptor(java.io.FileDescriptor fileDescriptor, android.graphics.Rect rect, android.graphics.BitmapFactory$Options options)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeFileDescriptor(
    jni.JObject fileDescriptor,
    Rect rect,
    BitmapFactory_Options options,
  ) {
    return const $BitmapType().fromRef(_decodeFileDescriptor(
            fileDescriptor.reference, rect.reference, options.reference)
        .object);
  }

  static final _decodeFileDescriptor1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BitmapFactory__decodeFileDescriptor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Bitmap decodeFileDescriptor(java.io.FileDescriptor fileDescriptor)
  /// The returned object must be released after use, by calling the [release] method.
  static Bitmap decodeFileDescriptor1(
    jni.JObject fileDescriptor,
  ) {
    return const $BitmapType()
        .fromRef(_decodeFileDescriptor1(fileDescriptor.reference).object);
  }
}

final class $BitmapFactoryType extends jni.JObjType<BitmapFactory> {
  const $BitmapFactoryType();

  @override
  String get signature => r"Landroid/graphics/BitmapFactory;";

  @override
  BitmapFactory fromRef(jni.JObjectPtr ref) => BitmapFactory.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BitmapFactoryType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BitmapFactoryType) &&
        other is $BitmapFactoryType;
  }
}

/// from: android.graphics.Point
class Point extends jni.JObject {
  @override
  late final jni.JObjType<Point> $type = type;

  Point.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $PointType();
  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Point__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      const jni.JObjectType().fromRef(_get_CREATOR().object);

  static final _get_x = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Point__x")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_x = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Point__x")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int x
  int get x => _get_x(reference).integer;

  /// from: public int x
  set x(int value) => _set_x(reference, value).check();

  static final _get_y = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Point__y")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_y = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Point__y")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int y
  int get y => _get_y(reference).integer;

  /// from: public int y
  set y(int value) => _set_y(reference, value).check();

  static final _new0 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Point__new0")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Point() {
    return Point.fromRef(_new0().object);
  }

  static final _new1 = jniLookup<
              ffi.NativeFunction<jni.JniResult Function(ffi.Int32, ffi.Int32)>>(
          "Point__new1")
      .asFunction<jni.JniResult Function(int, int)>();

  /// from: public void <init>(int i, int i1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Point.new1(
    int i,
    int i1,
  ) {
    return Point.fromRef(_new1(i, i1).object);
  }

  static final _new2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Point__new2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.Point point)
  /// The returned object must be released after use, by calling the [release] method.
  factory Point.new2(
    Point point,
  ) {
    return Point.fromRef(_new2(point.reference).object);
  }

  static final _set0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>("Point__set0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void set(int i, int i1)
  void set0(
    int i,
    int i1,
  ) {
    return _set0(reference, i, i1).check();
  }

  static final _negate = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Point__negate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final void negate()
  void negate() {
    return _negate(reference).check();
  }

  static final _offset = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Point__offset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final void offset(int i, int i1)
  void offset(
    int i,
    int i1,
  ) {
    return _offset(reference, i, i1).check();
  }

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Point__equals1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public final boolean equals(int i, int i1)
  bool equals1(
    int i,
    int i1,
  ) {
    return _equals1(reference, i, i1).boolean;
  }

  static final _equals2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Point__equals2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals2(
    jni.JObject object,
  ) {
    return _equals2(reference, object.reference).boolean;
  }

  static final _hashCode1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Point__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference).integer;
  }

  static final _toString1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Point__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(_toString1(reference).object);
  }

  static final _describeContents = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Point__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    return _describeContents(reference).integer;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Point__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    return _writeToParcel(reference, parcel.reference, i).check();
  }

  static final _readFromParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Point__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel parcel)
  void readFromParcel(
    jni.JObject parcel,
  ) {
    return _readFromParcel(reference, parcel.reference).check();
  }
}

final class $PointType extends jni.JObjType<Point> {
  const $PointType();

  @override
  String get signature => r"Landroid/graphics/Point;";

  @override
  Point fromRef(jni.JObjectPtr ref) => Point.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($PointType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($PointType) && other is $PointType;
  }
}

/// from: android.graphics.Rect
class Rect extends jni.JObject {
  @override
  late final jni.JObjType<Rect> $type = type;

  Rect.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $RectType();
  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Rect__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      const jni.JObjectType().fromRef(_get_CREATOR().object);

  static final _get_bottom = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Rect__bottom")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_bottom = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Rect__bottom")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int bottom
  int get bottom => _get_bottom(reference).integer;

  /// from: public int bottom
  set bottom(int value) => _set_bottom(reference, value).check();

  static final _get_left = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Rect__left")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_left = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Rect__left")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int left
  int get left => _get_left(reference).integer;

  /// from: public int left
  set left(int value) => _set_left(reference, value).check();

  static final _get_right = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Rect__right")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_right = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Rect__right")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int right
  int get right => _get_right(reference).integer;

  /// from: public int right
  set right(int value) => _set_right(reference, value).check();

  static final _get_top = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                jni.JObjectPtr,
              )>>("get_Rect__top")
      .asFunction<
          jni.JniResult Function(
            jni.JObjectPtr,
          )>();

  static final _set_top = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  jni.JObjectPtr, ffi.Int32)>>("set_Rect__top")
      .asFunction<jni.JniResult Function(jni.JObjectPtr, int)>();

  /// from: public int top
  int get top => _get_top(reference).integer;

  /// from: public int top
  set top(int value) => _set_top(reference, value).check();

  static final _new0 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Rect__new0")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Rect() {
    return Rect.fromRef(_new0().object);
  }

  static final _new1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32, ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__new1")
      .asFunction<jni.JniResult Function(int, int, int, int)>();

  /// from: public void <init>(int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  factory Rect.new1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return Rect.fromRef(_new1(i, i1, i2, i3).object);
  }

  static final _new2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__new2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(android.graphics.Rect rect)
  /// The returned object must be released after use, by calling the [release] method.
  factory Rect.new2(
    Rect rect,
  ) {
    return Rect.fromRef(_new2(rect.reference).object);
  }

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return _equals1(reference, object.reference).boolean;
  }

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference).integer;
  }

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(_toString1(reference).object);
  }

  static final _toShortString = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__toShortString")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toShortString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toShortString() {
    return const jni.JStringType().fromRef(_toShortString(reference).object);
  }

  static final _flattenToString = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__flattenToString")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String flattenToString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString flattenToString() {
    return const jni.JStringType().fromRef(_flattenToString(reference).object);
  }

  static final _unflattenFromString = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__unflattenFromString")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.graphics.Rect unflattenFromString(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Rect unflattenFromString(
    jni.JString string,
  ) {
    return const $RectType()
        .fromRef(_unflattenFromString(string.reference).object);
  }

  static final _isEmpty = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__isEmpty")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isEmpty()
  bool isEmpty() {
    return _isEmpty(reference).boolean;
  }

  static final _width = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__width")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int width()
  int width() {
    return _width(reference).integer;
  }

  static final _height = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__height")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int height()
  int height() {
    return _height(reference).integer;
  }

  static final _centerX = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__centerX")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int centerX()
  int centerX() {
    return _centerX(reference).integer;
  }

  static final _centerY = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__centerY")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int centerY()
  int centerY() {
    return _centerY(reference).integer;
  }

  static final _exactCenterX = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__exactCenterX")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float exactCenterX()
  double exactCenterX() {
    return _exactCenterX(reference).float;
  }

  static final _exactCenterY = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__exactCenterY")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public float exactCenterY()
  double exactCenterY() {
    return _exactCenterY(reference).float;
  }

  static final _setEmpty = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__setEmpty")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void setEmpty()
  void setEmpty() {
    return _setEmpty(reference).check();
  }

  static final _set0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__set0")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public void set(int i, int i1, int i2, int i3)
  void set0(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _set0(reference, i, i1, i2, i3).check();
  }

  static final _set1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>("Rect__set1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void set(android.graphics.Rect rect)
  void set1(
    Rect rect,
  ) {
    return _set1(reference, rect.reference).check();
  }

  static final _offset = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>("Rect__offset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void offset(int i, int i1)
  void offset(
    int i,
    int i1,
  ) {
    return _offset(reference, i, i1).check();
  }

  static final _offsetTo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Rect__offsetTo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void offsetTo(int i, int i1)
  void offsetTo(
    int i,
    int i1,
  ) {
    return _offsetTo(reference, i, i1).check();
  }

  static final _inset = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>("Rect__inset")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void inset(int i, int i1)
  void inset(
    int i,
    int i1,
  ) {
    return _inset(reference, i, i1).check();
  }

  static final _inset1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__inset1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void inset(android.graphics.Insets insets)
  void inset1(
    jni.JObject insets,
  ) {
    return _inset1(reference, insets.reference).check();
  }

  static final _inset2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__inset2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public void inset(int i, int i1, int i2, int i3)
  void inset2(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _inset2(reference, i, i1, i2, i3).check();
  }

  static final _contains = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32)>>("Rect__contains")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public boolean contains(int i, int i1)
  bool contains(
    int i,
    int i1,
  ) {
    return _contains(reference, i, i1).boolean;
  }

  static final _contains1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__contains1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public boolean contains(int i, int i1, int i2, int i3)
  bool contains1(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _contains1(reference, i, i1, i2, i3).boolean;
  }

  static final _contains2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__contains2")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean contains(android.graphics.Rect rect)
  bool contains2(
    Rect rect,
  ) {
    return _contains2(reference, rect.reference).boolean;
  }

  static final _intersect = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__intersect")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public boolean intersect(int i, int i1, int i2, int i3)
  bool intersect(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _intersect(reference, i, i1, i2, i3).boolean;
  }

  static final _intersect1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__intersect1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean intersect(android.graphics.Rect rect)
  bool intersect1(
    Rect rect,
  ) {
    return _intersect1(reference, rect.reference).boolean;
  }

  static final _setIntersect = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__setIntersect")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public boolean setIntersect(android.graphics.Rect rect, android.graphics.Rect rect1)
  bool setIntersect(
    Rect rect,
    Rect rect1,
  ) {
    return _setIntersect(reference, rect.reference, rect1.reference).boolean;
  }

  static final _intersects = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__intersects")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public boolean intersects(int i, int i1, int i2, int i3)
  bool intersects(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _intersects(reference, i, i1, i2, i3).boolean;
  }

  static final _intersects1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__intersects1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public boolean intersects(android.graphics.Rect rect, android.graphics.Rect rect1)
  static bool intersects1(
    Rect rect,
    Rect rect1,
  ) {
    return _intersects1(rect.reference, rect1.reference).boolean;
  }

  static final _union = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Int32, ffi.Int32, ffi.Int32)>>("Rect__union")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: public void union(int i, int i1, int i2, int i3)
  void union(
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return _union(reference, i, i1, i2, i3).check();
  }

  static final _union1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__union1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void union(android.graphics.Rect rect)
  void union1(
    Rect rect,
  ) {
    return _union1(reference, rect.reference).check();
  }

  static final _union2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>>("Rect__union2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// from: public void union(int i, int i1)
  void union2(
    int i,
    int i1,
  ) {
    return _union2(reference, i, i1).check();
  }

  static final _sort = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Rect__sort")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void sort()
  void sort() {
    return _sort(reference).check();
  }

  static final _describeContents = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Rect__describeContents")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int describeContents()
  int describeContents() {
    return _describeContents(reference).integer;
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Rect__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void writeToParcel(android.os.Parcel parcel, int i)
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    return _writeToParcel(reference, parcel.reference, i).check();
  }

  static final _readFromParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Rect__readFromParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void readFromParcel(android.os.Parcel parcel)
  void readFromParcel(
    jni.JObject parcel,
  ) {
    return _readFromParcel(reference, parcel.reference).check();
  }
}

final class $RectType extends jni.JObjType<Rect> {
  const $RectType();

  @override
  String get signature => r"Landroid/graphics/Rect;";

  @override
  Rect fromRef(jni.JObjectPtr ref) => Rect.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RectType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RectType) && other is $RectType;
  }
}

/// from: android.net.Uri$Builder
class Uri_Builder extends jni.JObject {
  @override
  late final jni.JObjType<Uri_Builder> $type = type;

  Uri_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Uri_BuilderType();
  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "Uri_Builder__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Uri_Builder() {
    return Uri_Builder.fromRef(_new0().object);
  }

  static final _scheme = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__scheme")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder scheme(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder scheme(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_scheme(reference, string.reference).object);
  }

  static final _opaquePart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__opaquePart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder opaquePart(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder opaquePart(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_opaquePart(reference, string.reference).object);
  }

  static final _encodedOpaquePart = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__encodedOpaquePart")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedOpaquePart(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedOpaquePart(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_encodedOpaquePart(reference, string.reference).object);
  }

  static final _authority = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__authority")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder authority(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder authority(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_authority(reference, string.reference).object);
  }

  static final _encodedAuthority = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__encodedAuthority")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedAuthority(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedAuthority(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_encodedAuthority(reference, string.reference).object);
  }

  static final _path = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__path")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder path(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder path(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_path(reference, string.reference).object);
  }

  static final _encodedPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__encodedPath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedPath(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_encodedPath(reference, string.reference).object);
  }

  static final _appendPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__appendPath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder appendPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder appendPath(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_appendPath(reference, string.reference).object);
  }

  static final _appendEncodedPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__appendEncodedPath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder appendEncodedPath(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder appendEncodedPath(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_appendEncodedPath(reference, string.reference).object);
  }

  static final _query = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__query")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder query(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder query(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_query(reference, string.reference).object);
  }

  static final _encodedQuery = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__encodedQuery")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedQuery(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedQuery(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_encodedQuery(reference, string.reference).object);
  }

  static final _fragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__fragment")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder fragment(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder fragment(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_fragment(reference, string.reference).object);
  }

  static final _encodedFragment = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__encodedFragment")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder encodedFragment(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder encodedFragment(
    jni.JString string,
  ) {
    return const $Uri_BuilderType()
        .fromRef(_encodedFragment(reference, string.reference).object);
  }

  static final _appendQueryParameter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri_Builder__appendQueryParameter")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder appendQueryParameter(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder appendQueryParameter(
    jni.JString string,
    jni.JString string1,
  ) {
    return const $Uri_BuilderType().fromRef(
        _appendQueryParameter(reference, string.reference, string1.reference)
            .object);
  }

  static final _clearQuery = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri_Builder__clearQuery")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri$Builder clearQuery()
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder clearQuery() {
    return const $Uri_BuilderType().fromRef(_clearQuery(reference).object);
  }

  static final _build = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri build()
  /// The returned object must be released after use, by calling the [release] method.
  Uri build() {
    return const $UriType().fromRef(_build(reference).object);
  }

  static final _toString1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri_Builder__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(_toString1(reference).object);
  }
}

final class $Uri_BuilderType extends jni.JObjType<Uri_Builder> {
  const $Uri_BuilderType();

  @override
  String get signature => r"Landroid/net/Uri$Builder;";

  @override
  Uri_Builder fromRef(jni.JObjectPtr ref) => Uri_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Uri_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Uri_BuilderType) && other is $Uri_BuilderType;
  }
}

/// from: android.net.Uri
class Uri extends jni.JObject {
  @override
  late final jni.JObjType<Uri> $type = type;

  Uri.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $UriType();
  static final _get_CREATOR =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "get_Uri__CREATOR")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.os.Parcelable$Creator CREATOR
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      const jni.JObjectType().fromRef(_get_CREATOR().object);

  static final _get_EMPTY =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("get_Uri__EMPTY")
          .asFunction<jni.JniResult Function()>();

  /// from: static public final android.net.Uri EMPTY
  /// The returned object must be released after use, by calling the [release] method.
  static Uri get EMPTY => const $UriType().fromRef(_get_EMPTY().object);

  static final _isHierarchical = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__isHierarchical")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isHierarchical()
  bool isHierarchical() {
    return _isHierarchical(reference).boolean;
  }

  static final _isOpaque = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__isOpaque")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isOpaque()
  bool isOpaque() {
    return _isOpaque(reference).boolean;
  }

  static final _isRelative = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__isRelative")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isRelative()
  bool isRelative() {
    return _isRelative(reference).boolean;
  }

  static final _isAbsolute = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__isAbsolute")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isAbsolute()
  bool isAbsolute() {
    return _isAbsolute(reference).boolean;
  }

  static final _getScheme = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__getScheme")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getScheme()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getScheme() {
    return const jni.JStringType().fromRef(_getScheme(reference).object);
  }

  static final _getSchemeSpecificPart = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getSchemeSpecificPart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getSchemeSpecificPart()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSchemeSpecificPart() {
    return const jni.JStringType()
        .fromRef(_getSchemeSpecificPart(reference).object);
  }

  static final _getEncodedSchemeSpecificPart = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedSchemeSpecificPart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedSchemeSpecificPart()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedSchemeSpecificPart() {
    return const jni.JStringType()
        .fromRef(_getEncodedSchemeSpecificPart(reference).object);
  }

  static final _getAuthority = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getAuthority")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getAuthority()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAuthority() {
    return const jni.JStringType().fromRef(_getAuthority(reference).object);
  }

  static final _getEncodedAuthority = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedAuthority")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedAuthority()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedAuthority() {
    return const jni.JStringType()
        .fromRef(_getEncodedAuthority(reference).object);
  }

  static final _getUserInfo = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getUserInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getUserInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUserInfo() {
    return const jni.JStringType().fromRef(_getUserInfo(reference).object);
  }

  static final _getEncodedUserInfo = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedUserInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedUserInfo()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedUserInfo() {
    return const jni.JStringType()
        .fromRef(_getEncodedUserInfo(reference).object);
  }

  static final _getHost = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__getHost")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getHost()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getHost() {
    return const jni.JStringType().fromRef(_getHost(reference).object);
  }

  static final _getPort = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__getPort")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract int getPort()
  int getPort() {
    return _getPort(reference).integer;
  }

  static final _getPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__getPath")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPath() {
    return const jni.JStringType().fromRef(_getPath(reference).object);
  }

  static final _getEncodedPath = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedPath")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedPath()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedPath() {
    return const jni.JStringType().fromRef(_getEncodedPath(reference).object);
  }

  static final _getQuery = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__getQuery")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getQuery()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getQuery() {
    return const jni.JStringType().fromRef(_getQuery(reference).object);
  }

  static final _getEncodedQuery = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedQuery")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedQuery()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedQuery() {
    return const jni.JStringType().fromRef(_getEncodedQuery(reference).object);
  }

  static final _getFragment = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getFragment")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getFragment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFragment() {
    return const jni.JStringType().fromRef(_getFragment(reference).object);
  }

  static final _getEncodedFragment = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getEncodedFragment")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getEncodedFragment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getEncodedFragment() {
    return const jni.JStringType()
        .fromRef(_getEncodedFragment(reference).object);
  }

  static final _getPathSegments = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getPathSegments")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.util.List getPathSegments()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getPathSegments() {
    return const jni.JListType(jni.JStringType())
        .fromRef(_getPathSegments(reference).object);
  }

  static final _getLastPathSegment = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getLastPathSegment")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String getLastPathSegment()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLastPathSegment() {
    return const jni.JStringType()
        .fromRef(_getLastPathSegment(reference).object);
  }

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return _equals1(reference, object.reference).boolean;
  }

  static final _hashCode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference).integer;
  }

  static final _compareTo = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__compareTo")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(android.net.Uri uri)
  int compareTo(
    Uri uri,
  ) {
    return _compareTo(reference, uri.reference).integer;
  }

  static final _toString1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__toString1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.String toString()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return const jni.JStringType().fromRef(_toString1(reference).object);
  }

  static final _buildUpon = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__buildUpon")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract android.net.Uri$Builder buildUpon()
  /// The returned object must be released after use, by calling the [release] method.
  Uri_Builder buildUpon() {
    return const $Uri_BuilderType().fromRef(_buildUpon(reference).object);
  }

  static final _parse = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__parse")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri parse(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri parse(
    jni.JString string,
  ) {
    return const $UriType().fromRef(_parse(string.reference).object);
  }

  static final _fromFile = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__fromFile")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri fromFile(java.io.File file)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri fromFile(
    jni.JObject file,
  ) {
    return const $UriType().fromRef(_fromFile(file.reference).object);
  }

  static final _fromParts = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__fromParts")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri fromParts(java.lang.String string, java.lang.String string1, java.lang.String string2)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri fromParts(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    return const $UriType().fromRef(
        _fromParts(string.reference, string1.reference, string2.reference)
            .object);
  }

  static final _getQueryParameterNames = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__getQueryParameterNames")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.Set getQueryParameterNames()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JSet<jni.JString> getQueryParameterNames() {
    return const jni.JSetType(jni.JStringType())
        .fromRef(_getQueryParameterNames(reference).object);
  }

  static final _getQueryParameters = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__getQueryParameters")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getQueryParameters(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getQueryParameters(
    jni.JString string,
  ) {
    return const jni.JListType(jni.JStringType())
        .fromRef(_getQueryParameters(reference, string.reference).object);
  }

  static final _getQueryParameter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__getQueryParameter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getQueryParameter(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getQueryParameter(
    jni.JString string,
  ) {
    return const jni.JStringType()
        .fromRef(_getQueryParameter(reference, string.reference).object);
  }

  static final _getBooleanQueryParameter = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Uint8)>>("Uri__getBooleanQueryParameter")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public boolean getBooleanQueryParameter(java.lang.String string, boolean z)
  bool getBooleanQueryParameter(
    jni.JString string,
    bool z,
  ) {
    return _getBooleanQueryParameter(reference, string.reference, z ? 1 : 0)
        .boolean;
  }

  static final _normalizeScheme = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Uri__normalizeScheme")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.net.Uri normalizeScheme()
  /// The returned object must be released after use, by calling the [release] method.
  Uri normalizeScheme() {
    return const $UriType().fromRef(_normalizeScheme(reference).object);
  }

  static final _writeToParcel = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__writeToParcel")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public void writeToParcel(android.os.Parcel parcel, android.net.Uri uri)
  static void writeToParcel(
    jni.JObject parcel,
    Uri uri,
  ) {
    return _writeToParcel(parcel.reference, uri.reference).check();
  }

  static final _encode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__encode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String encode(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString encode(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(_encode(string.reference).object);
  }

  static final _encode1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__encode1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String encode(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString encode1(
    jni.JString string,
    jni.JString string1,
  ) {
    return const jni.JStringType()
        .fromRef(_encode1(string.reference, string1.reference).object);
  }

  static final _decode = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Uri__decode")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.lang.String decode(java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JString decode(
    jni.JString string,
  ) {
    return const jni.JStringType().fromRef(_decode(string.reference).object);
  }

  static final _withAppendedPath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__withAppendedPath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public android.net.Uri withAppendedPath(android.net.Uri uri, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  static Uri withAppendedPath(
    Uri uri,
    jni.JString string,
  ) {
    return const $UriType()
        .fromRef(_withAppendedPath(uri.reference, string.reference).object);
  }

  static final _compareTo1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Uri__compareTo1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public int compareTo(java.lang.Object object)
  int compareTo1(
    jni.JObject object,
  ) {
    return _compareTo1(reference, object.reference).integer;
  }
}

final class $UriType extends jni.JObjType<Uri> {
  const $UriType();

  @override
  String get signature => r"Landroid/net/Uri;";

  @override
  Uri fromRef(jni.JObjectPtr ref) => Uri.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($UriType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($UriType) && other is $UriType;
  }
}

/// from: com.google.android.gms.tasks.Task
class Task<$TResult extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<Task<$TResult>> $type = type(TResult);

  final jni.JObjType<$TResult> TResult;

  Task.fromRef(
    this.TResult,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $TaskType<$TResult> type<$TResult extends jni.JObject>(
    jni.JObjType<$TResult> TResult,
  ) {
    return $TaskType(
      TResult,
    );
  }

  static final _addOnCanceledListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCanceledListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCanceledListener(com.google.android.gms.tasks.OnCanceledListener onCanceledListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCanceledListener(
    OnCanceledListener onCanceledListener,
  ) {
    return $TaskType(TResult).fromRef(
        _addOnCanceledListener(reference, onCanceledListener.reference).object);
  }

  static final _addOnCanceledListener1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCanceledListener1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCanceledListener(android.app.Activity activity, com.google.android.gms.tasks.OnCanceledListener onCanceledListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCanceledListener1(
    jni.JObject activity,
    OnCanceledListener onCanceledListener,
  ) {
    return $TaskType(TResult).fromRef(_addOnCanceledListener1(
            reference, activity.reference, onCanceledListener.reference)
        .object);
  }

  static final _addOnCanceledListener2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCanceledListener2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCanceledListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnCanceledListener onCanceledListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCanceledListener2(
    Executor executor,
    OnCanceledListener onCanceledListener,
  ) {
    return $TaskType(TResult).fromRef(_addOnCanceledListener2(
            reference, executor.reference, onCanceledListener.reference)
        .object);
  }

  static final _addOnCompleteListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCompleteListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCompleteListener(com.google.android.gms.tasks.OnCompleteListener onCompleteListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCompleteListener(
    OnCompleteListener<$TResult> onCompleteListener,
  ) {
    return $TaskType(TResult).fromRef(
        _addOnCompleteListener(reference, onCompleteListener.reference).object);
  }

  static final _addOnCompleteListener1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCompleteListener1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCompleteListener(android.app.Activity activity, com.google.android.gms.tasks.OnCompleteListener onCompleteListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCompleteListener1(
    jni.JObject activity,
    OnCompleteListener<$TResult> onCompleteListener,
  ) {
    return $TaskType(TResult).fromRef(_addOnCompleteListener1(
            reference, activity.reference, onCompleteListener.reference)
        .object);
  }

  static final _addOnCompleteListener2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnCompleteListener2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task addOnCompleteListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnCompleteListener onCompleteListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnCompleteListener2(
    Executor executor,
    OnCompleteListener<$TResult> onCompleteListener,
  ) {
    return $TaskType(TResult).fromRef(_addOnCompleteListener2(
            reference, executor.reference, onCompleteListener.reference)
        .object);
  }

  static final _addOnFailureListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnFailureListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnFailureListener(com.google.android.gms.tasks.OnFailureListener onFailureListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnFailureListener(
    OnFailureListener onFailureListener,
  ) {
    return $TaskType(TResult).fromRef(
        _addOnFailureListener(reference, onFailureListener.reference).object);
  }

  static final _addOnFailureListener1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnFailureListener1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnFailureListener(android.app.Activity activity, com.google.android.gms.tasks.OnFailureListener onFailureListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnFailureListener1(
    jni.JObject activity,
    OnFailureListener onFailureListener,
  ) {
    return $TaskType(TResult).fromRef(_addOnFailureListener1(
            reference, activity.reference, onFailureListener.reference)
        .object);
  }

  static final _addOnFailureListener2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnFailureListener2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnFailureListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnFailureListener onFailureListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnFailureListener2(
    Executor executor,
    OnFailureListener onFailureListener,
  ) {
    return $TaskType(TResult).fromRef(_addOnFailureListener2(
            reference, executor.reference, onFailureListener.reference)
        .object);
  }

  static final _addOnSuccessListener = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnSuccessListener")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnSuccessListener(com.google.android.gms.tasks.OnSuccessListener onSuccessListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnSuccessListener(
    OnSuccessListener<$TResult> onSuccessListener,
  ) {
    return $TaskType(TResult).fromRef(
        _addOnSuccessListener(reference, onSuccessListener.reference).object);
  }

  static final _addOnSuccessListener1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnSuccessListener1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnSuccessListener(android.app.Activity activity, com.google.android.gms.tasks.OnSuccessListener onSuccessListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnSuccessListener1(
    jni.JObject activity,
    OnSuccessListener<$TResult> onSuccessListener,
  ) {
    return $TaskType(TResult).fromRef(_addOnSuccessListener1(
            reference, activity.reference, onSuccessListener.reference)
        .object);
  }

  static final _addOnSuccessListener2 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__addOnSuccessListener2")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task addOnSuccessListener(java.util.concurrent.Executor executor, com.google.android.gms.tasks.OnSuccessListener onSuccessListener)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TResult> addOnSuccessListener2(
    Executor executor,
    OnSuccessListener<$TResult> onSuccessListener,
  ) {
    return $TaskType(TResult).fromRef(_addOnSuccessListener2(
            reference, executor.reference, onSuccessListener.reference)
        .object);
  }

  static final _continueWith = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__continueWith")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWith(com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWith<$TContinuationResult extends jni.JObject>(
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return $TaskType(TContinuationResult)
        .fromRef(_continueWith(reference, continuation.reference).object);
  }

  static final _continueWith1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__continueWith1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWith(java.util.concurrent.Executor executor, com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWith1<$TContinuationResult extends jni.JObject>(
    Executor executor,
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return $TaskType(TContinuationResult).fromRef(
        _continueWith1(reference, executor.reference, continuation.reference)
            .object);
  }

  static final _continueWithTask = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__continueWithTask")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWithTask(com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWithTask<$TContinuationResult extends jni.JObject>(
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return $TaskType(TContinuationResult)
        .fromRef(_continueWithTask(reference, continuation.reference).object);
  }

  static final _continueWithTask1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__continueWithTask1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task continueWithTask(java.util.concurrent.Executor executor, com.google.android.gms.tasks.Continuation continuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      continueWithTask1<$TContinuationResult extends jni.JObject>(
    Executor executor,
    jni.JObject continuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return $TaskType(TContinuationResult).fromRef(_continueWithTask1(
            reference, executor.reference, continuation.reference)
        .object);
  }

  static final _onSuccessTask = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__onSuccessTask")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task onSuccessTask(com.google.android.gms.tasks.SuccessContinuation successContinuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      onSuccessTask<$TContinuationResult extends jni.JObject>(
    jni.JObject successContinuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return $TaskType(TContinuationResult).fromRef(
        _onSuccessTask(reference, successContinuation.reference).object);
  }

  static final _onSuccessTask1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__onSuccessTask1")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.android.gms.tasks.Task onSuccessTask(java.util.concurrent.Executor executor, com.google.android.gms.tasks.SuccessContinuation successContinuation)
  /// The returned object must be released after use, by calling the [release] method.
  Task<$TContinuationResult>
      onSuccessTask1<$TContinuationResult extends jni.JObject>(
    Executor executor,
    jni.JObject successContinuation, {
    required jni.JObjType<$TContinuationResult> TContinuationResult,
  }) {
    return $TaskType(TContinuationResult).fromRef(_onSuccessTask1(
            reference, executor.reference, successContinuation.reference)
        .object);
  }

  static final _getException = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Task__getException")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract java.lang.Exception getException()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getException() {
    return const jni.JObjectType().fromRef(_getException(reference).object);
  }

  static final _getResult = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Task__getResult")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract TResult getResult()
  /// The returned object must be released after use, by calling the [release] method.
  $TResult getResult() {
    return TResult.fromRef(_getResult(reference).object);
  }

  static final _getResult1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Task__getResult1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract TResult getResult(java.lang.Class class)
  /// The returned object must be released after use, by calling the [release] method.
  $TResult getResult1<$X extends jni.JObject>(
    jni.JObject class0, {
    required jni.JObjType<$X> X,
  }) {
    return TResult.fromRef(_getResult1(reference, class0.reference).object);
  }

  static final _new0 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>("Task__new0")
          .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory Task({
    required jni.JObjType<$TResult> TResult,
  }) {
    return Task.fromRef(TResult, _new0().object);
  }

  static final _isCanceled = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Task__isCanceled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isCanceled()
  bool isCanceled() {
    return _isCanceled(reference).boolean;
  }

  static final _isComplete = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Task__isComplete")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isComplete()
  bool isComplete() {
    return _isComplete(reference).boolean;
  }

  static final _isSuccessful = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Task__isSuccessful")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract boolean isSuccessful()
  bool isSuccessful() {
    return _isSuccessful(reference).boolean;
  }
}

final class $TaskType<$TResult extends jni.JObject>
    extends jni.JObjType<Task<$TResult>> {
  final jni.JObjType<$TResult> TResult;

  const $TaskType(
    this.TResult,
  );

  @override
  String get signature => r"Lcom/google/android/gms/tasks/Task;";

  @override
  Task<$TResult> fromRef(jni.JObjectPtr ref) => Task.fromRef(TResult, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($TaskType, TResult);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($TaskType<$TResult>) &&
        other is $TaskType<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: com.google.android.gms.tasks.Tasks
class Tasks extends jni.JObject {
  @override
  late final jni.JObjType<Tasks> $type = type;

  Tasks.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $TasksType();
  static final _call = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Tasks__call")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task call(java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$TResult> call<$TResult extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$TResult> TResult,
  }) {
    return $TaskType(TResult).fromRef(_call(callable.reference).object);
  }

  static final _call1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Tasks__call1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task call(java.util.concurrent.Executor executor, java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$TResult> call1<$TResult extends jni.JObject>(
    Executor executor,
    jni.JObject callable, {
    required jni.JObjType<$TResult> TResult,
  }) {
    return $TaskType(TResult)
        .fromRef(_call1(executor.reference, callable.reference).object);
  }

  static final _forCanceled =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Tasks__forCanceled")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.google.android.gms.tasks.Task forCanceled()
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$TResult> forCanceled<$TResult extends jni.JObject>({
    required jni.JObjType<$TResult> TResult,
  }) {
    return $TaskType(TResult).fromRef(_forCanceled().object);
  }

  static final _forException = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__forException")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task forException(java.lang.Exception exception)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$TResult> forException<$TResult extends jni.JObject>(
    jni.JObject exception, {
    required jni.JObjType<$TResult> TResult,
  }) {
    return $TaskType(TResult)
        .fromRef(_forException(exception.reference).object);
  }

  static final _forResult = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__forResult")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task forResult(TResult object)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$TResult> forResult<$TResult extends jni.JObject>(
    $TResult object, {
    jni.JObjType<$TResult>? TResult,
  }) {
    TResult ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$TResult>;
    return $TaskType(TResult).fromRef(_forResult(object.reference).object);
  }

  static final _whenAll = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Tasks__whenAll")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAll(java.util.Collection collection)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JObject> whenAll(
    jni.JObject collection,
  ) {
    return const $TaskType(jni.JObjectType())
        .fromRef(_whenAll(collection.reference).object);
  }

  static final _whenAll1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Tasks__whenAll1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAll(java.lang.Object[] tasks)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JObject> whenAll1(
    jni.JArray<Task<jni.JObject>> tasks,
  ) {
    return const $TaskType(jni.JObjectType())
        .fromRef(_whenAll1(tasks.reference).object);
  }

  static final _whenAllComplete = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__whenAllComplete")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAllComplete(java.util.Collection collection)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JList<Task<jni.JObject>>> whenAllComplete(
    jni.JObject collection,
  ) {
    return const $TaskType(jni.JListType($TaskType(jni.JObjectType())))
        .fromRef(_whenAllComplete(collection.reference).object);
  }

  static final _whenAllComplete1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__whenAllComplete1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAllComplete(java.lang.Object[] tasks)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JList<Task<jni.JObject>>> whenAllComplete1(
    jni.JArray<Task<jni.JObject>> tasks,
  ) {
    return const $TaskType(jni.JListType($TaskType(jni.JObjectType())))
        .fromRef(_whenAllComplete1(tasks.reference).object);
  }

  static final _whenAllSuccess = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__whenAllSuccess")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAllSuccess(java.util.Collection collection)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JList<$TResult>> whenAllSuccess<$TResult extends jni.JObject>(
    jni.JObject collection, {
    required jni.JObjType<$TResult> TResult,
  }) {
    return $TaskType(jni.JListType(TResult))
        .fromRef(_whenAllSuccess(collection.reference).object);
  }

  static final _whenAllSuccess1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Tasks__whenAllSuccess1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task whenAllSuccess(java.lang.Object[] tasks)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<jni.JList<$TResult>>
      whenAllSuccess1<$TResult extends jni.JObject>(
    jni.JArray<Task<jni.JObject>> tasks, {
    required jni.JObjType<$TResult> TResult,
  }) {
    return $TaskType(jni.JListType(TResult))
        .fromRef(_whenAllSuccess1(tasks.reference).object);
  }

  static final _withTimeout = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("Tasks__withTimeout")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.android.gms.tasks.Task withTimeout(com.google.android.gms.tasks.Task task, long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  static Task<$T> withTimeout<$T extends jni.JObject>(
    Task<$T> task,
    int j,
    jni.JObject timeUnit, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      (task.$type as $TaskType).TResult,
    ]) as jni.JObjType<$T>;
    return $TaskType(T)
        .fromRef(_withTimeout(task.reference, j, timeUnit.reference).object);
  }

  static final _await0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Tasks__await0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public TResult await(com.google.android.gms.tasks.Task task)
  /// The returned object must be released after use, by calling the [release] method.
  static $TResult await0<$TResult extends jni.JObject>(
    Task<$TResult> task, {
    jni.JObjType<$TResult>? TResult,
  }) {
    TResult ??= jni.lowestCommonSuperType([
      (task.$type as $TaskType).TResult,
    ]) as jni.JObjType<$TResult>;
    return TResult.fromRef(_await0(task.reference).object);
  }

  static final _await1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int64,
                  ffi.Pointer<ffi.Void>)>>("Tasks__await1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public TResult await(com.google.android.gms.tasks.Task task, long j, java.util.concurrent.TimeUnit timeUnit)
  /// The returned object must be released after use, by calling the [release] method.
  static $TResult await1<$TResult extends jni.JObject>(
    Task<$TResult> task,
    int j,
    jni.JObject timeUnit, {
    jni.JObjType<$TResult>? TResult,
  }) {
    TResult ??= jni.lowestCommonSuperType([
      (task.$type as $TaskType).TResult,
    ]) as jni.JObjType<$TResult>;
    return TResult.fromRef(
        _await1(task.reference, j, timeUnit.reference).object);
  }
}

final class $TasksType extends jni.JObjType<Tasks> {
  const $TasksType();

  @override
  String get signature => r"Lcom/google/android/gms/tasks/Tasks;";

  @override
  Tasks fromRef(jni.JObjectPtr ref) => Tasks.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($TasksType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($TasksType) && other is $TasksType;
  }
}

/// from: com.google.android.gms.tasks.OnCompleteListener
class OnCompleteListener<$TResult extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<OnCompleteListener<$TResult>> $type = type(TResult);

  final jni.JObjType<$TResult> TResult;

  OnCompleteListener.fromRef(
    this.TResult,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $OnCompleteListenerType<$TResult> type<$TResult extends jni.JObject>(
    jni.JObjType<$TResult> TResult,
  ) {
    return $OnCompleteListenerType(
      TResult,
    );
  }

  static final _onComplete = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OnCompleteListener__onComplete")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onComplete(com.google.android.gms.tasks.Task task)
  void onComplete(
    Task<$TResult> task,
  ) {
    return _onComplete(reference, task.reference).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnCompleteListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onComplete(Lcom/google/android/gms/tasks/Task;)V") {
        _$impls[$p]!.onComplete(
          $a[0].castTo($TaskType(_$impls[$p]!.TResult), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory OnCompleteListener.implement(
    $OnCompleteListenerImpl<$TResult> $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnCompleteListener.fromRef(
      $impl.TResult,
      ProtectedJniExtensions.newPortProxy(
        r"com.google.android.gms.tasks.OnCompleteListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $OnCompleteListenerImpl<$TResult extends jni.JObject> {
  factory $OnCompleteListenerImpl({
    required jni.JObjType<$TResult> TResult,
    required void Function(Task<$TResult> task) onComplete,
  }) = _$OnCompleteListenerImpl;

  jni.JObjType<$TResult> get TResult;

  void onComplete(Task<$TResult> task);
}

class _$OnCompleteListenerImpl<$TResult extends jni.JObject>
    implements $OnCompleteListenerImpl<$TResult> {
  _$OnCompleteListenerImpl({
    required this.TResult,
    required void Function(Task<$TResult> task) onComplete,
  }) : _onComplete = onComplete;

  @override
  final jni.JObjType<$TResult> TResult;

  final void Function(Task<$TResult> task) _onComplete;

  void onComplete(Task<$TResult> task) {
    return _onComplete(task);
  }
}

final class $OnCompleteListenerType<$TResult extends jni.JObject>
    extends jni.JObjType<OnCompleteListener<$TResult>> {
  final jni.JObjType<$TResult> TResult;

  const $OnCompleteListenerType(
    this.TResult,
  );

  @override
  String get signature => r"Lcom/google/android/gms/tasks/OnCompleteListener;";

  @override
  OnCompleteListener<$TResult> fromRef(jni.JObjectPtr ref) =>
      OnCompleteListener.fromRef(TResult, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($OnCompleteListenerType, TResult);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnCompleteListenerType<$TResult>) &&
        other is $OnCompleteListenerType<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: com.google.android.gms.tasks.OnSuccessListener
class OnSuccessListener<$TResult extends jni.JObject> extends jni.JObject {
  @override
  late final jni.JObjType<OnSuccessListener<$TResult>> $type = type(TResult);

  final jni.JObjType<$TResult> TResult;

  OnSuccessListener.fromRef(
    this.TResult,
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static $OnSuccessListenerType<$TResult> type<$TResult extends jni.JObject>(
    jni.JObjType<$TResult> TResult,
  ) {
    return $OnSuccessListenerType(
      TResult,
    );
  }

  static final _onSuccess = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OnSuccessListener__onSuccess")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onSuccess(TResult object)
  void onSuccess(
    $TResult object,
  ) {
    return _onSuccess(reference, object.reference).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnSuccessListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onSuccess(Ljava/lang/Object;)V") {
        _$impls[$p]!.onSuccess(
          $a[0].castTo(_$impls[$p]!.TResult, releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory OnSuccessListener.implement(
    $OnSuccessListenerImpl<$TResult> $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnSuccessListener.fromRef(
      $impl.TResult,
      ProtectedJniExtensions.newPortProxy(
        r"com.google.android.gms.tasks.OnSuccessListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $OnSuccessListenerImpl<$TResult extends jni.JObject> {
  factory $OnSuccessListenerImpl({
    required jni.JObjType<$TResult> TResult,
    required void Function($TResult object) onSuccess,
  }) = _$OnSuccessListenerImpl;

  jni.JObjType<$TResult> get TResult;

  void onSuccess($TResult object);
}

class _$OnSuccessListenerImpl<$TResult extends jni.JObject>
    implements $OnSuccessListenerImpl<$TResult> {
  _$OnSuccessListenerImpl({
    required this.TResult,
    required void Function($TResult object) onSuccess,
  }) : _onSuccess = onSuccess;

  @override
  final jni.JObjType<$TResult> TResult;

  final void Function($TResult object) _onSuccess;

  void onSuccess($TResult object) {
    return _onSuccess(object);
  }
}

final class $OnSuccessListenerType<$TResult extends jni.JObject>
    extends jni.JObjType<OnSuccessListener<$TResult>> {
  final jni.JObjType<$TResult> TResult;

  const $OnSuccessListenerType(
    this.TResult,
  );

  @override
  String get signature => r"Lcom/google/android/gms/tasks/OnSuccessListener;";

  @override
  OnSuccessListener<$TResult> fromRef(jni.JObjectPtr ref) =>
      OnSuccessListener.fromRef(TResult, ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => Object.hash($OnSuccessListenerType, TResult);

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnSuccessListenerType<$TResult>) &&
        other is $OnSuccessListenerType<$TResult> &&
        TResult == other.TResult;
  }
}

/// from: com.google.android.gms.tasks.OnFailureListener
class OnFailureListener extends jni.JObject {
  @override
  late final jni.JObjType<OnFailureListener> $type = type;

  OnFailureListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $OnFailureListenerType();
  static final _onFailure = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("OnFailureListener__onFailure")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onFailure(java.lang.Exception exception)
  void onFailure(
    jni.JObject exception,
  ) {
    return _onFailure(reference, exception.reference).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnFailureListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onFailure(Ljava/lang/Exception;)V") {
        _$impls[$p]!.onFailure(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory OnFailureListener.implement(
    $OnFailureListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnFailureListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.android.gms.tasks.OnFailureListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $OnFailureListenerImpl {
  factory $OnFailureListenerImpl({
    required void Function(jni.JObject exception) onFailure,
  }) = _$OnFailureListenerImpl;

  void onFailure(jni.JObject exception);
}

class _$OnFailureListenerImpl implements $OnFailureListenerImpl {
  _$OnFailureListenerImpl({
    required void Function(jni.JObject exception) onFailure,
  }) : _onFailure = onFailure;

  final void Function(jni.JObject exception) _onFailure;

  void onFailure(jni.JObject exception) {
    return _onFailure(exception);
  }
}

final class $OnFailureListenerType extends jni.JObjType<OnFailureListener> {
  const $OnFailureListenerType();

  @override
  String get signature => r"Lcom/google/android/gms/tasks/OnFailureListener;";

  @override
  OnFailureListener fromRef(jni.JObjectPtr ref) =>
      OnFailureListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OnFailureListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnFailureListenerType) &&
        other is $OnFailureListenerType;
  }
}

/// from: com.google.android.gms.tasks.OnCanceledListener
class OnCanceledListener extends jni.JObject {
  @override
  late final jni.JObjType<OnCanceledListener> $type = type;

  OnCanceledListener.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $OnCanceledListenerType();
  static final _onCanceled = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "OnCanceledListener__onCanceled")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void onCanceled()
  void onCanceled() {
    return _onCanceled(reference).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $OnCanceledListenerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"onCanceled()V") {
        _$impls[$p]!.onCanceled();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory OnCanceledListener.implement(
    $OnCanceledListenerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = OnCanceledListener.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.android.gms.tasks.OnCanceledListener",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $OnCanceledListenerImpl {
  factory $OnCanceledListenerImpl({
    required void Function() onCanceled,
  }) = _$OnCanceledListenerImpl;

  void onCanceled();
}

class _$OnCanceledListenerImpl implements $OnCanceledListenerImpl {
  _$OnCanceledListenerImpl({
    required void Function() onCanceled,
  }) : _onCanceled = onCanceled;

  final void Function() _onCanceled;

  void onCanceled() {
    return _onCanceled();
  }
}

final class $OnCanceledListenerType extends jni.JObjType<OnCanceledListener> {
  const $OnCanceledListenerType();

  @override
  String get signature => r"Lcom/google/android/gms/tasks/OnCanceledListener;";

  @override
  OnCanceledListener fromRef(jni.JObjectPtr ref) =>
      OnCanceledListener.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($OnCanceledListenerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($OnCanceledListenerType) &&
        other is $OnCanceledListenerType;
  }
}

/// from: com.google.mlkit.vision.common.InputImage$ImageFormat
class InputImage_ImageFormat extends jni.JObject {
  @override
  late final jni.JObjType<InputImage_ImageFormat> $type = type;

  InputImage_ImageFormat.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $InputImage_ImageFormatType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $InputImage_ImageFormatImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory InputImage_ImageFormat.implement(
    $InputImage_ImageFormatImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = InputImage_ImageFormat.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.common.InputImage$ImageFormat",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $InputImage_ImageFormatImpl {
  factory $InputImage_ImageFormatImpl() = _$InputImage_ImageFormatImpl;
}

class _$InputImage_ImageFormatImpl implements $InputImage_ImageFormatImpl {
  _$InputImage_ImageFormatImpl();
}

final class $InputImage_ImageFormatType
    extends jni.JObjType<InputImage_ImageFormat> {
  const $InputImage_ImageFormatType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/common/InputImage$ImageFormat;";

  @override
  InputImage_ImageFormat fromRef(jni.JObjectPtr ref) =>
      InputImage_ImageFormat.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($InputImage_ImageFormatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($InputImage_ImageFormatType) &&
        other is $InputImage_ImageFormatType;
  }
}

/// from: com.google.mlkit.vision.common.InputImage
class InputImage extends jni.JObject {
  @override
  late final jni.JObjType<InputImage> $type = type;

  InputImage.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $InputImageType();

  /// from: static public final int IMAGE_FORMAT_NV21
  static const IMAGE_FORMAT_NV21 = 17;

  /// from: static public final int IMAGE_FORMAT_YV12
  static const IMAGE_FORMAT_YV12 = 842094169;

  /// from: static public final int IMAGE_FORMAT_BITMAP
  static const IMAGE_FORMAT_BITMAP = -1;

  /// from: static public final int IMAGE_FORMAT_YUV_420_888
  static const IMAGE_FORMAT_YUV_420_888 = 35;

  static final _getFormat = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getFormat")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getFormat()
  int getFormat() {
    return _getFormat(reference).integer;
  }

  static final _getHeight = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getHeight")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHeight()
  int getHeight() {
    return _getHeight(reference).integer;
  }

  static final _getRotationDegrees = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getRotationDegrees")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getRotationDegrees()
  int getRotationDegrees() {
    return _getRotationDegrees(reference).integer;
  }

  static final _getWidth = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getWidth")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getWidth()
  int getWidth() {
    return _getWidth(reference).integer;
  }

  static final _getBitmapInternal = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getBitmapInternal")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Bitmap getBitmapInternal()
  /// The returned object must be released after use, by calling the [release] method.
  Bitmap getBitmapInternal() {
    return const $BitmapType().fromRef(_getBitmapInternal(reference).object);
  }

  static final _getCoordinatesMatrix = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getCoordinatesMatrix")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Matrix getCoordinatesMatrix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCoordinatesMatrix() {
    return const jni.JObjectType()
        .fromRef(_getCoordinatesMatrix(reference).object);
  }

  static final _getMediaImage = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getMediaImage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.media.Image getMediaImage()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getMediaImage() {
    return const jni.JObjectType().fromRef(_getMediaImage(reference).object);
  }

  static final _fromBitmap = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("InputImage__fromBitmap")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromBitmap(android.graphics.Bitmap bitmap, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromBitmap(
    Bitmap bitmap,
    int i,
  ) {
    return const $InputImageType()
        .fromRef(_fromBitmap(bitmap.reference, i).object);
  }

  static final _fromByteArray = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("InputImage__fromByteArray")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromByteArray(byte[] bs, int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromByteArray(
    jni.JArray<jni.jbyte> bs,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return const $InputImageType()
        .fromRef(_fromByteArray(bs.reference, i, i1, i2, i3).object);
  }

  static final _fromByteBuffer = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32)>>("InputImage__fromByteBuffer")
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, int, int, int, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromByteBuffer(java.nio.ByteBuffer byteBuffer, int i, int i1, int i2, int i3)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromByteBuffer(
    jni.JByteBuffer byteBuffer,
    int i,
    int i1,
    int i2,
    int i3,
  ) {
    return const $InputImageType()
        .fromRef(_fromByteBuffer(byteBuffer.reference, i, i1, i2, i3).object);
  }

  static final _fromFilePath = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("InputImage__fromFilePath")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromFilePath(android.content.Context context, android.net.Uri uri)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromFilePath(
    jni.JObject context,
    Uri uri,
  ) {
    return const $InputImageType()
        .fromRef(_fromFilePath(context.reference, uri.reference).object);
  }

  static final _fromMediaImage = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Int32)>>("InputImage__fromMediaImage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromMediaImage(android.media.Image image, int i)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromMediaImage(
    jni.JObject image,
    int i,
  ) {
    return const $InputImageType()
        .fromRef(_fromMediaImage(image.reference, i).object);
  }

  static final _fromMediaImage1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("InputImage__fromMediaImage1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.mlkit.vision.common.InputImage fromMediaImage(android.media.Image image, int i, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  static InputImage fromMediaImage1(
    jni.JObject image,
    int i,
    jni.JObject matrix,
  ) {
    return const $InputImageType()
        .fromRef(_fromMediaImage1(image.reference, i, matrix.reference).object);
  }

  static final _getByteBuffer = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getByteBuffer")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.nio.ByteBuffer getByteBuffer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JByteBuffer getByteBuffer() {
    return const jni.JByteBufferType()
        .fromRef(_getByteBuffer(reference).object);
  }

  static final _getPlanes = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "InputImage__getPlanes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.media.Image$Plane[] getPlanes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JObject> getPlanes() {
    return const jni.JArrayType(jni.JObjectType())
        .fromRef(_getPlanes(reference).object);
  }
}

final class $InputImageType extends jni.JObjType<InputImage> {
  const $InputImageType();

  @override
  String get signature => r"Lcom/google/mlkit/vision/common/InputImage;";

  @override
  InputImage fromRef(jni.JObjectPtr ref) => InputImage.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($InputImageType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($InputImageType) && other is $InputImageType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScanner
class BarcodeScanner extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScanner> $type = type;

  BarcodeScanner.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScannerType();
  static final _process = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("BarcodeScanner__process")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(com.google.android.odml.image.MlImage mlImage)
  /// The returned object must be released after use, by calling the [release] method.
  Task<jni.JList<Barcode>> process(
    jni.JObject mlImage,
  ) {
    return const $TaskType(jni.JListType($BarcodeType()))
        .fromRef(_process(reference, mlImage.reference).object);
  }

  static final _process1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("BarcodeScanner__process1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract com.google.android.gms.tasks.Task process(com.google.mlkit.vision.common.InputImage inputImage)
  /// The returned object must be released after use, by calling the [release] method.
  Task<jni.JList<Barcode>> process1(
    InputImage inputImage,
  ) {
    return const $TaskType(jni.JListType($BarcodeType()))
        .fromRef(_process1(reference, inputImage.reference).object);
  }

  static final _close = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScanner__close")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void close()
  void close() {
    return _close(reference).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $BarcodeScannerImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d ==
          r"process(Lcom/google/android/odml/image/MlImage;)Lcom/google/android/gms/tasks/Task;") {
        final $r = _$impls[$p]!.process(
          $a[0].castTo(const jni.JObjectType(), releaseOriginal: true),
        );
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
      if ($d ==
          r"process(Lcom/google/mlkit/vision/common/InputImage;)Lcom/google/android/gms/tasks/Task;") {
        final $r = _$impls[$p]!.process1(
          $a[0].castTo(const $InputImageType(), releaseOriginal: true),
        );
        return ($r as jni.JObject).castTo(const jni.JObjectType()).toPointer();
      }
      if ($d == r"close()V") {
        _$impls[$p]!.close();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory BarcodeScanner.implement(
    $BarcodeScannerImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = BarcodeScanner.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.BarcodeScanner",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $BarcodeScannerImpl {
  factory $BarcodeScannerImpl({
    required Task<jni.JList<Barcode>> Function(jni.JObject mlImage) process,
    required Task<jni.JList<Barcode>> Function(InputImage inputImage) process1,
    required void Function() close,
  }) = _$BarcodeScannerImpl;

  Task<jni.JList<Barcode>> process(jni.JObject mlImage);
  Task<jni.JList<Barcode>> process1(InputImage inputImage);
  void close();
}

class _$BarcodeScannerImpl implements $BarcodeScannerImpl {
  _$BarcodeScannerImpl({
    required Task<jni.JList<Barcode>> Function(jni.JObject mlImage) process,
    required Task<jni.JList<Barcode>> Function(InputImage inputImage) process1,
    required void Function() close,
  })  : _process = process,
        _process1 = process1,
        _close = close;

  final Task<jni.JList<Barcode>> Function(jni.JObject mlImage) _process;
  final Task<jni.JList<Barcode>> Function(InputImage inputImage) _process1;
  final void Function() _close;

  Task<jni.JList<Barcode>> process(jni.JObject mlImage) {
    return _process(mlImage);
  }

  Task<jni.JList<Barcode>> process1(InputImage inputImage) {
    return _process1(inputImage);
  }

  void close() {
    return _close();
  }
}

final class $BarcodeScannerType extends jni.JObjType<BarcodeScanner> {
  const $BarcodeScannerType();

  @override
  String get signature => r"Lcom/google/mlkit/vision/barcode/BarcodeScanner;";

  @override
  BarcodeScanner fromRef(jni.JObjectPtr ref) => BarcodeScanner.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScannerType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScannerType) &&
        other is $BarcodeScannerType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder
class BarcodeScannerOptions_Builder extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScannerOptions_Builder> $type = type;

  BarcodeScannerOptions_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScannerOptions_BuilderType();
  static final _enableAllPotentialBarcodes = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions_Builder__enableAllPotentialBarcodes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder enableAllPotentialBarcodes()
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder enableAllPotentialBarcodes() {
    return const $BarcodeScannerOptions_BuilderType()
        .fromRef(_enableAllPotentialBarcodes(reference).object);
  }

  static final _setBarcodeFormats = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Int32,
                      ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions_Builder__setBarcodeFormats")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder setBarcodeFormats(int i, int[] is)
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder setBarcodeFormats(
    int i,
    jni.JArray<jni.jint> is0,
  ) {
    return const $BarcodeScannerOptions_BuilderType()
        .fromRef(_setBarcodeFormats(reference, i, is0.reference).object);
  }

  static final _setExecutor = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions_Builder__setExecutor")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder setExecutor(java.util.concurrent.Executor executor)
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder setExecutor(
    Executor executor,
  ) {
    return const $BarcodeScannerOptions_BuilderType()
        .fromRef(_setExecutor(reference, executor.reference).object);
  }

  static final _setZoomSuggestionOptions = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions_Builder__setZoomSuggestionOptions")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions$Builder setZoomSuggestionOptions(com.google.mlkit.vision.barcode.ZoomSuggestionOptions zoomSuggestionOptions)
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions_Builder setZoomSuggestionOptions(
    ZoomSuggestionOptions zoomSuggestionOptions,
  ) {
    return const $BarcodeScannerOptions_BuilderType().fromRef(
        _setZoomSuggestionOptions(reference, zoomSuggestionOptions.reference)
            .object);
  }

  static final _build = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.BarcodeScannerOptions build()
  /// The returned object must be released after use, by calling the [release] method.
  BarcodeScannerOptions build() {
    return const $BarcodeScannerOptionsType().fromRef(_build(reference).object);
  }

  static final _new0 = jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
          "BarcodeScannerOptions_Builder__new0")
      .asFunction<jni.JniResult Function()>();

  /// from: public void <init>()
  /// The returned object must be released after use, by calling the [release] method.
  factory BarcodeScannerOptions_Builder() {
    return BarcodeScannerOptions_Builder.fromRef(_new0().object);
  }
}

final class $BarcodeScannerOptions_BuilderType
    extends jni.JObjType<BarcodeScannerOptions_Builder> {
  const $BarcodeScannerOptions_BuilderType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions$Builder;";

  @override
  BarcodeScannerOptions_Builder fromRef(jni.JObjectPtr ref) =>
      BarcodeScannerOptions_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScannerOptions_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScannerOptions_BuilderType) &&
        other is $BarcodeScannerOptions_BuilderType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScannerOptions
class BarcodeScannerOptions extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScannerOptions> $type = type;

  BarcodeScannerOptions.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScannerOptionsType();
  static final _hashCode1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference).integer;
  }

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("BarcodeScannerOptions__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return _equals1(reference, object.reference).boolean;
  }

  static final _zza = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions__zza")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final int zza()
  int zza() {
    return _zza(reference).integer;
  }

  static final _zzb = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions__zzb")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final com.google.mlkit.vision.barcode.ZoomSuggestionOptions zzb()
  /// The returned object must be released after use, by calling the [release] method.
  ZoomSuggestionOptions zzb() {
    return const $ZoomSuggestionOptionsType().fromRef(_zzb(reference).object);
  }

  static final _zzc = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions__zzc")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final java.util.concurrent.Executor zzc()
  /// The returned object must be released after use, by calling the [release] method.
  Executor zzc() {
    return const $ExecutorType().fromRef(_zzc(reference).object);
  }

  static final _zzd = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScannerOptions__zzd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final boolean zzd()
  bool zzd() {
    return _zzd(reference).boolean;
  }
}

final class $BarcodeScannerOptionsType
    extends jni.JObjType<BarcodeScannerOptions> {
  const $BarcodeScannerOptionsType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/BarcodeScannerOptions;";

  @override
  BarcodeScannerOptions fromRef(jni.JObjectPtr ref) =>
      BarcodeScannerOptions.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScannerOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScannerOptionsType) &&
        other is $BarcodeScannerOptionsType;
  }
}

/// from: com.google.mlkit.vision.barcode.BarcodeScanning
class BarcodeScanning extends jni.JObject {
  @override
  late final jni.JObjType<BarcodeScanning> $type = type;

  BarcodeScanning.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeScanningType();
  static final _getClient =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "BarcodeScanning__getClient")
          .asFunction<jni.JniResult Function()>();

  /// from: static public com.google.mlkit.vision.barcode.BarcodeScanner getClient()
  /// The returned object must be released after use, by calling the [release] method.
  static BarcodeScanner getClient() {
    return const $BarcodeScannerType().fromRef(_getClient().object);
  }

  static final _getClient1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "BarcodeScanning__getClient1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public com.google.mlkit.vision.barcode.BarcodeScanner getClient(com.google.mlkit.vision.barcode.BarcodeScannerOptions barcodeScannerOptions)
  /// The returned object must be released after use, by calling the [release] method.
  static BarcodeScanner getClient1(
    BarcodeScannerOptions barcodeScannerOptions,
  ) {
    return const $BarcodeScannerType()
        .fromRef(_getClient1(barcodeScannerOptions.reference).object);
  }
}

final class $BarcodeScanningType extends jni.JObjType<BarcodeScanning> {
  const $BarcodeScanningType();

  @override
  String get signature => r"Lcom/google/mlkit/vision/barcode/BarcodeScanning;";

  @override
  BarcodeScanning fromRef(jni.JObjectPtr ref) => BarcodeScanning.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeScanningType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeScanningType) &&
        other is $BarcodeScanningType;
  }
}

/// from: com.google.mlkit.vision.barcode.ZoomSuggestionOptions$Builder
class ZoomSuggestionOptions_Builder extends jni.JObject {
  @override
  late final jni.JObjType<ZoomSuggestionOptions_Builder> $type = type;

  ZoomSuggestionOptions_Builder.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ZoomSuggestionOptions_BuilderType();
  static final _setMaxSupportedZoomRatio = jniLookup<
              ffi.NativeFunction<
                  jni.JniResult Function(ffi.Pointer<ffi.Void>, ffi.Float)>>(
          "ZoomSuggestionOptions_Builder__setMaxSupportedZoomRatio")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public com.google.mlkit.vision.barcode.ZoomSuggestionOptions$Builder setMaxSupportedZoomRatio(float f)
  /// The returned object must be released after use, by calling the [release] method.
  ZoomSuggestionOptions_Builder setMaxSupportedZoomRatio(
    double f,
  ) {
    return const $ZoomSuggestionOptions_BuilderType()
        .fromRef(_setMaxSupportedZoomRatio(reference, f).object);
  }

  static final _build = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ZoomSuggestionOptions_Builder__build")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.ZoomSuggestionOptions build()
  /// The returned object must be released after use, by calling the [release] method.
  ZoomSuggestionOptions build() {
    return const $ZoomSuggestionOptionsType().fromRef(_build(reference).object);
  }

  static final _new0 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ZoomSuggestionOptions_Builder__new0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.ZoomSuggestionOptions$ZoomCallback zoomCallback)
  /// The returned object must be released after use, by calling the [release] method.
  factory ZoomSuggestionOptions_Builder(
    ZoomSuggestionOptions_ZoomCallback zoomCallback,
  ) {
    return ZoomSuggestionOptions_Builder.fromRef(
        _new0(zoomCallback.reference).object);
  }
}

final class $ZoomSuggestionOptions_BuilderType
    extends jni.JObjType<ZoomSuggestionOptions_Builder> {
  const $ZoomSuggestionOptions_BuilderType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/ZoomSuggestionOptions$Builder;";

  @override
  ZoomSuggestionOptions_Builder fromRef(jni.JObjectPtr ref) =>
      ZoomSuggestionOptions_Builder.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ZoomSuggestionOptions_BuilderType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoomSuggestionOptions_BuilderType) &&
        other is $ZoomSuggestionOptions_BuilderType;
  }
}

/// from: com.google.mlkit.vision.barcode.ZoomSuggestionOptions$ZoomCallback
class ZoomSuggestionOptions_ZoomCallback extends jni.JObject {
  @override
  late final jni.JObjType<ZoomSuggestionOptions_ZoomCallback> $type = type;

  ZoomSuggestionOptions_ZoomCallback.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ZoomSuggestionOptions_ZoomCallbackType();
  static final _setZoom = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Float)>>("ZoomSuggestionOptions_ZoomCallback__setZoom")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, double)>();

  /// from: public abstract boolean setZoom(float f)
  bool setZoom(
    double f,
  ) {
    return _setZoom(reference, f).boolean;
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ZoomSuggestionOptions_ZoomCallbackImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"setZoom(F)Z") {
        final $r = _$impls[$p]!.setZoom(
          $a[0]
              .castTo(const jni.JFloatType(), releaseOriginal: true)
              .floatValue(releaseOriginal: true),
        );
        return jni.JBoolean($r).toPointer();
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory ZoomSuggestionOptions_ZoomCallback.implement(
    $ZoomSuggestionOptions_ZoomCallbackImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = ZoomSuggestionOptions_ZoomCallback.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.ZoomSuggestionOptions$ZoomCallback",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $ZoomSuggestionOptions_ZoomCallbackImpl {
  factory $ZoomSuggestionOptions_ZoomCallbackImpl({
    required bool Function(double f) setZoom,
  }) = _$ZoomSuggestionOptions_ZoomCallbackImpl;

  bool setZoom(double f);
}

class _$ZoomSuggestionOptions_ZoomCallbackImpl
    implements $ZoomSuggestionOptions_ZoomCallbackImpl {
  _$ZoomSuggestionOptions_ZoomCallbackImpl({
    required bool Function(double f) setZoom,
  }) : _setZoom = setZoom;

  final bool Function(double f) _setZoom;

  bool setZoom(double f) {
    return _setZoom(f);
  }
}

final class $ZoomSuggestionOptions_ZoomCallbackType
    extends jni.JObjType<ZoomSuggestionOptions_ZoomCallback> {
  const $ZoomSuggestionOptions_ZoomCallbackType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/ZoomSuggestionOptions$ZoomCallback;";

  @override
  ZoomSuggestionOptions_ZoomCallback fromRef(jni.JObjectPtr ref) =>
      ZoomSuggestionOptions_ZoomCallback.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ZoomSuggestionOptions_ZoomCallbackType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoomSuggestionOptions_ZoomCallbackType) &&
        other is $ZoomSuggestionOptions_ZoomCallbackType;
  }
}

/// from: com.google.mlkit.vision.barcode.ZoomSuggestionOptions
class ZoomSuggestionOptions extends jni.JObject {
  @override
  late final jni.JObjType<ZoomSuggestionOptions> $type = type;

  ZoomSuggestionOptions.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ZoomSuggestionOptionsType();
  static final _hashCode1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ZoomSuggestionOptions__hashCode1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int hashCode()
  int hashCode1() {
    return _hashCode1(reference).integer;
  }

  static final _equals1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("ZoomSuggestionOptions__equals1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public boolean equals(java.lang.Object object)
  bool equals1(
    jni.JObject object,
  ) {
    return _equals1(reference, object.reference).boolean;
  }

  static final _zza = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ZoomSuggestionOptions__zza")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final float zza()
  double zza() {
    return _zza(reference).float;
  }

  static final _zzb = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "ZoomSuggestionOptions__zzb")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public final com.google.mlkit.vision.barcode.ZoomSuggestionOptions$ZoomCallback zzb()
  /// The returned object must be released after use, by calling the [release] method.
  ZoomSuggestionOptions_ZoomCallback zzb() {
    return const $ZoomSuggestionOptions_ZoomCallbackType()
        .fromRef(_zzb(reference).object);
  }
}

final class $ZoomSuggestionOptionsType
    extends jni.JObjType<ZoomSuggestionOptions> {
  const $ZoomSuggestionOptionsType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/ZoomSuggestionOptions;";

  @override
  ZoomSuggestionOptions fromRef(jni.JObjectPtr ref) =>
      ZoomSuggestionOptions.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ZoomSuggestionOptionsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoomSuggestionOptionsType) &&
        other is $ZoomSuggestionOptionsType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Address$AddressType
class Barcode_Address_AddressType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Address_AddressType> $type = type;

  Barcode_Address_AddressType.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Address_AddressTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Address_AddressTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_Address_AddressType.implement(
    $Barcode_Address_AddressTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Address_AddressType.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$Address$AddressType",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $Barcode_Address_AddressTypeImpl {
  factory $Barcode_Address_AddressTypeImpl() =
      _$Barcode_Address_AddressTypeImpl;
}

class _$Barcode_Address_AddressTypeImpl
    implements $Barcode_Address_AddressTypeImpl {
  _$Barcode_Address_AddressTypeImpl();
}

final class $Barcode_Address_AddressTypeType
    extends jni.JObjType<Barcode_Address_AddressType> {
  const $Barcode_Address_AddressTypeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Address$AddressType;";

  @override
  Barcode_Address_AddressType fromRef(jni.JObjectPtr ref) =>
      Barcode_Address_AddressType.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Address_AddressTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Address_AddressTypeType) &&
        other is $Barcode_Address_AddressTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Address
class Barcode_Address extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Address> $type = type;

  Barcode_Address.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_AddressType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;

  static final _getType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Address__getType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getType()
  int getType() {
    return _getType(reference).integer;
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32, ffi.Pointer<ffi.Void>)>>("Barcode_Address__new0")
      .asFunction<jni.JniResult Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, java.lang.String[] strings)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Address(
    int i,
    jni.JArray<jni.JString> strings,
  ) {
    return Barcode_Address.fromRef(_new0(i, strings.reference).object);
  }

  static final _getAddressLines = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Address__getAddressLines")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String[] getAddressLines()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.JString> getAddressLines() {
    return const jni.JArrayType(jni.JStringType())
        .fromRef(_getAddressLines(reference).object);
  }
}

final class $Barcode_AddressType extends jni.JObjType<Barcode_Address> {
  const $Barcode_AddressType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Address;";

  @override
  Barcode_Address fromRef(jni.JObjectPtr ref) => Barcode_Address.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_AddressType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_AddressType) &&
        other is $Barcode_AddressType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$BarcodeFormat
class Barcode_BarcodeFormat extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_BarcodeFormat> $type = type;

  Barcode_BarcodeFormat.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_BarcodeFormatType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_BarcodeFormatImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_BarcodeFormat.implement(
    $Barcode_BarcodeFormatImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_BarcodeFormat.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$BarcodeFormat",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $Barcode_BarcodeFormatImpl {
  factory $Barcode_BarcodeFormatImpl() = _$Barcode_BarcodeFormatImpl;
}

class _$Barcode_BarcodeFormatImpl implements $Barcode_BarcodeFormatImpl {
  _$Barcode_BarcodeFormatImpl();
}

final class $Barcode_BarcodeFormatType
    extends jni.JObjType<Barcode_BarcodeFormat> {
  const $Barcode_BarcodeFormatType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$BarcodeFormat;";

  @override
  Barcode_BarcodeFormat fromRef(jni.JObjectPtr ref) =>
      Barcode_BarcodeFormat.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_BarcodeFormatType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_BarcodeFormatType) &&
        other is $Barcode_BarcodeFormatType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$BarcodeValueType
class Barcode_BarcodeValueType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_BarcodeValueType> $type = type;

  Barcode_BarcodeValueType.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_BarcodeValueTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_BarcodeValueTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_BarcodeValueType.implement(
    $Barcode_BarcodeValueTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_BarcodeValueType.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$BarcodeValueType",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $Barcode_BarcodeValueTypeImpl {
  factory $Barcode_BarcodeValueTypeImpl() = _$Barcode_BarcodeValueTypeImpl;
}

class _$Barcode_BarcodeValueTypeImpl implements $Barcode_BarcodeValueTypeImpl {
  _$Barcode_BarcodeValueTypeImpl();
}

final class $Barcode_BarcodeValueTypeType
    extends jni.JObjType<Barcode_BarcodeValueType> {
  const $Barcode_BarcodeValueTypeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$BarcodeValueType;";

  @override
  Barcode_BarcodeValueType fromRef(jni.JObjectPtr ref) =>
      Barcode_BarcodeValueType.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_BarcodeValueTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_BarcodeValueTypeType) &&
        other is $Barcode_BarcodeValueTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime
class Barcode_CalendarDateTime extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_CalendarDateTime> $type = type;

  Barcode_CalendarDateTime.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_CalendarDateTimeType();
  static final _getDay = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getDay")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getDay()
  int getDay() {
    return _getDay(reference).integer;
  }

  static final _getHours = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getHours")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getHours()
  int getHours() {
    return _getHours(reference).integer;
  }

  static final _getMinutes = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getMinutes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMinutes()
  int getMinutes() {
    return _getMinutes(reference).integer;
  }

  static final _getMonth = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getMonth")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getMonth()
  int getMonth() {
    return _getMonth(reference).integer;
  }

  static final _getSeconds = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getSeconds")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getSeconds()
  int getSeconds() {
    return _getSeconds(reference).integer;
  }

  static final _getYear = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getYear")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getYear()
  int getYear() {
    return _getYear(reference).integer;
  }

  static final _getRawValue = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__getRawValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getRawValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRawValue() {
    return const jni.JStringType().fromRef(_getRawValue(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Int32,
                  ffi.Uint8,
                  ffi.Pointer<ffi.Void>)>>("Barcode_CalendarDateTime__new0")
      .asFunction<
          jni.JniResult Function(
              int, int, int, int, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, int i1, int i2, int i3, int i4, int i5, boolean z, java.lang.String string)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_CalendarDateTime(
    int i,
    int i1,
    int i2,
    int i3,
    int i4,
    int i5,
    bool z,
    jni.JString string,
  ) {
    return Barcode_CalendarDateTime.fromRef(
        _new0(i, i1, i2, i3, i4, i5, z ? 1 : 0, string.reference).object);
  }

  static final _isUtc = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarDateTime__isUtc")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public boolean isUtc()
  bool isUtc() {
    return _isUtc(reference).boolean;
  }
}

final class $Barcode_CalendarDateTimeType
    extends jni.JObjType<Barcode_CalendarDateTime> {
  const $Barcode_CalendarDateTimeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarDateTime;";

  @override
  Barcode_CalendarDateTime fromRef(jni.JObjectPtr ref) =>
      Barcode_CalendarDateTime.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_CalendarDateTimeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_CalendarDateTimeType) &&
        other is $Barcode_CalendarDateTimeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$CalendarEvent
class Barcode_CalendarEvent extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_CalendarEvent> $type = type;

  Barcode_CalendarEvent.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_CalendarEventType();
  static final _getEnd = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getEnd")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime getEnd()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarDateTime getEnd() {
    return const $Barcode_CalendarDateTimeType()
        .fromRef(_getEnd(reference).object);
  }

  static final _getStart = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getStart")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime getStart()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarDateTime getStart() {
    return const $Barcode_CalendarDateTimeType()
        .fromRef(_getStart(reference).object);
  }

  static final _getDescription = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getDescription")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDescription()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDescription() {
    return const jni.JStringType().fromRef(_getDescription(reference).object);
  }

  static final _getLocation = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getLocation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLocation()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLocation() {
    return const jni.JStringType().fromRef(_getLocation(reference).object);
  }

  static final _getOrganizer = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getOrganizer")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getOrganizer()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOrganizer() {
    return const jni.JStringType().fromRef(_getOrganizer(reference).object);
  }

  static final _getStatus = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getStatus")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getStatus()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getStatus() {
    return const jni.JStringType().fromRef(_getStatus(reference).object);
  }

  static final _getSummary = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_CalendarEvent__getSummary")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSummary()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSummary() {
    return const jni.JStringType().fromRef(_getSummary(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_CalendarEvent__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime calendarDateTime, com.google.mlkit.vision.barcode.common.Barcode$CalendarDateTime calendarDateTime1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_CalendarEvent(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    Barcode_CalendarDateTime calendarDateTime,
    Barcode_CalendarDateTime calendarDateTime1,
  ) {
    return Barcode_CalendarEvent.fromRef(_new0(
            string.reference,
            string1.reference,
            string2.reference,
            string3.reference,
            string4.reference,
            calendarDateTime.reference,
            calendarDateTime1.reference)
        .object);
  }
}

final class $Barcode_CalendarEventType
    extends jni.JObjType<Barcode_CalendarEvent> {
  const $Barcode_CalendarEventType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$CalendarEvent;";

  @override
  Barcode_CalendarEvent fromRef(jni.JObjectPtr ref) =>
      Barcode_CalendarEvent.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_CalendarEventType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_CalendarEventType) &&
        other is $Barcode_CalendarEventType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$ContactInfo
class Barcode_ContactInfo extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_ContactInfo> $type = type;

  Barcode_ContactInfo.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_ContactInfoType();
  static final _getName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$PersonName getName()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_PersonName getName() {
    return const $Barcode_PersonNameType().fromRef(_getName(reference).object);
  }

  static final _getOrganization = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getOrganization")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getOrganization()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getOrganization() {
    return const jni.JStringType().fromRef(_getOrganization(reference).object);
  }

  static final _getTitle = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTitle() {
    return const jni.JStringType().fromRef(_getTitle(reference).object);
  }

  static final _getAddresses = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getAddresses")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getAddresses()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Address> getAddresses() {
    return const jni.JListType($Barcode_AddressType())
        .fromRef(_getAddresses(reference).object);
  }

  static final _getEmails = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getEmails")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getEmails()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Email> getEmails() {
    return const jni.JListType($Barcode_EmailType())
        .fromRef(_getEmails(reference).object);
  }

  static final _getPhones = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getPhones")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getPhones()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<Barcode_Phone> getPhones() {
    return const jni.JListType($Barcode_PhoneType())
        .fromRef(_getPhones(reference).object);
  }

  static final _getUrls = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_ContactInfo__getUrls")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.util.List getUrls()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JList<jni.JString> getUrls() {
    return const jni.JListType(jni.JStringType())
        .fromRef(_getUrls(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_ContactInfo__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.Barcode$PersonName personName, java.lang.String string, java.lang.String string1, java.util.List list, java.util.List list1, java.util.List list2, java.util.List list3)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_ContactInfo(
    Barcode_PersonName personName,
    jni.JString string,
    jni.JString string1,
    jni.JList<Barcode_Phone> list,
    jni.JList<Barcode_Email> list1,
    jni.JList<jni.JString> list2,
    jni.JList<Barcode_Address> list3,
  ) {
    return Barcode_ContactInfo.fromRef(_new0(
            personName.reference,
            string.reference,
            string1.reference,
            list.reference,
            list1.reference,
            list2.reference,
            list3.reference)
        .object);
  }
}

final class $Barcode_ContactInfoType extends jni.JObjType<Barcode_ContactInfo> {
  const $Barcode_ContactInfoType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$ContactInfo;";

  @override
  Barcode_ContactInfo fromRef(jni.JObjectPtr ref) =>
      Barcode_ContactInfo.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_ContactInfoType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_ContactInfoType) &&
        other is $Barcode_ContactInfoType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$DriverLicense
class Barcode_DriverLicense extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_DriverLicense> $type = type;

  Barcode_DriverLicense.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_DriverLicenseType();
  static final _getAddressCity = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getAddressCity")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAddressCity()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressCity() {
    return const jni.JStringType().fromRef(_getAddressCity(reference).object);
  }

  static final _getAddressState = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getAddressState")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAddressState()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressState() {
    return const jni.JStringType().fromRef(_getAddressState(reference).object);
  }

  static final _getAddressStreet = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getAddressStreet")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAddressStreet()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressStreet() {
    return const jni.JStringType().fromRef(_getAddressStreet(reference).object);
  }

  static final _getAddressZip = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getAddressZip")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAddressZip()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddressZip() {
    return const jni.JStringType().fromRef(_getAddressZip(reference).object);
  }

  static final _getBirthDate = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getBirthDate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getBirthDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getBirthDate() {
    return const jni.JStringType().fromRef(_getBirthDate(reference).object);
  }

  static final _getDocumentType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getDocumentType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDocumentType()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDocumentType() {
    return const jni.JStringType().fromRef(_getDocumentType(reference).object);
  }

  static final _getExpiryDate = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getExpiryDate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getExpiryDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getExpiryDate() {
    return const jni.JStringType().fromRef(_getExpiryDate(reference).object);
  }

  static final _getFirstName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getFirstName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getFirstName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFirstName() {
    return const jni.JStringType().fromRef(_getFirstName(reference).object);
  }

  static final _getGender = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getGender")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getGender()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getGender() {
    return const jni.JStringType().fromRef(_getGender(reference).object);
  }

  static final _getIssueDate = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getIssueDate")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getIssueDate()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getIssueDate() {
    return const jni.JStringType().fromRef(_getIssueDate(reference).object);
  }

  static final _getIssuingCountry = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getIssuingCountry")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getIssuingCountry()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getIssuingCountry() {
    return const jni.JStringType()
        .fromRef(_getIssuingCountry(reference).object);
  }

  static final _getLastName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getLastName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLastName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLastName() {
    return const jni.JStringType().fromRef(_getLastName(reference).object);
  }

  static final _getLicenseNumber = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getLicenseNumber")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLicenseNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLicenseNumber() {
    return const jni.JStringType().fromRef(_getLicenseNumber(reference).object);
  }

  static final _getMiddleName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_DriverLicense__getMiddleName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getMiddleName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMiddleName() {
    return const jni.JStringType().fromRef(_getMiddleName(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_DriverLicense__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6, java.lang.String string7, java.lang.String string8, java.lang.String string9, java.lang.String string10, java.lang.String string11, java.lang.String string12, java.lang.String string13)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_DriverLicense(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    jni.JString string5,
    jni.JString string6,
    jni.JString string7,
    jni.JString string8,
    jni.JString string9,
    jni.JString string10,
    jni.JString string11,
    jni.JString string12,
    jni.JString string13,
  ) {
    return Barcode_DriverLicense.fromRef(_new0(
            string.reference,
            string1.reference,
            string2.reference,
            string3.reference,
            string4.reference,
            string5.reference,
            string6.reference,
            string7.reference,
            string8.reference,
            string9.reference,
            string10.reference,
            string11.reference,
            string12.reference,
            string13.reference)
        .object);
  }
}

final class $Barcode_DriverLicenseType
    extends jni.JObjType<Barcode_DriverLicense> {
  const $Barcode_DriverLicenseType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$DriverLicense;";

  @override
  Barcode_DriverLicense fromRef(jni.JObjectPtr ref) =>
      Barcode_DriverLicense.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_DriverLicenseType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_DriverLicenseType) &&
        other is $Barcode_DriverLicenseType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Email$FormatType
class Barcode_Email_FormatType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Email_FormatType> $type = type;

  Barcode_Email_FormatType.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Email_FormatTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Email_FormatTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_Email_FormatType.implement(
    $Barcode_Email_FormatTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Email_FormatType.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$Email$FormatType",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $Barcode_Email_FormatTypeImpl {
  factory $Barcode_Email_FormatTypeImpl() = _$Barcode_Email_FormatTypeImpl;
}

class _$Barcode_Email_FormatTypeImpl implements $Barcode_Email_FormatTypeImpl {
  _$Barcode_Email_FormatTypeImpl();
}

final class $Barcode_Email_FormatTypeType
    extends jni.JObjType<Barcode_Email_FormatType> {
  const $Barcode_Email_FormatTypeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Email$FormatType;";

  @override
  Barcode_Email_FormatType fromRef(jni.JObjectPtr ref) =>
      Barcode_Email_FormatType.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Email_FormatTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Email_FormatTypeType) &&
        other is $Barcode_Email_FormatTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Email
class Barcode_Email extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Email> $type = type;

  Barcode_Email.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_EmailType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;

  static final _getType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Email__getType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getType()
  int getType() {
    return _getType(reference).integer;
  }

  static final _getAddress = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Email__getAddress")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getAddress()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getAddress() {
    return const jni.JStringType().fromRef(_getAddress(reference).object);
  }

  static final _getBody = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Email__getBody")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getBody()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getBody() {
    return const jni.JStringType().fromRef(_getBody(reference).object);
  }

  static final _getSubject = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Email__getSubject")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSubject()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSubject() {
    return const jni.JStringType().fromRef(_getSubject(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Int32,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_Email__new0")
      .asFunction<
          jni.JniResult Function(int, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(int i, java.lang.String string, java.lang.String string1, java.lang.String string2)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Email(
    int i,
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
  ) {
    return Barcode_Email.fromRef(
        _new0(i, string.reference, string1.reference, string2.reference)
            .object);
  }
}

final class $Barcode_EmailType extends jni.JObjType<Barcode_Email> {
  const $Barcode_EmailType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Email;";

  @override
  Barcode_Email fromRef(jni.JObjectPtr ref) => Barcode_Email.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_EmailType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_EmailType) &&
        other is $Barcode_EmailType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$GeoPoint
class Barcode_GeoPoint extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_GeoPoint> $type = type;

  Barcode_GeoPoint.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_GeoPointType();
  static final _getLat = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_GeoPoint__getLat")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public double getLat()
  double getLat() {
    return _getLat(reference).doubleFloat;
  }

  static final _getLng = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_GeoPoint__getLng")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public double getLng()
  double getLng() {
    return _getLng(reference).doubleFloat;
  }

  static final _new0 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Double, ffi.Double)>>(
          "Barcode_GeoPoint__new0")
      .asFunction<jni.JniResult Function(double, double)>();

  /// from: public void <init>(double d, double d1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_GeoPoint(
    double d,
    double d1,
  ) {
    return Barcode_GeoPoint.fromRef(_new0(d, d1).object);
  }
}

final class $Barcode_GeoPointType extends jni.JObjType<Barcode_GeoPoint> {
  const $Barcode_GeoPointType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$GeoPoint;";

  @override
  Barcode_GeoPoint fromRef(jni.JObjectPtr ref) => Barcode_GeoPoint.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_GeoPointType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_GeoPointType) &&
        other is $Barcode_GeoPointType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$PersonName
class Barcode_PersonName extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_PersonName> $type = type;

  Barcode_PersonName.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_PersonNameType();
  static final _getFirst = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getFirst")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getFirst()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFirst() {
    return const jni.JStringType().fromRef(_getFirst(reference).object);
  }

  static final _getFormattedName = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getFormattedName")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getFormattedName()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getFormattedName() {
    return const jni.JStringType().fromRef(_getFormattedName(reference).object);
  }

  static final _getLast = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getLast")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getLast()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getLast() {
    return const jni.JStringType().fromRef(_getLast(reference).object);
  }

  static final _getMiddle = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getMiddle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getMiddle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMiddle() {
    return const jni.JStringType().fromRef(_getMiddle(reference).object);
  }

  static final _getPrefix = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getPrefix")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPrefix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPrefix() {
    return const jni.JStringType().fromRef(_getPrefix(reference).object);
  }

  static final _getPronunciation = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getPronunciation")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPronunciation()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPronunciation() {
    return const jni.JStringType().fromRef(_getPronunciation(reference).object);
  }

  static final _getSuffix = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_PersonName__getSuffix")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSuffix()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSuffix() {
    return const jni.JStringType().fromRef(_getSuffix(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_PersonName__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, java.lang.String string2, java.lang.String string3, java.lang.String string4, java.lang.String string5, java.lang.String string6)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_PersonName(
    jni.JString string,
    jni.JString string1,
    jni.JString string2,
    jni.JString string3,
    jni.JString string4,
    jni.JString string5,
    jni.JString string6,
  ) {
    return Barcode_PersonName.fromRef(_new0(
            string.reference,
            string1.reference,
            string2.reference,
            string3.reference,
            string4.reference,
            string5.reference,
            string6.reference)
        .object);
  }
}

final class $Barcode_PersonNameType extends jni.JObjType<Barcode_PersonName> {
  const $Barcode_PersonNameType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$PersonName;";

  @override
  Barcode_PersonName fromRef(jni.JObjectPtr ref) =>
      Barcode_PersonName.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_PersonNameType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_PersonNameType) &&
        other is $Barcode_PersonNameType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Phone$FormatType
class Barcode_Phone_FormatType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Phone_FormatType> $type = type;

  Barcode_Phone_FormatType.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_Phone_FormatTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_Phone_FormatTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_Phone_FormatType.implement(
    $Barcode_Phone_FormatTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_Phone_FormatType.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$Phone$FormatType",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $Barcode_Phone_FormatTypeImpl {
  factory $Barcode_Phone_FormatTypeImpl() = _$Barcode_Phone_FormatTypeImpl;
}

class _$Barcode_Phone_FormatTypeImpl implements $Barcode_Phone_FormatTypeImpl {
  _$Barcode_Phone_FormatTypeImpl();
}

final class $Barcode_Phone_FormatTypeType
    extends jni.JObjType<Barcode_Phone_FormatType> {
  const $Barcode_Phone_FormatTypeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Phone$FormatType;";

  @override
  Barcode_Phone_FormatType fromRef(jni.JObjectPtr ref) =>
      Barcode_Phone_FormatType.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_Phone_FormatTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_Phone_FormatTypeType) &&
        other is $Barcode_Phone_FormatTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Phone
class Barcode_Phone extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Phone> $type = type;

  Barcode_Phone.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_PhoneType();

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_WORK
  static const TYPE_WORK = 1;

  /// from: static public final int TYPE_HOME
  static const TYPE_HOME = 2;

  /// from: static public final int TYPE_FAX
  static const TYPE_FAX = 3;

  /// from: static public final int TYPE_MOBILE
  static const TYPE_MOBILE = 4;

  static final _getType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Phone__getType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getType()
  int getType() {
    return _getType(reference).integer;
  }

  static final _getNumber = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Phone__getNumber")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getNumber() {
    return const jni.JStringType().fromRef(_getNumber(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Barcode_Phone__new0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String string, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Phone(
    jni.JString string,
    int i,
  ) {
    return Barcode_Phone.fromRef(_new0(string.reference, i).object);
  }
}

final class $Barcode_PhoneType extends jni.JObjType<Barcode_Phone> {
  const $Barcode_PhoneType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Phone;";

  @override
  Barcode_Phone fromRef(jni.JObjectPtr ref) => Barcode_Phone.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_PhoneType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_PhoneType) &&
        other is $Barcode_PhoneType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$Sms
class Barcode_Sms extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_Sms> $type = type;

  Barcode_Sms.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_SmsType();
  static final _getMessage = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Sms__getMessage")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getMessage()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getMessage() {
    return const jni.JStringType().fromRef(_getMessage(reference).object);
  }

  static final _getPhoneNumber = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_Sms__getPhoneNumber")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPhoneNumber()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPhoneNumber() {
    return const jni.JStringType().fromRef(_getPhoneNumber(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_Sms__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_Sms(
    jni.JString string,
    jni.JString string1,
  ) {
    return Barcode_Sms.fromRef(
        _new0(string.reference, string1.reference).object);
  }
}

final class $Barcode_SmsType extends jni.JObjType<Barcode_Sms> {
  const $Barcode_SmsType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$Sms;";

  @override
  Barcode_Sms fromRef(jni.JObjectPtr ref) => Barcode_Sms.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_SmsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_SmsType) && other is $Barcode_SmsType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$UrlBookmark
class Barcode_UrlBookmark extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_UrlBookmark> $type = type;

  Barcode_UrlBookmark.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_UrlBookmarkType();
  static final _getTitle = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_UrlBookmark__getTitle")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getTitle()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getTitle() {
    return const jni.JStringType().fromRef(_getTitle(reference).object);
  }

  static final _getUrl = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_UrlBookmark__getUrl")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getUrl() {
    return const jni.JStringType().fromRef(_getUrl(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode_UrlBookmark__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_UrlBookmark(
    jni.JString string,
    jni.JString string1,
  ) {
    return Barcode_UrlBookmark.fromRef(
        _new0(string.reference, string1.reference).object);
  }
}

final class $Barcode_UrlBookmarkType extends jni.JObjType<Barcode_UrlBookmark> {
  const $Barcode_UrlBookmarkType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$UrlBookmark;";

  @override
  Barcode_UrlBookmark fromRef(jni.JObjectPtr ref) =>
      Barcode_UrlBookmark.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_UrlBookmarkType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_UrlBookmarkType) &&
        other is $Barcode_UrlBookmarkType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$WiFi$EncryptionType
class Barcode_WiFi_EncryptionType extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_WiFi_EncryptionType> $type = type;

  Barcode_WiFi_EncryptionType.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_WiFi_EncryptionTypeType();

  /// Maps a specific port to the implemented interface.
  static final Map<int, $Barcode_WiFi_EncryptionTypeImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Barcode_WiFi_EncryptionType.implement(
    $Barcode_WiFi_EncryptionTypeImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Barcode_WiFi_EncryptionType.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.google.mlkit.vision.barcode.common.Barcode$WiFi$EncryptionType",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $Barcode_WiFi_EncryptionTypeImpl {
  factory $Barcode_WiFi_EncryptionTypeImpl() =
      _$Barcode_WiFi_EncryptionTypeImpl;
}

class _$Barcode_WiFi_EncryptionTypeImpl
    implements $Barcode_WiFi_EncryptionTypeImpl {
  _$Barcode_WiFi_EncryptionTypeImpl();
}

final class $Barcode_WiFi_EncryptionTypeType
    extends jni.JObjType<Barcode_WiFi_EncryptionType> {
  const $Barcode_WiFi_EncryptionTypeType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$WiFi$EncryptionType;";

  @override
  Barcode_WiFi_EncryptionType fromRef(jni.JObjectPtr ref) =>
      Barcode_WiFi_EncryptionType.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_WiFi_EncryptionTypeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_WiFi_EncryptionTypeType) &&
        other is $Barcode_WiFi_EncryptionTypeType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode$WiFi
class Barcode_WiFi extends jni.JObject {
  @override
  late final jni.JObjType<Barcode_WiFi> $type = type;

  Barcode_WiFi.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $Barcode_WiFiType();

  /// from: static public final int TYPE_OPEN
  static const TYPE_OPEN = 1;

  /// from: static public final int TYPE_WPA
  static const TYPE_WPA = 2;

  /// from: static public final int TYPE_WEP
  static const TYPE_WEP = 3;

  static final _getEncryptionType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_WiFi__getEncryptionType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getEncryptionType()
  int getEncryptionType() {
    return _getEncryptionType(reference).integer;
  }

  static final _getPassword = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_WiFi__getPassword")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getPassword()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getPassword() {
    return const jni.JStringType().fromRef(_getPassword(reference).object);
  }

  static final _getSsid = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode_WiFi__getSsid")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getSsid()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getSsid() {
    return const jni.JStringType().fromRef(_getSsid(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>, ffi.Int32)>>("Barcode_WiFi__new0")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  /// from: public void <init>(java.lang.String string, java.lang.String string1, int i)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode_WiFi(
    jni.JString string,
    jni.JString string1,
    int i,
  ) {
    return Barcode_WiFi.fromRef(
        _new0(string.reference, string1.reference, i).object);
  }
}

final class $Barcode_WiFiType extends jni.JObjType<Barcode_WiFi> {
  const $Barcode_WiFiType();

  @override
  String get signature =>
      r"Lcom/google/mlkit/vision/barcode/common/Barcode$WiFi;";

  @override
  Barcode_WiFi fromRef(jni.JObjectPtr ref) => Barcode_WiFi.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Barcode_WiFiType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Barcode_WiFiType) &&
        other is $Barcode_WiFiType;
  }
}

/// from: com.google.mlkit.vision.barcode.common.Barcode
class Barcode extends jni.JObject {
  @override
  late final jni.JObjType<Barcode> $type = type;

  Barcode.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $BarcodeType();

  /// from: static public final int FORMAT_UNKNOWN
  static const FORMAT_UNKNOWN = -1;

  /// from: static public final int FORMAT_ALL_FORMATS
  static const FORMAT_ALL_FORMATS = 0;

  /// from: static public final int FORMAT_CODE_128
  static const FORMAT_CODE_128 = 1;

  /// from: static public final int FORMAT_CODE_39
  static const FORMAT_CODE_39 = 2;

  /// from: static public final int FORMAT_CODE_93
  static const FORMAT_CODE_93 = 4;

  /// from: static public final int FORMAT_CODABAR
  static const FORMAT_CODABAR = 8;

  /// from: static public final int FORMAT_DATA_MATRIX
  static const FORMAT_DATA_MATRIX = 16;

  /// from: static public final int FORMAT_EAN_13
  static const FORMAT_EAN_13 = 32;

  /// from: static public final int FORMAT_EAN_8
  static const FORMAT_EAN_8 = 64;

  /// from: static public final int FORMAT_ITF
  static const FORMAT_ITF = 128;

  /// from: static public final int FORMAT_QR_CODE
  static const FORMAT_QR_CODE = 256;

  /// from: static public final int FORMAT_UPC_A
  static const FORMAT_UPC_A = 512;

  /// from: static public final int FORMAT_UPC_E
  static const FORMAT_UPC_E = 1024;

  /// from: static public final int FORMAT_PDF417
  static const FORMAT_PDF417 = 2048;

  /// from: static public final int FORMAT_AZTEC
  static const FORMAT_AZTEC = 4096;

  /// from: static public final int TYPE_UNKNOWN
  static const TYPE_UNKNOWN = 0;

  /// from: static public final int TYPE_CONTACT_INFO
  static const TYPE_CONTACT_INFO = 1;

  /// from: static public final int TYPE_EMAIL
  static const TYPE_EMAIL = 2;

  /// from: static public final int TYPE_ISBN
  static const TYPE_ISBN = 3;

  /// from: static public final int TYPE_PHONE
  static const TYPE_PHONE = 4;

  /// from: static public final int TYPE_PRODUCT
  static const TYPE_PRODUCT = 5;

  /// from: static public final int TYPE_SMS
  static const TYPE_SMS = 6;

  /// from: static public final int TYPE_TEXT
  static const TYPE_TEXT = 7;

  /// from: static public final int TYPE_URL
  static const TYPE_URL = 8;

  /// from: static public final int TYPE_WIFI
  static const TYPE_WIFI = 9;

  /// from: static public final int TYPE_GEO
  static const TYPE_GEO = 10;

  /// from: static public final int TYPE_CALENDAR_EVENT
  static const TYPE_CALENDAR_EVENT = 11;

  /// from: static public final int TYPE_DRIVER_LICENSE
  static const TYPE_DRIVER_LICENSE = 12;

  static final _getFormat = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getFormat")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getFormat()
  int getFormat() {
    return _getFormat(reference).integer;
  }

  static final _getValueType = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getValueType")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public int getValueType()
  int getValueType() {
    return _getValueType(reference).integer;
  }

  static final _getBoundingBox = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getBoundingBox")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Rect getBoundingBox()
  /// The returned object must be released after use, by calling the [release] method.
  Rect getBoundingBox() {
    return const $RectType().fromRef(_getBoundingBox(reference).object);
  }

  static final _getCalendarEvent = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getCalendarEvent")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$CalendarEvent getCalendarEvent()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_CalendarEvent getCalendarEvent() {
    return const $Barcode_CalendarEventType()
        .fromRef(_getCalendarEvent(reference).object);
  }

  static final _getContactInfo = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getContactInfo")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$ContactInfo getContactInfo()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_ContactInfo getContactInfo() {
    return const $Barcode_ContactInfoType()
        .fromRef(_getContactInfo(reference).object);
  }

  static final _getDriverLicense = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getDriverLicense")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$DriverLicense getDriverLicense()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_DriverLicense getDriverLicense() {
    return const $Barcode_DriverLicenseType()
        .fromRef(_getDriverLicense(reference).object);
  }

  static final _getEmail = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getEmail")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Email getEmail()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Email getEmail() {
    return const $Barcode_EmailType().fromRef(_getEmail(reference).object);
  }

  static final _getGeoPoint = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getGeoPoint")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$GeoPoint getGeoPoint()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_GeoPoint getGeoPoint() {
    return const $Barcode_GeoPointType()
        .fromRef(_getGeoPoint(reference).object);
  }

  static final _getPhone = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getPhone")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Phone getPhone()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Phone getPhone() {
    return const $Barcode_PhoneType().fromRef(_getPhone(reference).object);
  }

  static final _getSms = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Barcode__getSms")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$Sms getSms()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_Sms getSms() {
    return const $Barcode_SmsType().fromRef(_getSms(reference).object);
  }

  static final _getUrl = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Barcode__getUrl")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$UrlBookmark getUrl()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_UrlBookmark getUrl() {
    return const $Barcode_UrlBookmarkType().fromRef(_getUrl(reference).object);
  }

  static final _getWifi = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getWifi")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public com.google.mlkit.vision.barcode.common.Barcode$WiFi getWifi()
  /// The returned object must be released after use, by calling the [release] method.
  Barcode_WiFi getWifi() {
    return const $Barcode_WiFiType().fromRef(_getWifi(reference).object);
  }

  static final _getDisplayValue = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getDisplayValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getDisplayValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getDisplayValue() {
    return const jni.JStringType().fromRef(_getDisplayValue(reference).object);
  }

  static final _getRawValue = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getRawValue")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public java.lang.String getRawValue()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getRawValue() {
    return const jni.JStringType().fromRef(_getRawValue(reference).object);
  }

  static final _new0 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Barcode__new0")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.internal.BarcodeSource barcodeSource)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode(
    jni.JObject barcodeSource,
  ) {
    return Barcode.fromRef(_new0(barcodeSource.reference).object);
  }

  static final _new1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Barcode__new1")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public void <init>(com.google.mlkit.vision.barcode.common.internal.BarcodeSource barcodeSource, android.graphics.Matrix matrix)
  /// The returned object must be released after use, by calling the [release] method.
  factory Barcode.new1(
    jni.JObject barcodeSource,
    jni.JObject matrix,
  ) {
    return Barcode.fromRef(
        _new1(barcodeSource.reference, matrix.reference).object);
  }

  static final _getRawBytes = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getRawBytes")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public byte[] getRawBytes()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jbyte> getRawBytes() {
    return const jni.JArrayType(jni.jbyteType())
        .fromRef(_getRawBytes(reference).object);
  }

  static final _getCornerPoints = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Barcode__getCornerPoints")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public android.graphics.Point[] getCornerPoints()
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<Point> getCornerPoints() {
    return const jni.JArrayType($PointType())
        .fromRef(_getCornerPoints(reference).object);
  }
}

final class $BarcodeType extends jni.JObjType<Barcode> {
  const $BarcodeType();

  @override
  String get signature => r"Lcom/google/mlkit/vision/barcode/common/Barcode;";

  @override
  Barcode fromRef(jni.JObjectPtr ref) => Barcode.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($BarcodeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($BarcodeType) && other is $BarcodeType;
  }
}

/// from: java.lang.Runnable
class Runnable extends jni.JObject {
  @override
  late final jni.JObjType<Runnable> $type = type;

  Runnable.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $RunnableType();
  static final _run = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>)>>("Runnable__run")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void run()
  void run() {
    return _run(reference).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $RunnableImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"run()V") {
        _$impls[$p]!.run();
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Runnable.implement(
    $RunnableImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Runnable.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"java.lang.Runnable",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $RunnableImpl {
  factory $RunnableImpl({
    required void Function() run,
  }) = _$RunnableImpl;

  void run();
}

class _$RunnableImpl implements $RunnableImpl {
  _$RunnableImpl({
    required void Function() run,
  }) : _run = run;

  final void Function() _run;

  void run() {
    return _run();
  }
}

final class $RunnableType extends jni.JObjType<Runnable> {
  const $RunnableType();

  @override
  String get signature => r"Ljava/lang/Runnable;";

  @override
  Runnable fromRef(jni.JObjectPtr ref) => Runnable.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($RunnableType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($RunnableType) && other is $RunnableType;
  }
}

/// from: java.util.concurrent.Executor
class Executor extends jni.JObject {
  @override
  late final jni.JObjType<Executor> $type = type;

  Executor.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ExecutorType();
  static final _execute = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Executor__execute")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: public abstract void execute(java.lang.Runnable runnable)
  void execute(
    Runnable runnable,
  ) {
    return _execute(reference, runnable.reference).check();
  }

  /// Maps a specific port to the implemented interface.
  static final Map<int, $ExecutorImpl> _$impls = {};
  ReceivePort? _$p;

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    try {
      final $d = $i.methodDescriptor.toDartString(releaseOriginal: true);
      final $a = $i.args;
      if ($d == r"execute(Ljava/lang/Runnable;)V") {
        _$impls[$p]!.execute(
          $a[0].castTo(const $RunnableType(), releaseOriginal: true),
        );
        return jni.nullptr;
      }
    } catch (e) {
      return ProtectedJniExtensions.newDartException(e.toString());
    }
    return jni.nullptr;
  }

  factory Executor.implement(
    $ExecutorImpl $impl,
  ) {
    final $p = ReceivePort();
    final $x = Executor.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"java.util.concurrent.Executor",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$impls[$a] = $impl;
    $p.listen(($m) {
      if ($m == null) {
        _$impls.remove($p.sendPort.nativePort);
        $p.close();
        return;
      }
      final $i = $MethodInvocation.fromMessage($m as List<dynamic>);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

abstract class $ExecutorImpl {
  factory $ExecutorImpl({
    required void Function(Runnable runnable) execute,
  }) = _$ExecutorImpl;

  void execute(Runnable runnable);
}

class _$ExecutorImpl implements $ExecutorImpl {
  _$ExecutorImpl({
    required void Function(Runnable runnable) execute,
  }) : _execute = execute;

  final void Function(Runnable runnable) _execute;

  void execute(Runnable runnable) {
    return _execute(runnable);
  }
}

final class $ExecutorType extends jni.JObjType<Executor> {
  const $ExecutorType();

  @override
  String get signature => r"Ljava/util/concurrent/Executor;";

  @override
  Executor fromRef(jni.JObjectPtr ref) => Executor.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExecutorType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExecutorType) && other is $ExecutorType;
  }
}

/// from: java.util.concurrent.Executors
class Executors extends jni.JObject {
  @override
  late final jni.JObjType<Executors> $type = type;

  Executors.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  /// The type which includes information such as the signature of this class.
  static const type = $ExecutorsType();
  static final _newFixedThreadPool =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "Executors__newFixedThreadPool")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public java.util.concurrent.ExecutorService newFixedThreadPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newFixedThreadPool(
    int i,
  ) {
    return const jni.JObjectType().fromRef(_newFixedThreadPool(i).object);
  }

  static final _newWorkStealingPool =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "Executors__newWorkStealingPool")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public java.util.concurrent.ExecutorService newWorkStealingPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newWorkStealingPool(
    int i,
  ) {
    return const jni.JObjectType().fromRef(_newWorkStealingPool(i).object);
  }

  static final _newWorkStealingPool1 =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__newWorkStealingPool1")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ExecutorService newWorkStealingPool()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newWorkStealingPool1() {
    return const jni.JObjectType().fromRef(_newWorkStealingPool1().object);
  }

  static final _newFixedThreadPool1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Executors__newFixedThreadPool1")
      .asFunction<jni.JniResult Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService newFixedThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newFixedThreadPool1(
    int i,
    jni.JObject threadFactory,
  ) {
    return const jni.JObjectType()
        .fromRef(_newFixedThreadPool1(i, threadFactory.reference).object);
  }

  static final _newSingleThreadExecutor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__newSingleThreadExecutor")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ExecutorService newSingleThreadExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadExecutor() {
    return const jni.JObjectType().fromRef(_newSingleThreadExecutor().object);
  }

  static final _newSingleThreadExecutor1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__newSingleThreadExecutor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService newSingleThreadExecutor(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadExecutor1(
    jni.JObject threadFactory,
  ) {
    return const jni.JObjectType()
        .fromRef(_newSingleThreadExecutor1(threadFactory.reference).object);
  }

  static final _newCachedThreadPool =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__newCachedThreadPool")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ExecutorService newCachedThreadPool()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newCachedThreadPool() {
    return const jni.JObjectType().fromRef(_newCachedThreadPool().object);
  }

  static final _newCachedThreadPool1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__newCachedThreadPool1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService newCachedThreadPool(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newCachedThreadPool1(
    jni.JObject threadFactory,
  ) {
    return const jni.JObjectType()
        .fromRef(_newCachedThreadPool1(threadFactory.reference).object);
  }

  static final _newSingleThreadScheduledExecutor =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__newSingleThreadScheduledExecutor")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadScheduledExecutor() {
    return const jni.JObjectType()
        .fromRef(_newSingleThreadScheduledExecutor().object);
  }

  static final _newSingleThreadScheduledExecutor1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__newSingleThreadScheduledExecutor1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newSingleThreadScheduledExecutor(java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newSingleThreadScheduledExecutor1(
    jni.JObject threadFactory,
  ) {
    return const jni.JObjectType().fromRef(
        _newSingleThreadScheduledExecutor1(threadFactory.reference).object);
  }

  static final _newScheduledThreadPool =
      jniLookup<ffi.NativeFunction<jni.JniResult Function(ffi.Int32)>>(
              "Executors__newScheduledThreadPool")
          .asFunction<jni.JniResult Function(int)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newScheduledThreadPool(
    int i,
  ) {
    return const jni.JObjectType().fromRef(_newScheduledThreadPool(i).object);
  }

  static final _newScheduledThreadPool1 = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Int32,
                  ffi.Pointer<ffi.Void>)>>("Executors__newScheduledThreadPool1")
      .asFunction<jni.JniResult Function(int, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService newScheduledThreadPool(int i, java.util.concurrent.ThreadFactory threadFactory)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject newScheduledThreadPool1(
    int i,
    jni.JObject threadFactory,
  ) {
    return const jni.JObjectType()
        .fromRef(_newScheduledThreadPool1(i, threadFactory.reference).object);
  }

  static final _unconfigurableExecutorService = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__unconfigurableExecutorService")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ExecutorService unconfigurableExecutorService(java.util.concurrent.ExecutorService executorService)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject unconfigurableExecutorService(
    jni.JObject executorService,
  ) {
    return const jni.JObjectType().fromRef(
        _unconfigurableExecutorService(executorService.reference).object);
  }

  static final _unconfigurableScheduledExecutorService = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__unconfigurableScheduledExecutorService")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.ScheduledExecutorService unconfigurableScheduledExecutorService(java.util.concurrent.ScheduledExecutorService scheduledExecutorService)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject unconfigurableScheduledExecutorService(
    jni.JObject scheduledExecutorService,
  ) {
    return const jni.JObjectType().fromRef(
        _unconfigurableScheduledExecutorService(
                scheduledExecutorService.reference)
            .object);
  }

  static final _defaultThreadFactory =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__defaultThreadFactory")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ThreadFactory defaultThreadFactory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject defaultThreadFactory() {
    return const jni.JObjectType().fromRef(_defaultThreadFactory().object);
  }

  static final _privilegedThreadFactory =
      jniLookup<ffi.NativeFunction<jni.JniResult Function()>>(
              "Executors__privilegedThreadFactory")
          .asFunction<jni.JniResult Function()>();

  /// from: static public java.util.concurrent.ThreadFactory privilegedThreadFactory()
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject privilegedThreadFactory() {
    return const jni.JObjectType().fromRef(_privilegedThreadFactory().object);
  }

  static final _callable = jniLookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>>("Executors__callable")
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.lang.Runnable runnable, T object)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable<$T extends jni.JObject>(
    Runnable runnable,
    $T object, {
    jni.JObjType<$T>? T,
  }) {
    T ??= jni.lowestCommonSuperType([
      object.$type,
    ]) as jni.JObjType<$T>;
    return const jni.JObjectType()
        .fromRef(_callable(runnable.reference, object.reference).object);
  }

  static final _callable1 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__callable1")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.lang.Runnable runnable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable1(
    Runnable runnable,
  ) {
    return const jni.JObjectType()
        .fromRef(_callable1(runnable.reference).object);
  }

  static final _callable2 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__callable2")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.security.PrivilegedAction privilegedAction)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable2(
    jni.JObject privilegedAction,
  ) {
    return const jni.JObjectType()
        .fromRef(_callable2(privilegedAction.reference).object);
  }

  static final _callable3 = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__callable3")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable callable(java.security.PrivilegedExceptionAction privilegedExceptionAction)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject callable3(
    jni.JObject privilegedExceptionAction,
  ) {
    return const jni.JObjectType()
        .fromRef(_callable3(privilegedExceptionAction.reference).object);
  }

  static final _privilegedCallable = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__privilegedCallable")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable privilegedCallable(java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject privilegedCallable<$T extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$T> T,
  }) {
    return const jni.JObjectType()
        .fromRef(_privilegedCallable(callable.reference).object);
  }

  static final _privilegedCallableUsingCurrentClassLoader = jniLookup<
              ffi
              .NativeFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>>(
          "Executors__privilegedCallableUsingCurrentClassLoader")
      .asFunction<jni.JniResult Function(ffi.Pointer<ffi.Void>)>();

  /// from: static public java.util.concurrent.Callable privilegedCallableUsingCurrentClassLoader(java.util.concurrent.Callable callable)
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject
      privilegedCallableUsingCurrentClassLoader<$T extends jni.JObject>(
    jni.JObject callable, {
    required jni.JObjType<$T> T,
  }) {
    return const jni.JObjectType().fromRef(
        _privilegedCallableUsingCurrentClassLoader(callable.reference).object);
  }
}

final class $ExecutorsType extends jni.JObjType<Executors> {
  const $ExecutorsType();

  @override
  String get signature => r"Ljava/util/concurrent/Executors;";

  @override
  Executors fromRef(jni.JObjectPtr ref) => Executors.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($ExecutorsType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($ExecutorsType) && other is $ExecutorsType;
  }
}
