// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `libjpeg`.
///
class LibJPEG {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibJPEG(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibJPEG.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Default error-management setup
  ffi.Pointer<jpeg_error_mgr> jpeg_std_error(
    ffi.Pointer<jpeg_error_mgr> err,
  ) {
    return _jpeg_std_error(
      err,
    );
  }

  late final _jpeg_std_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<jpeg_error_mgr> Function(
              ffi.Pointer<jpeg_error_mgr>)>>('jpeg_std_error');
  late final _jpeg_std_error = _jpeg_std_errorPtr.asFunction<
      ffi.Pointer<jpeg_error_mgr> Function(ffi.Pointer<jpeg_error_mgr>)>();

  void jpeg_CreateCompress(
    j_compress_ptr cinfo,
    int version,
    int structsize,
  ) {
    return _jpeg_CreateCompress(
      cinfo,
      version,
      structsize,
    );
  }

  late final _jpeg_CreateCompressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              j_compress_ptr, ffi.Int, ffi.Size)>>('jpeg_CreateCompress');
  late final _jpeg_CreateCompress = _jpeg_CreateCompressPtr
      .asFunction<void Function(j_compress_ptr, int, int)>();

  void jpeg_CreateDecompress(
    j_decompress_ptr cinfo,
    int version,
    int structsize,
  ) {
    return _jpeg_CreateDecompress(
      cinfo,
      version,
      structsize,
    );
  }

  late final _jpeg_CreateDecompressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              j_decompress_ptr, ffi.Int, ffi.Size)>>('jpeg_CreateDecompress');
  late final _jpeg_CreateDecompress = _jpeg_CreateDecompressPtr
      .asFunction<void Function(j_decompress_ptr, int, int)>();

  /// Destruction of JPEG compression objects
  void jpeg_destroy_compress(
    j_compress_ptr cinfo,
  ) {
    return _jpeg_destroy_compress(
      cinfo,
    );
  }

  late final _jpeg_destroy_compressPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_compress_ptr)>>(
          'jpeg_destroy_compress');
  late final _jpeg_destroy_compress =
      _jpeg_destroy_compressPtr.asFunction<void Function(j_compress_ptr)>();

  void jpeg_destroy_decompress(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_destroy_decompress(
      cinfo,
    );
  }

  late final _jpeg_destroy_decompressPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_decompress_ptr)>>(
          'jpeg_destroy_decompress');
  late final _jpeg_destroy_decompress =
      _jpeg_destroy_decompressPtr.asFunction<void Function(j_decompress_ptr)>();

  /// Standard data source and destination managers: stdio streams. */
  /// /* Caller is responsible for opening the file before and closing after.
  void jpeg_stdio_dest(
    j_compress_ptr cinfo,
    ffi.Pointer<FILE> outfile,
  ) {
    return _jpeg_stdio_dest(
      cinfo,
      outfile,
    );
  }

  late final _jpeg_stdio_destPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              j_compress_ptr, ffi.Pointer<FILE>)>>('jpeg_stdio_dest');
  late final _jpeg_stdio_dest = _jpeg_stdio_destPtr
      .asFunction<void Function(j_compress_ptr, ffi.Pointer<FILE>)>();

  void jpeg_stdio_src(
    j_decompress_ptr cinfo,
    ffi.Pointer<FILE> infile,
  ) {
    return _jpeg_stdio_src(
      cinfo,
      infile,
    );
  }

  late final _jpeg_stdio_srcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              j_decompress_ptr, ffi.Pointer<FILE>)>>('jpeg_stdio_src');
  late final _jpeg_stdio_src = _jpeg_stdio_srcPtr
      .asFunction<void Function(j_decompress_ptr, ffi.Pointer<FILE>)>();

  /// Data source and destination managers: memory buffers.
  void jpeg_mem_dest(
    j_compress_ptr cinfo,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> outbuffer,
    ffi.Pointer<ffi.UnsignedLong> outsize,
  ) {
    return _jpeg_mem_dest(
      cinfo,
      outbuffer,
      outsize,
    );
  }

  late final _jpeg_mem_destPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              j_compress_ptr,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.UnsignedLong>)>>('jpeg_mem_dest');
  late final _jpeg_mem_dest = _jpeg_mem_destPtr.asFunction<
      void Function(j_compress_ptr, ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedLong>)>();

  void jpeg_mem_src(
    j_decompress_ptr cinfo,
    ffi.Pointer<ffi.UnsignedChar> inbuffer,
    int insize,
  ) {
    return _jpeg_mem_src(
      cinfo,
      inbuffer,
      insize,
    );
  }

  late final _jpeg_mem_srcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(j_decompress_ptr, ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong)>>('jpeg_mem_src');
  late final _jpeg_mem_src = _jpeg_mem_srcPtr.asFunction<
      void Function(j_decompress_ptr, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Default parameter setup for compression
  void jpeg_set_defaults(
    j_compress_ptr cinfo,
  ) {
    return _jpeg_set_defaults(
      cinfo,
    );
  }

  late final _jpeg_set_defaultsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_compress_ptr)>>(
          'jpeg_set_defaults');
  late final _jpeg_set_defaults =
      _jpeg_set_defaultsPtr.asFunction<void Function(j_compress_ptr)>();

  /// Compression parameter setup aids
  void jpeg_set_colorspace(
    j_compress_ptr cinfo,
    J_COLOR_SPACE colorspace,
  ) {
    return _jpeg_set_colorspace(
      cinfo,
      colorspace.value,
    );
  }

  late final _jpeg_set_colorspacePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(j_compress_ptr, ffi.UnsignedInt)>>(
      'jpeg_set_colorspace');
  late final _jpeg_set_colorspace =
      _jpeg_set_colorspacePtr.asFunction<void Function(j_compress_ptr, int)>();

  void jpeg_default_colorspace(
    j_compress_ptr cinfo,
  ) {
    return _jpeg_default_colorspace(
      cinfo,
    );
  }

  late final _jpeg_default_colorspacePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_compress_ptr)>>(
          'jpeg_default_colorspace');
  late final _jpeg_default_colorspace =
      _jpeg_default_colorspacePtr.asFunction<void Function(j_compress_ptr)>();

  void jpeg_set_quality(
    j_compress_ptr cinfo,
    int quality,
    int force_baseline,
  ) {
    return _jpeg_set_quality(
      cinfo,
      quality,
      force_baseline,
    );
  }

  late final _jpeg_set_qualityPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(j_compress_ptr, ffi.Int, boolean)>>(
      'jpeg_set_quality');
  late final _jpeg_set_quality = _jpeg_set_qualityPtr
      .asFunction<void Function(j_compress_ptr, int, int)>();

  void jpeg_set_linear_quality(
    j_compress_ptr cinfo,
    int scale_factor,
    int force_baseline,
  ) {
    return _jpeg_set_linear_quality(
      cinfo,
      scale_factor,
      force_baseline,
    );
  }

  late final _jpeg_set_linear_qualityPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(j_compress_ptr, ffi.Int, boolean)>>(
      'jpeg_set_linear_quality');
  late final _jpeg_set_linear_quality = _jpeg_set_linear_qualityPtr
      .asFunction<void Function(j_compress_ptr, int, int)>();

  void jpeg_add_quant_table(
    j_compress_ptr cinfo,
    int which_tbl,
    ffi.Pointer<ffi.UnsignedInt> basic_table,
    int scale_factor,
    int force_baseline,
  ) {
    return _jpeg_add_quant_table(
      cinfo,
      which_tbl,
      basic_table,
      scale_factor,
      force_baseline,
    );
  }

  late final _jpeg_add_quant_tablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              j_compress_ptr,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Int,
              boolean)>>('jpeg_add_quant_table');
  late final _jpeg_add_quant_table = _jpeg_add_quant_tablePtr.asFunction<
      void Function(
          j_compress_ptr, int, ffi.Pointer<ffi.UnsignedInt>, int, int)>();

  int jpeg_quality_scaling(
    int quality,
  ) {
    return _jpeg_quality_scaling(
      quality,
    );
  }

  late final _jpeg_quality_scalingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'jpeg_quality_scaling');
  late final _jpeg_quality_scaling =
      _jpeg_quality_scalingPtr.asFunction<int Function(int)>();

  void jpeg_enable_lossless(
    j_compress_ptr cinfo,
    int predictor_selection_value,
    int point_transform,
  ) {
    return _jpeg_enable_lossless(
      cinfo,
      predictor_selection_value,
      point_transform,
    );
  }

  late final _jpeg_enable_losslessPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(j_compress_ptr, ffi.Int, ffi.Int)>>(
      'jpeg_enable_lossless');
  late final _jpeg_enable_lossless = _jpeg_enable_losslessPtr
      .asFunction<void Function(j_compress_ptr, int, int)>();

  void jpeg_simple_progression(
    j_compress_ptr cinfo,
  ) {
    return _jpeg_simple_progression(
      cinfo,
    );
  }

  late final _jpeg_simple_progressionPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_compress_ptr)>>(
          'jpeg_simple_progression');
  late final _jpeg_simple_progression =
      _jpeg_simple_progressionPtr.asFunction<void Function(j_compress_ptr)>();

  void jpeg_suppress_tables(
    j_compress_ptr cinfo,
    int suppress,
  ) {
    return _jpeg_suppress_tables(
      cinfo,
      suppress,
    );
  }

  late final _jpeg_suppress_tablesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_compress_ptr, boolean)>>(
          'jpeg_suppress_tables');
  late final _jpeg_suppress_tables =
      _jpeg_suppress_tablesPtr.asFunction<void Function(j_compress_ptr, int)>();

  ffi.Pointer<JQUANT_TBL> jpeg_alloc_quant_table(
    j_common_ptr cinfo,
  ) {
    return _jpeg_alloc_quant_table(
      cinfo,
    );
  }

  late final _jpeg_alloc_quant_tablePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<JQUANT_TBL> Function(j_common_ptr)>>(
      'jpeg_alloc_quant_table');
  late final _jpeg_alloc_quant_table = _jpeg_alloc_quant_tablePtr
      .asFunction<ffi.Pointer<JQUANT_TBL> Function(j_common_ptr)>();

  ffi.Pointer<JHUFF_TBL> jpeg_alloc_huff_table(
    j_common_ptr cinfo,
  ) {
    return _jpeg_alloc_huff_table(
      cinfo,
    );
  }

  late final _jpeg_alloc_huff_tablePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<JHUFF_TBL> Function(j_common_ptr)>>(
      'jpeg_alloc_huff_table');
  late final _jpeg_alloc_huff_table = _jpeg_alloc_huff_tablePtr
      .asFunction<ffi.Pointer<JHUFF_TBL> Function(j_common_ptr)>();

  /// Main entry points for compression
  void jpeg_start_compress(
    j_compress_ptr cinfo,
    int write_all_tables,
  ) {
    return _jpeg_start_compress(
      cinfo,
      write_all_tables,
    );
  }

  late final _jpeg_start_compressPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_compress_ptr, boolean)>>(
          'jpeg_start_compress');
  late final _jpeg_start_compress =
      _jpeg_start_compressPtr.asFunction<void Function(j_compress_ptr, int)>();

  int jpeg_write_scanlines(
    j_compress_ptr cinfo,
    JSAMPARRAY scanlines,
    int num_lines,
  ) {
    return _jpeg_write_scanlines(
      cinfo,
      scanlines,
      num_lines,
    );
  }

  late final _jpeg_write_scanlinesPtr = _lookup<
      ffi.NativeFunction<
          JDIMENSION Function(
              j_compress_ptr, JSAMPARRAY, JDIMENSION)>>('jpeg_write_scanlines');
  late final _jpeg_write_scanlines = _jpeg_write_scanlinesPtr
      .asFunction<int Function(j_compress_ptr, JSAMPARRAY, int)>();

  int jpeg12_write_scanlines(
    j_compress_ptr cinfo,
    J12SAMPARRAY scanlines,
    int num_lines,
  ) {
    return _jpeg12_write_scanlines(
      cinfo,
      scanlines,
      num_lines,
    );
  }

  late final _jpeg12_write_scanlinesPtr = _lookup<
      ffi.NativeFunction<
          JDIMENSION Function(j_compress_ptr, J12SAMPARRAY,
              JDIMENSION)>>('jpeg12_write_scanlines');
  late final _jpeg12_write_scanlines = _jpeg12_write_scanlinesPtr
      .asFunction<int Function(j_compress_ptr, J12SAMPARRAY, int)>();

  int jpeg16_write_scanlines(
    j_compress_ptr cinfo,
    J16SAMPARRAY scanlines,
    int num_lines,
  ) {
    return _jpeg16_write_scanlines(
      cinfo,
      scanlines,
      num_lines,
    );
  }

  late final _jpeg16_write_scanlinesPtr = _lookup<
      ffi.NativeFunction<
          JDIMENSION Function(j_compress_ptr, J16SAMPARRAY,
              JDIMENSION)>>('jpeg16_write_scanlines');
  late final _jpeg16_write_scanlines = _jpeg16_write_scanlinesPtr
      .asFunction<int Function(j_compress_ptr, J16SAMPARRAY, int)>();

  void jpeg_finish_compress(
    j_compress_ptr cinfo,
  ) {
    return _jpeg_finish_compress(
      cinfo,
    );
  }

  late final _jpeg_finish_compressPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_compress_ptr)>>(
          'jpeg_finish_compress');
  late final _jpeg_finish_compress =
      _jpeg_finish_compressPtr.asFunction<void Function(j_compress_ptr)>();

  /// Replaces jpeg_write_scanlines when writing raw downsampled data.
  int jpeg_write_raw_data(
    j_compress_ptr cinfo,
    JSAMPIMAGE data,
    int num_lines,
  ) {
    return _jpeg_write_raw_data(
      cinfo,
      data,
      num_lines,
    );
  }

  late final _jpeg_write_raw_dataPtr = _lookup<
      ffi.NativeFunction<
          JDIMENSION Function(
              j_compress_ptr, JSAMPIMAGE, JDIMENSION)>>('jpeg_write_raw_data');
  late final _jpeg_write_raw_data = _jpeg_write_raw_dataPtr
      .asFunction<int Function(j_compress_ptr, JSAMPIMAGE, int)>();

  int jpeg12_write_raw_data(
    j_compress_ptr cinfo,
    J12SAMPIMAGE data,
    int num_lines,
  ) {
    return _jpeg12_write_raw_data(
      cinfo,
      data,
      num_lines,
    );
  }

  late final _jpeg12_write_raw_dataPtr = _lookup<
      ffi.NativeFunction<
          JDIMENSION Function(j_compress_ptr, J12SAMPIMAGE,
              JDIMENSION)>>('jpeg12_write_raw_data');
  late final _jpeg12_write_raw_data = _jpeg12_write_raw_dataPtr
      .asFunction<int Function(j_compress_ptr, J12SAMPIMAGE, int)>();

  /// Write a special marker.  See libjpeg.txt concerning safe usage.
  void jpeg_write_marker(
    j_compress_ptr cinfo,
    int marker,
    ffi.Pointer<JOCTET> dataptr,
    int datalen,
  ) {
    return _jpeg_write_marker(
      cinfo,
      marker,
      dataptr,
      datalen,
    );
  }

  late final _jpeg_write_markerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(j_compress_ptr, ffi.Int, ffi.Pointer<JOCTET>,
              ffi.UnsignedInt)>>('jpeg_write_marker');
  late final _jpeg_write_marker = _jpeg_write_markerPtr.asFunction<
      void Function(j_compress_ptr, int, ffi.Pointer<JOCTET>, int)>();

  /// Same, but piecemeal.
  void jpeg_write_m_header(
    j_compress_ptr cinfo,
    int marker,
    int datalen,
  ) {
    return _jpeg_write_m_header(
      cinfo,
      marker,
      datalen,
    );
  }

  late final _jpeg_write_m_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(j_compress_ptr, ffi.Int,
              ffi.UnsignedInt)>>('jpeg_write_m_header');
  late final _jpeg_write_m_header = _jpeg_write_m_headerPtr
      .asFunction<void Function(j_compress_ptr, int, int)>();

  void jpeg_write_m_byte(
    j_compress_ptr cinfo,
    int val,
  ) {
    return _jpeg_write_m_byte(
      cinfo,
      val,
    );
  }

  late final _jpeg_write_m_bytePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_compress_ptr, ffi.Int)>>(
          'jpeg_write_m_byte');
  late final _jpeg_write_m_byte =
      _jpeg_write_m_bytePtr.asFunction<void Function(j_compress_ptr, int)>();

  /// Alternate compression function: just write an abbreviated table file
  void jpeg_write_tables(
    j_compress_ptr cinfo,
  ) {
    return _jpeg_write_tables(
      cinfo,
    );
  }

  late final _jpeg_write_tablesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_compress_ptr)>>(
          'jpeg_write_tables');
  late final _jpeg_write_tables =
      _jpeg_write_tablesPtr.asFunction<void Function(j_compress_ptr)>();

  /// Write ICC profile.  See libjpeg.txt for usage information.
  void jpeg_write_icc_profile(
    j_compress_ptr cinfo,
    ffi.Pointer<JOCTET> icc_data_ptr,
    int icc_data_len,
  ) {
    return _jpeg_write_icc_profile(
      cinfo,
      icc_data_ptr,
      icc_data_len,
    );
  }

  late final _jpeg_write_icc_profilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(j_compress_ptr, ffi.Pointer<JOCTET>,
              ffi.UnsignedInt)>>('jpeg_write_icc_profile');
  late final _jpeg_write_icc_profile = _jpeg_write_icc_profilePtr
      .asFunction<void Function(j_compress_ptr, ffi.Pointer<JOCTET>, int)>();

  /// Decompression startup: read start of JPEG datastream to see what's there
  int jpeg_read_header(
    j_decompress_ptr cinfo,
    int require_image,
  ) {
    return _jpeg_read_header(
      cinfo,
      require_image,
    );
  }

  late final _jpeg_read_headerPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(j_decompress_ptr, boolean)>>(
          'jpeg_read_header');
  late final _jpeg_read_header =
      _jpeg_read_headerPtr.asFunction<int Function(j_decompress_ptr, int)>();

  /// Main entry points for decompression
  int jpeg_start_decompress(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_start_decompress(
      cinfo,
    );
  }

  late final _jpeg_start_decompressPtr =
      _lookup<ffi.NativeFunction<boolean Function(j_decompress_ptr)>>(
          'jpeg_start_decompress');
  late final _jpeg_start_decompress =
      _jpeg_start_decompressPtr.asFunction<int Function(j_decompress_ptr)>();

  int jpeg_read_scanlines(
    j_decompress_ptr cinfo,
    JSAMPARRAY scanlines,
    int max_lines,
  ) {
    return _jpeg_read_scanlines(
      cinfo,
      scanlines,
      max_lines,
    );
  }

  late final _jpeg_read_scanlinesPtr = _lookup<
      ffi.NativeFunction<
          JDIMENSION Function(j_decompress_ptr, JSAMPARRAY,
              JDIMENSION)>>('jpeg_read_scanlines');
  late final _jpeg_read_scanlines = _jpeg_read_scanlinesPtr
      .asFunction<int Function(j_decompress_ptr, JSAMPARRAY, int)>();

  int jpeg12_read_scanlines(
    j_decompress_ptr cinfo,
    J12SAMPARRAY scanlines,
    int max_lines,
  ) {
    return _jpeg12_read_scanlines(
      cinfo,
      scanlines,
      max_lines,
    );
  }

  late final _jpeg12_read_scanlinesPtr = _lookup<
      ffi.NativeFunction<
          JDIMENSION Function(j_decompress_ptr, J12SAMPARRAY,
              JDIMENSION)>>('jpeg12_read_scanlines');
  late final _jpeg12_read_scanlines = _jpeg12_read_scanlinesPtr
      .asFunction<int Function(j_decompress_ptr, J12SAMPARRAY, int)>();

  int jpeg16_read_scanlines(
    j_decompress_ptr cinfo,
    J16SAMPARRAY scanlines,
    int max_lines,
  ) {
    return _jpeg16_read_scanlines(
      cinfo,
      scanlines,
      max_lines,
    );
  }

  late final _jpeg16_read_scanlinesPtr = _lookup<
      ffi.NativeFunction<
          JDIMENSION Function(j_decompress_ptr, J16SAMPARRAY,
              JDIMENSION)>>('jpeg16_read_scanlines');
  late final _jpeg16_read_scanlines = _jpeg16_read_scanlinesPtr
      .asFunction<int Function(j_decompress_ptr, J16SAMPARRAY, int)>();

  int jpeg_skip_scanlines(
    j_decompress_ptr cinfo,
    int num_lines,
  ) {
    return _jpeg_skip_scanlines(
      cinfo,
      num_lines,
    );
  }

  late final _jpeg_skip_scanlinesPtr = _lookup<
          ffi
          .NativeFunction<JDIMENSION Function(j_decompress_ptr, JDIMENSION)>>(
      'jpeg_skip_scanlines');
  late final _jpeg_skip_scanlines =
      _jpeg_skip_scanlinesPtr.asFunction<int Function(j_decompress_ptr, int)>();

  int jpeg12_skip_scanlines(
    j_decompress_ptr cinfo,
    int num_lines,
  ) {
    return _jpeg12_skip_scanlines(
      cinfo,
      num_lines,
    );
  }

  late final _jpeg12_skip_scanlinesPtr = _lookup<
          ffi
          .NativeFunction<JDIMENSION Function(j_decompress_ptr, JDIMENSION)>>(
      'jpeg12_skip_scanlines');
  late final _jpeg12_skip_scanlines = _jpeg12_skip_scanlinesPtr
      .asFunction<int Function(j_decompress_ptr, int)>();

  void jpeg_crop_scanline(
    j_decompress_ptr cinfo,
    ffi.Pointer<JDIMENSION> xoffset,
    ffi.Pointer<JDIMENSION> width,
  ) {
    return _jpeg_crop_scanline(
      cinfo,
      xoffset,
      width,
    );
  }

  late final _jpeg_crop_scanlinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(j_decompress_ptr, ffi.Pointer<JDIMENSION>,
              ffi.Pointer<JDIMENSION>)>>('jpeg_crop_scanline');
  late final _jpeg_crop_scanline = _jpeg_crop_scanlinePtr.asFunction<
      void Function(j_decompress_ptr, ffi.Pointer<JDIMENSION>,
          ffi.Pointer<JDIMENSION>)>();

  void jpeg12_crop_scanline(
    j_decompress_ptr cinfo,
    ffi.Pointer<JDIMENSION> xoffset,
    ffi.Pointer<JDIMENSION> width,
  ) {
    return _jpeg12_crop_scanline(
      cinfo,
      xoffset,
      width,
    );
  }

  late final _jpeg12_crop_scanlinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(j_decompress_ptr, ffi.Pointer<JDIMENSION>,
              ffi.Pointer<JDIMENSION>)>>('jpeg12_crop_scanline');
  late final _jpeg12_crop_scanline = _jpeg12_crop_scanlinePtr.asFunction<
      void Function(j_decompress_ptr, ffi.Pointer<JDIMENSION>,
          ffi.Pointer<JDIMENSION>)>();

  int jpeg_finish_decompress(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_finish_decompress(
      cinfo,
    );
  }

  late final _jpeg_finish_decompressPtr =
      _lookup<ffi.NativeFunction<boolean Function(j_decompress_ptr)>>(
          'jpeg_finish_decompress');
  late final _jpeg_finish_decompress =
      _jpeg_finish_decompressPtr.asFunction<int Function(j_decompress_ptr)>();

  /// Replaces jpeg_read_scanlines when reading raw downsampled data.
  int jpeg_read_raw_data(
    j_decompress_ptr cinfo,
    JSAMPIMAGE data,
    int max_lines,
  ) {
    return _jpeg_read_raw_data(
      cinfo,
      data,
      max_lines,
    );
  }

  late final _jpeg_read_raw_dataPtr = _lookup<
      ffi.NativeFunction<
          JDIMENSION Function(
              j_decompress_ptr, JSAMPIMAGE, JDIMENSION)>>('jpeg_read_raw_data');
  late final _jpeg_read_raw_data = _jpeg_read_raw_dataPtr
      .asFunction<int Function(j_decompress_ptr, JSAMPIMAGE, int)>();

  int jpeg12_read_raw_data(
    j_decompress_ptr cinfo,
    J12SAMPIMAGE data,
    int max_lines,
  ) {
    return _jpeg12_read_raw_data(
      cinfo,
      data,
      max_lines,
    );
  }

  late final _jpeg12_read_raw_dataPtr = _lookup<
      ffi.NativeFunction<
          JDIMENSION Function(j_decompress_ptr, J12SAMPIMAGE,
              JDIMENSION)>>('jpeg12_read_raw_data');
  late final _jpeg12_read_raw_data = _jpeg12_read_raw_dataPtr
      .asFunction<int Function(j_decompress_ptr, J12SAMPIMAGE, int)>();

  /// Additional entry points for buffered-image mode.
  int jpeg_has_multiple_scans(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_has_multiple_scans(
      cinfo,
    );
  }

  late final _jpeg_has_multiple_scansPtr =
      _lookup<ffi.NativeFunction<boolean Function(j_decompress_ptr)>>(
          'jpeg_has_multiple_scans');
  late final _jpeg_has_multiple_scans =
      _jpeg_has_multiple_scansPtr.asFunction<int Function(j_decompress_ptr)>();

  int jpeg_start_output(
    j_decompress_ptr cinfo,
    int scan_number,
  ) {
    return _jpeg_start_output(
      cinfo,
      scan_number,
    );
  }

  late final _jpeg_start_outputPtr =
      _lookup<ffi.NativeFunction<boolean Function(j_decompress_ptr, ffi.Int)>>(
          'jpeg_start_output');
  late final _jpeg_start_output =
      _jpeg_start_outputPtr.asFunction<int Function(j_decompress_ptr, int)>();

  int jpeg_finish_output(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_finish_output(
      cinfo,
    );
  }

  late final _jpeg_finish_outputPtr =
      _lookup<ffi.NativeFunction<boolean Function(j_decompress_ptr)>>(
          'jpeg_finish_output');
  late final _jpeg_finish_output =
      _jpeg_finish_outputPtr.asFunction<int Function(j_decompress_ptr)>();

  int jpeg_input_complete(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_input_complete(
      cinfo,
    );
  }

  late final _jpeg_input_completePtr =
      _lookup<ffi.NativeFunction<boolean Function(j_decompress_ptr)>>(
          'jpeg_input_complete');
  late final _jpeg_input_complete =
      _jpeg_input_completePtr.asFunction<int Function(j_decompress_ptr)>();

  void jpeg_new_colormap(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_new_colormap(
      cinfo,
    );
  }

  late final _jpeg_new_colormapPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_decompress_ptr)>>(
          'jpeg_new_colormap');
  late final _jpeg_new_colormap =
      _jpeg_new_colormapPtr.asFunction<void Function(j_decompress_ptr)>();

  int jpeg_consume_input(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_consume_input(
      cinfo,
    );
  }

  late final _jpeg_consume_inputPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(j_decompress_ptr)>>(
          'jpeg_consume_input');
  late final _jpeg_consume_input =
      _jpeg_consume_inputPtr.asFunction<int Function(j_decompress_ptr)>();

  void jpeg_calc_output_dimensions(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_calc_output_dimensions(
      cinfo,
    );
  }

  late final _jpeg_calc_output_dimensionsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_decompress_ptr)>>(
          'jpeg_calc_output_dimensions');
  late final _jpeg_calc_output_dimensions = _jpeg_calc_output_dimensionsPtr
      .asFunction<void Function(j_decompress_ptr)>();

  /// Control saving of COM and APPn markers into marker_list.
  void jpeg_save_markers(
    j_decompress_ptr cinfo,
    int marker_code,
    int length_limit,
  ) {
    return _jpeg_save_markers(
      cinfo,
      marker_code,
      length_limit,
    );
  }

  late final _jpeg_save_markersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(j_decompress_ptr, ffi.Int,
              ffi.UnsignedInt)>>('jpeg_save_markers');
  late final _jpeg_save_markers = _jpeg_save_markersPtr
      .asFunction<void Function(j_decompress_ptr, int, int)>();

  /// Install a special processing method for COM or APPn markers.
  void jpeg_set_marker_processor(
    j_decompress_ptr cinfo,
    int marker_code,
    jpeg_marker_parser_method routine,
  ) {
    return _jpeg_set_marker_processor(
      cinfo,
      marker_code,
      routine,
    );
  }

  late final _jpeg_set_marker_processorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(j_decompress_ptr, ffi.Int,
              jpeg_marker_parser_method)>>('jpeg_set_marker_processor');
  late final _jpeg_set_marker_processor =
      _jpeg_set_marker_processorPtr.asFunction<
          void Function(j_decompress_ptr, int, jpeg_marker_parser_method)>();

  /// Read or write raw DCT coefficients --- useful for lossless transcoding.
  ffi.Pointer<jvirt_barray_ptr> jpeg_read_coefficients(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_read_coefficients(
      cinfo,
    );
  }

  late final _jpeg_read_coefficientsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<jvirt_barray_ptr> Function(
              j_decompress_ptr)>>('jpeg_read_coefficients');
  late final _jpeg_read_coefficients = _jpeg_read_coefficientsPtr
      .asFunction<ffi.Pointer<jvirt_barray_ptr> Function(j_decompress_ptr)>();

  void jpeg_write_coefficients(
    j_compress_ptr cinfo,
    ffi.Pointer<jvirt_barray_ptr> coef_arrays,
  ) {
    return _jpeg_write_coefficients(
      cinfo,
      coef_arrays,
    );
  }

  late final _jpeg_write_coefficientsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(j_compress_ptr,
              ffi.Pointer<jvirt_barray_ptr>)>>('jpeg_write_coefficients');
  late final _jpeg_write_coefficients = _jpeg_write_coefficientsPtr.asFunction<
      void Function(j_compress_ptr, ffi.Pointer<jvirt_barray_ptr>)>();

  void jpeg_copy_critical_parameters(
    j_decompress_ptr srcinfo,
    j_compress_ptr dstinfo,
  ) {
    return _jpeg_copy_critical_parameters(
      srcinfo,
      dstinfo,
    );
  }

  late final _jpeg_copy_critical_parametersPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(j_decompress_ptr, j_compress_ptr)>>(
      'jpeg_copy_critical_parameters');
  late final _jpeg_copy_critical_parameters = _jpeg_copy_critical_parametersPtr
      .asFunction<void Function(j_decompress_ptr, j_compress_ptr)>();

  /// If you choose to abort compression or decompression before completing
  /// jpeg_finish_(de)compress, then you need to clean up to release memory,
  /// temporary files, etc.  You can just call jpeg_destroy_(de)compress
  /// if you're done with the JPEG object, but if you want to clean it up and
  /// reuse it, call this:
  void jpeg_abort_compress(
    j_compress_ptr cinfo,
  ) {
    return _jpeg_abort_compress(
      cinfo,
    );
  }

  late final _jpeg_abort_compressPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_compress_ptr)>>(
          'jpeg_abort_compress');
  late final _jpeg_abort_compress =
      _jpeg_abort_compressPtr.asFunction<void Function(j_compress_ptr)>();

  void jpeg_abort_decompress(
    j_decompress_ptr cinfo,
  ) {
    return _jpeg_abort_decompress(
      cinfo,
    );
  }

  late final _jpeg_abort_decompressPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_decompress_ptr)>>(
          'jpeg_abort_decompress');
  late final _jpeg_abort_decompress =
      _jpeg_abort_decompressPtr.asFunction<void Function(j_decompress_ptr)>();

  /// Generic versions of jpeg_abort and jpeg_destroy that work on either
  /// flavor of JPEG object.  These may be more convenient in some places.
  void jpeg_abort(
    j_common_ptr cinfo,
  ) {
    return _jpeg_abort(
      cinfo,
    );
  }

  late final _jpeg_abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_common_ptr)>>(
          'jpeg_abort');
  late final _jpeg_abort =
      _jpeg_abortPtr.asFunction<void Function(j_common_ptr)>();

  void jpeg_destroy(
    j_common_ptr cinfo,
  ) {
    return _jpeg_destroy(
      cinfo,
    );
  }

  late final _jpeg_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(j_common_ptr)>>(
          'jpeg_destroy');
  late final _jpeg_destroy =
      _jpeg_destroyPtr.asFunction<void Function(j_common_ptr)>();

  /// Default restart-marker-resync procedure for use by data source modules
  int jpeg_resync_to_restart(
    j_decompress_ptr cinfo,
    int desired,
  ) {
    return _jpeg_resync_to_restart(
      cinfo,
      desired,
    );
  }

  late final _jpeg_resync_to_restartPtr =
      _lookup<ffi.NativeFunction<boolean Function(j_decompress_ptr, ffi.Int)>>(
          'jpeg_resync_to_restart');
  late final _jpeg_resync_to_restart = _jpeg_resync_to_restartPtr
      .asFunction<int Function(j_decompress_ptr, int)>();

  /// Read ICC profile.  See libjpeg.txt for usage information.
  int jpeg_read_icc_profile(
    j_decompress_ptr cinfo,
    ffi.Pointer<ffi.Pointer<JOCTET>> icc_data_ptr,
    ffi.Pointer<ffi.UnsignedInt> icc_data_len,
  ) {
    return _jpeg_read_icc_profile(
      cinfo,
      icc_data_ptr,
      icc_data_len,
    );
  }

  late final _jpeg_read_icc_profilePtr = _lookup<
      ffi.NativeFunction<
          boolean Function(j_decompress_ptr, ffi.Pointer<ffi.Pointer<JOCTET>>,
              ffi.Pointer<ffi.UnsignedInt>)>>('jpeg_read_icc_profile');
  late final _jpeg_read_icc_profile = _jpeg_read_icc_profilePtr.asFunction<
      int Function(j_decompress_ptr, ffi.Pointer<ffi.Pointer<JOCTET>>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// MCU block width (in pixels) for a given level of chrominance subsampling.
  /// MCU block sizes:
  /// - 8x8 for no subsampling or grayscale
  /// - 16x8 for 4:2:2
  /// - 8x16 for 4:4:0
  /// - 16x16 for 4:2:0
  /// - 32x8 for 4:1:1
  /// - 8x32 for 4:4:1
  late final ffi.Pointer<ffi.Pointer<ffi.Int>> _tjMCUWidth =
      _lookup<ffi.Pointer<ffi.Int>>('tjMCUWidth');

  ffi.Pointer<ffi.Int> get tjMCUWidth => _tjMCUWidth.value;

  set tjMCUWidth(ffi.Pointer<ffi.Int> value) => _tjMCUWidth.value = value;

  /// MCU block height (in pixels) for a given level of chrominance subsampling.
  /// MCU block sizes:
  /// - 8x8 for no subsampling or grayscale
  /// - 16x8 for 4:2:2
  /// - 8x16 for 4:4:0
  /// - 16x16 for 4:2:0
  /// - 32x8 for 4:1:1
  /// - 8x32 for 4:4:1
  late final ffi.Pointer<ffi.Pointer<ffi.Int>> _tjMCUHeight =
      _lookup<ffi.Pointer<ffi.Int>>('tjMCUHeight');

  ffi.Pointer<ffi.Int> get tjMCUHeight => _tjMCUHeight.value;

  set tjMCUHeight(ffi.Pointer<ffi.Int> value) => _tjMCUHeight.value = value;

  /// Red offset (in samples) for a given pixel format.  This specifies the number
  /// of samples that the red component is offset from the start of the pixel.
  /// For instance, if an 8-bit-per-component pixel of format TJPF_BGRX is stored
  /// in `unsigned char pixel[]`, then the red component will be
  /// `pixel[tjRedOffset[TJPF_BGRX]]`.  This will be -1 if the pixel format does
  /// not have a red component.
  late final ffi.Pointer<ffi.Pointer<ffi.Int>> _tjRedOffset =
      _lookup<ffi.Pointer<ffi.Int>>('tjRedOffset');

  ffi.Pointer<ffi.Int> get tjRedOffset => _tjRedOffset.value;

  set tjRedOffset(ffi.Pointer<ffi.Int> value) => _tjRedOffset.value = value;

  /// Green offset (in samples) for a given pixel format.  This specifies the
  /// number of samples that the green component is offset from the start of the
  /// pixel.  For instance, if an 8-bit-per-component pixel of format TJPF_BGRX is
  /// stored in `unsigned char pixel[]`, then the green component will be
  /// `pixel[tjGreenOffset[TJPF_BGRX]]`.  This will be -1 if the pixel format does
  /// not have a green component.
  late final ffi.Pointer<ffi.Pointer<ffi.Int>> _tjGreenOffset =
      _lookup<ffi.Pointer<ffi.Int>>('tjGreenOffset');

  ffi.Pointer<ffi.Int> get tjGreenOffset => _tjGreenOffset.value;

  set tjGreenOffset(ffi.Pointer<ffi.Int> value) => _tjGreenOffset.value = value;

  /// Blue offset (in samples) for a given pixel format.  This specifies the
  /// number of samples that the blue component is offset from the start of the
  /// pixel.  For instance, if an 8-bit-per-component pixel of format TJPF_BGRX is
  /// stored in `unsigned char pixel[]`, then the blue component will be
  /// `pixel[tjBlueOffset[TJPF_BGRX]]`.  This will be -1 if the pixel format does
  /// not have a blue component.
  late final ffi.Pointer<ffi.Pointer<ffi.Int>> _tjBlueOffset =
      _lookup<ffi.Pointer<ffi.Int>>('tjBlueOffset');

  ffi.Pointer<ffi.Int> get tjBlueOffset => _tjBlueOffset.value;

  set tjBlueOffset(ffi.Pointer<ffi.Int> value) => _tjBlueOffset.value = value;

  /// Alpha offset (in samples) for a given pixel format.  This specifies the
  /// number of samples that the alpha component is offset from the start of the
  /// pixel.  For instance, if an 8-bit-per-component pixel of format TJPF_BGRA is
  /// stored in `unsigned char pixel[]`, then the alpha component will be
  /// `pixel[tjAlphaOffset[TJPF_BGRA]]`.  This will be -1 if the pixel format does
  /// not have an alpha component.
  late final ffi.Pointer<ffi.Pointer<ffi.Int>> _tjAlphaOffset =
      _lookup<ffi.Pointer<ffi.Int>>('tjAlphaOffset');

  ffi.Pointer<ffi.Int> get tjAlphaOffset => _tjAlphaOffset.value;

  set tjAlphaOffset(ffi.Pointer<ffi.Int> value) => _tjAlphaOffset.value = value;

  /// Pixel size (in samples) for a given pixel format
  late final ffi.Pointer<ffi.Pointer<ffi.Int>> _tjPixelSize =
      _lookup<ffi.Pointer<ffi.Int>>('tjPixelSize');

  ffi.Pointer<ffi.Int> get tjPixelSize => _tjPixelSize.value;

  set tjPixelSize(ffi.Pointer<ffi.Int> value) => _tjPixelSize.value = value;

  /// A #tjregion structure that specifies no cropping
  late final ffi.Pointer<tjregion> _TJUNCROPPED =
      _lookup<tjregion>('TJUNCROPPED');

  tjregion get TJUNCROPPED => _TJUNCROPPED.ref;

  /// A #tjscalingfactor structure that specifies a scaling factor of 1/1 (no
  /// scaling)
  late final ffi.Pointer<tjscalingfactor> _TJUNSCALED =
      _lookup<tjscalingfactor>('TJUNSCALED');

  tjscalingfactor get TJUNSCALED => _TJUNSCALED.ref;

  /// Create a new TurboJPEG instance.
  ///
  /// @param initType one of the @ref TJINIT "initialization options"
  ///
  /// @return a handle to the newly-created instance, or NULL if an error occurred
  /// (see #tj3GetErrorStr().)
  tjhandle tj3Init(
    int initType,
  ) {
    return _tj3Init(
      initType,
    );
  }

  late final _tj3InitPtr =
      _lookup<ffi.NativeFunction<tjhandle Function(ffi.Int)>>('tj3Init');
  late final _tj3Init = _tj3InitPtr.asFunction<tjhandle Function(int)>();

  /// Set the value of a parameter.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param param one of the @ref TJPARAM "parameters"
  ///
  /// @param value value of the parameter (refer to @ref TJPARAM
  /// "parameter documentation")
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3Set(
    tjhandle handle,
    int param,
    int value,
  ) {
    return _tj3Set(
      handle,
      param,
      value,
    );
  }

  late final _tj3SetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle, ffi.Int, ffi.Int)>>(
          'tj3Set');
  late final _tj3Set =
      _tj3SetPtr.asFunction<int Function(tjhandle, int, int)>();

  /// Get the value of a parameter.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param param one of the @ref TJPARAM "parameters"
  ///
  /// @return the value of the specified parameter, or -1 if the value is unknown.
  int tj3Get(
    tjhandle handle,
    int param,
  ) {
    return _tj3Get(
      handle,
      param,
    );
  }

  late final _tj3GetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle, ffi.Int)>>(
          'tj3Get');
  late final _tj3Get = _tj3GetPtr.asFunction<int Function(tjhandle, int)>();

  /// Compress an 8-bit-per-sample packed-pixel RGB, grayscale, or CMYK image into
  /// an 8-bit-per-sample JPEG image.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,
  /// or CMYK source image to be compressed.  This buffer should normally be
  /// `pitch * height` samples in size.  However, you can also use this parameter
  /// to compress from a specific region of a larger buffer.
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch samples per row in the source image.  Normally this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.
  /// (Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this
  /// parameter to specify the row alignment/padding of the source image, to skip
  /// rows, or to compress from a specific region of a larger buffer.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param jpegBuf address of a pointer to a byte buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  /// accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
  /// or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tj3JPEGBufSize().  This should ensure that the buffer never has to be
  /// re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)
  /// .
  /// If you choose option 1, then `*jpegSize` should be set to the size of your
  /// pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,
  /// you should always check `*jpegBuf` upon return from this function, as it may
  /// have changed.
  ///
  /// @param jpegSize pointer to a size_t variable that holds the size of the JPEG
  /// buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`
  /// should be set to the size of the buffer.  Upon return, `*jpegSize` will
  /// contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a
  /// JPEG buffer that is being reused from a previous call to one of the JPEG
  /// compression functions, then `*jpegSize` is ignored.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3Compress8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.Size> jpegSize,
  ) {
    return _tj3Compress8(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3Compress8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Size>)>>('tj3Compress8');
  late final _tj3Compress8 = _tj3Compress8Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int, int, int, int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Pointer<ffi.Size>)>();

  /// Compress a 12-bit-per-sample packed-pixel RGB, grayscale, or CMYK image into
  /// a 12-bit-per-sample JPEG image.
  ///
  /// \details \copydetails tj3Compress8()
  int tj3Compress12(
    tjhandle handle,
    ffi.Pointer<ffi.Short> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.Size> jpegSize,
  ) {
    return _tj3Compress12(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3Compress12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.Short>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Size>)>>('tj3Compress12');
  late final _tj3Compress12 = _tj3Compress12Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Short>, int, int, int, int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Pointer<ffi.Size>)>();

  /// Compress a 16-bit-per-sample packed-pixel RGB, grayscale, or CMYK image into
  /// a 16-bit-per-sample lossless JPEG image.
  ///
  /// \details \copydetails tj3Compress8()
  int tj3Compress16(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedShort> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.Size> jpegSize,
  ) {
    return _tj3Compress16(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3Compress16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Size>)>>('tj3Compress16');
  late final _tj3Compress16 = _tj3Compress16Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedShort>, int, int, int, int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Pointer<ffi.Size>)>();

  /// Compress an 8-bit-per-sample unified planar YUV image into an
  /// 8-bit-per-sample JPEG image.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcBuf pointer to a buffer containing a unified planar YUV source
  /// image to be compressed.  The size of this buffer should match the value
  /// returned by #tj3YUVBufSize() for the given image width, height, row
  /// alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The
  /// Y, U (Cb), and V (Cr) image planes should be stored sequentially in the
  /// buffer.  (Refer to @ref YUVnotes "YUV Image Format Notes".)
  ///
  /// @param width width (in pixels) of the source image.  If the width is not an
  /// even multiple of the MCU block width (see #tjMCUWidth), then an intermediate
  /// buffer copy will be performed.
  ///
  /// @param align row alignment (in bytes) of the source image (must be a power
  /// of 2.)  Setting this parameter to n indicates that each row in each plane of
  /// the source image is padded to the nearest multiple of n bytes
  /// (1 = unpadded.)
  ///
  /// @param height height (in pixels) of the source image.  If the height is not
  /// an even multiple of the MCU block height (see #tjMCUHeight), then an
  /// intermediate buffer copy will be performed.
  ///
  /// @param jpegBuf address of a pointer to a byte buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  /// accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
  /// or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tj3JPEGBufSize().  This should ensure that the buffer never has to be
  /// re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)
  /// .
  /// If you choose option 1, then `*jpegSize` should be set to the size of your
  /// pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,
  /// you should always check `*jpegBuf` upon return from this function, as it may
  /// have changed.
  ///
  /// @param jpegSize pointer to a size_t variable that holds the size of the JPEG
  /// buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`
  /// should be set to the size of the buffer.  Upon return, `*jpegSize` will
  /// contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a
  /// JPEG buffer that is being reused from a previous call to one of the JPEG
  /// compression functions, then `*jpegSize` is ignored.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3CompressFromYUV8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int align,
    int height,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.Size> jpegSize,
  ) {
    return _tj3CompressFromYUV8(
      handle,
      srcBuf,
      width,
      align,
      height,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3CompressFromYUV8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Size>)>>('tj3CompressFromYUV8');
  late final _tj3CompressFromYUV8 = _tj3CompressFromYUV8Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int, int, int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Pointer<ffi.Size>)>();

  /// Compress a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into
  /// an 8-bit-per-sample JPEG image.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if compressing a grayscale image) that contain a YUV
  /// source image to be compressed.  These planes can be contiguous or
  /// non-contiguous in memory.  The size of each plane should match the value
  /// returned by #tj3YUVPlaneSize() for the given image width, height, strides,
  /// and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer to
  /// @ref YUVnotes "YUV Image Format Notes" for more details.
  ///
  /// @param width width (in pixels) of the source image.  If the width is not an
  /// even multiple of the MCU block width (see #tjMCUWidth), then an intermediate
  /// buffer copy will be performed.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// row in the corresponding plane of the YUV source image.  Setting the stride
  /// for any plane to 0 is the same as setting it to the plane width (see
  /// @ref YUVnotes "YUV Image Format Notes".)  If `strides` is NULL, then the
  /// strides for all planes will be set to their respective plane widths.  You
  /// can adjust the strides in order to specify an arbitrary amount of row
  /// padding in each plane or to create a JPEG image from a subregion of a larger
  /// planar YUV image.
  ///
  /// @param height height (in pixels) of the source image.  If the height is not
  /// an even multiple of the MCU block height (see #tjMCUHeight), then an
  /// intermediate buffer copy will be performed.
  ///
  /// @param jpegBuf address of a pointer to a byte buffer that will receive the
  /// JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
  /// accommodate the size of the JPEG image.  Thus, you can choose to:
  /// -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and
  /// let TurboJPEG grow the buffer as needed,
  /// -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,
  /// or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tj3JPEGBufSize().  This should ensure that the buffer never has to be
  /// re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)
  /// .
  /// If you choose option 1, then `*jpegSize` should be set to the size of your
  /// pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,
  /// you should always check `*jpegBuf` upon return from this function, as it may
  /// have changed.
  ///
  /// @param jpegSize pointer to a size_t variable that holds the size of the JPEG
  /// buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`
  /// should be set to the size of the buffer.  Upon return, `*jpegSize` will
  /// contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a
  /// JPEG buffer that is being reused from a previous call to one of the JPEG
  /// compression functions, then `*jpegSize` is ignored.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3CompressFromYUVPlanes8(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> srcPlanes,
    int width,
    ffi.Pointer<ffi.Int> strides,
    int height,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.Size> jpegSize,
  ) {
    return _tj3CompressFromYUVPlanes8(
      handle,
      srcPlanes,
      width,
      strides,
      height,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3CompressFromYUVPlanes8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Size>)>>('tj3CompressFromYUVPlanes8');
  late final _tj3CompressFromYUVPlanes8 =
      _tj3CompressFromYUVPlanes8Ptr.asFunction<
          int Function(
              tjhandle,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              int,
              ffi.Pointer<ffi.Int>,
              int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Size>)>();

  /// The maximum size of the buffer (in bytes) required to hold a JPEG image with
  /// the given parameters.  The number of bytes returned by this function is
  /// larger than the size of the uncompressed source image.  The reason for this
  /// is that the JPEG format uses 16-bit coefficients, so it is possible for a
  /// very high-quality source image with very high-frequency content to expand
  /// rather than compress when converted to the JPEG format.  Such images
  /// represent very rare corner cases, but since there is no way to predict the
  /// size of a JPEG image prior to compression, the corner cases have to be
  /// handled.
  ///
  /// @param width width (in pixels) of the image
  ///
  /// @param height height (in pixels) of the image
  ///
  /// @param jpegSubsamp the level of chrominance subsampling to be used when
  /// generating the JPEG image (see @ref TJSAMP
  /// "Chrominance subsampling options".)  #TJSAMP_UNKNOWN is treated like
  /// #TJSAMP_444, since a buffer large enough to hold a JPEG image with no
  /// subsampling should also be large enough to hold a JPEG image with an
  /// arbitrary level of subsampling.  Note that lossless JPEG images always
  /// use #TJSAMP_444.
  ///
  /// @return the maximum size of the buffer (in bytes) required to hold the
  /// image, or 0 if the arguments are out of bounds.
  int tj3JPEGBufSize(
    int width,
    int height,
    int jpegSubsamp,
  ) {
    return _tj3JPEGBufSize(
      width,
      height,
      jpegSubsamp,
    );
  }

  late final _tj3JPEGBufSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'tj3JPEGBufSize');
  late final _tj3JPEGBufSize =
      _tj3JPEGBufSizePtr.asFunction<int Function(int, int, int)>();

  /// The size of the buffer (in bytes) required to hold a unified planar YUV
  /// image with the given parameters.
  ///
  /// @param width width (in pixels) of the image
  ///
  /// @param align row alignment (in bytes) of the image (must be a power of 2.)
  /// Setting this parameter to n specifies that each row in each plane of the
  /// image will be padded to the nearest multiple of n bytes (1 = unpadded.)
  ///
  /// @param height height (in pixels) of the image
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the size of the buffer (in bytes) required to hold the image, or 0
  /// if the arguments are out of bounds.
  int tj3YUVBufSize(
    int width,
    int align,
    int height,
    int subsamp,
  ) {
    return _tj3YUVBufSize(
      width,
      align,
      height,
      subsamp,
    );
  }

  late final _tj3YUVBufSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('tj3YUVBufSize');
  late final _tj3YUVBufSize =
      _tj3YUVBufSizePtr.asFunction<int Function(int, int, int, int)>();

  /// The size of the buffer (in bytes) required to hold a YUV image plane with
  /// the given parameters.
  ///
  /// @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)
  ///
  /// @param width width (in pixels) of the YUV image.  NOTE: this is the width of
  /// the whole image, not the plane width.
  ///
  /// @param stride bytes per row in the image plane.  Setting this to 0 is the
  /// equivalent of setting it to the plane width.
  ///
  /// @param height height (in pixels) of the YUV image.  NOTE: this is the height
  /// of the whole image, not the plane height.
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the size of the buffer (in bytes) required to hold the YUV image
  /// plane, or 0 if the arguments are out of bounds.
  int tj3YUVPlaneSize(
    int componentID,
    int width,
    int stride,
    int height,
    int subsamp,
  ) {
    return _tj3YUVPlaneSize(
      componentID,
      width,
      stride,
      height,
      subsamp,
    );
  }

  late final _tj3YUVPlaneSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('tj3YUVPlaneSize');
  late final _tj3YUVPlaneSize =
      _tj3YUVPlaneSizePtr.asFunction<int Function(int, int, int, int, int)>();

  /// The plane width of a YUV image plane with the given parameters.  Refer to
  /// @ref YUVnotes "YUV Image Format Notes" for a description of plane width.
  ///
  /// @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)
  ///
  /// @param width width (in pixels) of the YUV image
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the plane width of a YUV image plane with the given parameters, or 0
  /// if the arguments are out of bounds.
  int tj3YUVPlaneWidth(
    int componentID,
    int width,
    int subsamp,
  ) {
    return _tj3YUVPlaneWidth(
      componentID,
      width,
      subsamp,
    );
  }

  late final _tj3YUVPlaneWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'tj3YUVPlaneWidth');
  late final _tj3YUVPlaneWidth =
      _tj3YUVPlaneWidthPtr.asFunction<int Function(int, int, int)>();

  /// The plane height of a YUV image plane with the given parameters.  Refer to
  /// @ref YUVnotes "YUV Image Format Notes" for a description of plane height.
  ///
  /// @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)
  ///
  /// @param height height (in pixels) of the YUV image
  ///
  /// @param subsamp level of chrominance subsampling in the image (see
  /// @ref TJSAMP "Chrominance subsampling options".)
  ///
  /// @return the plane height of a YUV image plane with the given parameters, or
  /// 0 if the arguments are out of bounds.
  int tj3YUVPlaneHeight(
    int componentID,
    int height,
    int subsamp,
  ) {
    return _tj3YUVPlaneHeight(
      componentID,
      height,
      subsamp,
    );
  }

  late final _tj3YUVPlaneHeightPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'tj3YUVPlaneHeight');
  late final _tj3YUVPlaneHeight =
      _tj3YUVPlaneHeightPtr.asFunction<int Function(int, int, int)>();

  /// Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into an
  /// 8-bit-per-sample unified planar YUV image.  This function performs color
  /// conversion (which is accelerated in the libjpeg-turbo implementation) but
  /// does not execute any of the other steps in the JPEG compression process.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale
  /// source image to be encoded.  This buffer should normally be `pitch * height`
  /// bytes in size.  However, you can also use this parameter to encode from a
  /// specific region of a larger buffer.
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch bytes per row in the source image.  Normally this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.
  /// (Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this
  /// parameter to specify the row alignment/padding of the source image, to skip
  /// rows, or to encode from a specific region of a larger packed-pixel image.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param dstBuf pointer to a buffer that will receive the unified planar YUV
  /// image.  Use #tj3YUVBufSize() to determine the appropriate size for this
  /// buffer based on the image width, height, row alignment, and level of
  /// chrominance subsampling (see #TJPARAM_SUBSAMP.)  The Y, U (Cb), and V (Cr)
  /// image planes will be stored sequentially in the buffer.  (Refer to
  /// @ref YUVnotes "YUV Image Format Notes".)
  ///
  /// @param align row alignment (in bytes) of the YUV image (must be a power of
  /// 2.)  Setting this parameter to n will cause each row in each plane of the
  /// YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)
  /// To generate images suitable for X Video, `align` should be set to 4.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3EncodeYUV8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int align,
  ) {
    return _tj3EncodeYUV8(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstBuf,
      align,
    );
  }

  late final _tj3EncodeYUV8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('tj3EncodeYUV8');
  late final _tj3EncodeYUV8 = _tj3EncodeYUV8Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int, int, int, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into separate
  /// 8-bit-per-sample Y, U (Cb), and V (Cr) image planes.  This function performs
  /// color conversion (which is accelerated in the libjpeg-turbo implementation)
  /// but does not execute any of the other steps in the JPEG compression process.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// compression
  ///
  /// @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale
  /// source image to be encoded.  This buffer should normally be `pitch * height`
  /// bytes in size.  However, you can also use this parameter to encode from a
  /// specific region of a larger buffer.
  ///
  ///
  /// @param width width (in pixels) of the source image
  ///
  /// @param pitch bytes per row in the source image.  Normally this should be
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded.
  /// (Setting this parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this
  /// parameter to specify the row alignment/padding of the source image, to skip
  /// rows, or to encode from a specific region of a larger packed-pixel image.
  ///
  /// @param height height (in pixels) of the source image
  ///
  /// @param pixelFormat pixel format of the source image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if generating a grayscale image) that will receive the
  /// encoded image.  These planes can be contiguous or non-contiguous in memory.
  /// Use #tj3YUVPlaneSize() to determine the appropriate size for each plane
  /// based on the image width, height, strides, and level of chrominance
  /// subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes
  /// "YUV Image Format Notes" for more details.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// row in the corresponding plane of the YUV image.  Setting the stride for any
  /// plane to 0 is the same as setting it to the plane width (see @ref YUVnotes
  /// "YUV Image Format Notes".)  If `strides` is NULL, then the strides for all
  /// planes will be set to their respective plane widths.  You can adjust the
  /// strides in order to add an arbitrary amount of row padding to each plane or
  /// to encode an RGB or grayscale image into a subregion of a larger planar YUV
  /// image.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3EncodeYUVPlanes8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstPlanes,
    ffi.Pointer<ffi.Int> strides,
  ) {
    return _tj3EncodeYUVPlanes8(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstPlanes,
      strides,
    );
  }

  late final _tj3EncodeYUVPlanes8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Int>)>>('tj3EncodeYUVPlanes8');
  late final _tj3EncodeYUVPlanes8 = _tj3EncodeYUVPlanes8Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int, int, int, int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Pointer<ffi.Int>)>();

  /// Retrieve information about a JPEG image without decompressing it, or prime
  /// the decompressor with quantization and Huffman tables.  If a JPEG image is
  /// passed to this function, then the @ref TJPARAM "parameters" that describe
  /// the JPEG image will be set when the function returns.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param jpegBuf pointer to a byte buffer containing a JPEG image or an
  /// "abbreviated table specification" (AKA "tables-only") datastream.  Passing a
  /// tables-only datastream to this function primes the decompressor with
  /// quantization and Huffman tables that can be used when decompressing
  /// subsequent "abbreviated image" datastreams.  This is useful, for instance,
  /// when decompressing video streams in which all frames share the same
  /// quantization and Huffman tables.
  ///
  /// @param jpegSize size of the JPEG image or tables-only datastream (in bytes)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3DecompressHeader(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
  ) {
    return _tj3DecompressHeader(
      handle,
      jpegBuf,
      jpegSize,
    );
  }

  late final _tj3DecompressHeaderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('tj3DecompressHeader');
  late final _tj3DecompressHeader = _tj3DecompressHeaderPtr
      .asFunction<int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Returns a list of fractional scaling factors that the JPEG decompressor
  /// supports.
  ///
  /// @param numScalingFactors pointer to an integer variable that will receive
  /// the number of elements in the list
  ///
  /// @return a pointer to a list of fractional scaling factors, or NULL if an
  /// error is encountered (see #tj3GetErrorStr().)
  ffi.Pointer<tjscalingfactor> tj3GetScalingFactors(
    ffi.Pointer<ffi.Int> numScalingFactors,
  ) {
    return _tj3GetScalingFactors(
      numScalingFactors,
    );
  }

  late final _tj3GetScalingFactorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tjscalingfactor> Function(
              ffi.Pointer<ffi.Int>)>>('tj3GetScalingFactors');
  late final _tj3GetScalingFactors = _tj3GetScalingFactorsPtr.asFunction<
      ffi.Pointer<tjscalingfactor> Function(ffi.Pointer<ffi.Int>)>();

  /// Set the scaling factor for subsequent lossy decompression operations.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param scalingFactor #tjscalingfactor structure that specifies a fractional
  /// scaling factor that the decompressor supports (see #tj3GetScalingFactors()),
  /// or <tt>#TJUNSCALED</tt> for no scaling.  Decompression scaling is a function
  /// of the IDCT algorithm, so scaling factors are generally limited to multiples
  /// of 1/8.  If the entire JPEG image will be decompressed, then the width and
  /// height of the scaled destination image can be determined by calling
  /// #TJSCALED() with the JPEG width and height (see #TJPARAM_JPEGWIDTH and
  /// #TJPARAM_JPEGHEIGHT) and the specified scaling factor.  When decompressing
  /// into a planar YUV image, an intermediate buffer copy will be performed if
  /// the width or height of the scaled destination image is not an even multiple
  /// of the MCU block size (see #tjMCUWidth and #tjMCUHeight.)  Note that
  /// decompression scaling is not available (and the specified scaling factor is
  /// ignored) when decompressing lossless JPEG images (see #TJPARAM_LOSSLESS),
  /// since the IDCT algorithm is not used with those images.  Note also that
  /// #TJPARAM_FASTDCT is ignored when decompression scaling is enabled.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3SetScalingFactor(
    tjhandle handle,
    tjscalingfactor scalingFactor,
  ) {
    return _tj3SetScalingFactor(
      handle,
      scalingFactor,
    );
  }

  late final _tj3SetScalingFactorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle, tjscalingfactor)>>(
          'tj3SetScalingFactor');
  late final _tj3SetScalingFactor = _tj3SetScalingFactorPtr
      .asFunction<int Function(tjhandle, tjscalingfactor)>();

  /// Set the cropping region for partially decompressing a lossy JPEG image into
  /// a packed-pixel image
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param croppingRegion #tjregion structure that specifies a subregion of the
  /// JPEG image to decompress, or <tt>#TJUNCROPPED</tt> for no cropping.  The
  /// left boundary of the cropping region must be evenly divisible by the scaled
  /// MCU block width (<tt>#TJSCALED(#tjMCUWidth[subsamp], scalingFactor)</tt>,
  /// where `subsamp` is the level of chrominance subsampling in the JPEG image
  /// (see #TJPARAM_SUBSAMP) and `scalingFactor` is the decompression scaling
  /// factor (see #tj3SetScalingFactor().)  The cropping region should be
  /// specified relative to the scaled image dimensions.  Unless `croppingRegion`
  /// is <tt>#TJUNCROPPED</tt>, the JPEG header must be read (see
  /// #tj3DecompressHeader()) prior to calling this function.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3SetCroppingRegion(
    tjhandle handle,
    tjregion croppingRegion,
  ) {
    return _tj3SetCroppingRegion(
      handle,
      croppingRegion,
    );
  }

  late final _tj3SetCroppingRegionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle, tjregion)>>(
          'tj3SetCroppingRegion');
  late final _tj3SetCroppingRegion =
      _tj3SetCroppingRegionPtr.asFunction<int Function(tjhandle, tjregion)>();

  /// Decompress an 8-bit-per-sample JPEG image into an 8-bit-per-sample
  /// packed-pixel RGB, grayscale, or CMYK image.  The @ref TJPARAM "parameters"
  /// that describe the JPEG image will be set when this function returns.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param jpegBuf pointer to a byte buffer containing the JPEG image to
  /// decompress
  ///
  /// @param jpegSize size of the JPEG image (in bytes)
  ///
  /// @param dstBuf pointer to a buffer that will receive the packed-pixel
  /// decompressed image.  This buffer should normally be
  /// `pitch * destinationHeight` samples in size.  However, you can also use this
  /// parameter to decompress into a specific region of a larger buffer.  NOTE:
  /// If the JPEG image is lossy, then `destinationHeight` is either the scaled
  /// JPEG height (see #TJSCALED(), #TJPARAM_JPEGHEIGHT, and
  /// #tj3SetScalingFactor()) or the height of the cropping region (see
  /// #tj3SetCroppingRegion().)  If the JPEG image is lossless, then
  /// `destinationHeight` is the JPEG height.
  ///
  /// @param pitch samples per row in the destination image.  Normally this should
  /// be set to <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>, if the
  /// destination image should be unpadded.  (Setting this parameter to 0 is the
  /// equivalent of setting it to
  /// <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>.)  However, you can
  /// also use this parameter to specify the row alignment/padding of the
  /// destination image, to skip rows, or to decompress into a specific region of
  /// a larger buffer.  NOTE: If the JPEG image is lossy, then `destinationWidth`
  /// is either the scaled JPEG width (see #TJSCALED(), #TJPARAM_JPEGWIDTH, and
  /// #tj3SetScalingFactor()) or the width of the cropping region (see
  /// #tj3SetCroppingRegion().)  If the JPEG image is lossless, then
  /// `destinationWidth` is the JPEG width.
  ///
  /// @param pixelFormat pixel format of the destination image (see @ref
  /// TJPF "Pixel formats".)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3Decompress8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int pitch,
    int pixelFormat,
  ) {
    return _tj3Decompress8(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      pitch,
      pixelFormat,
    );
  }

  late final _tj3Decompress8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int)>>('tj3Decompress8');
  late final _tj3Decompress8 = _tj3Decompress8Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.UnsignedChar>, int, int)>();

  /// Decompress a 12-bit-per-sample JPEG image into a 12-bit-per-sample
  /// packed-pixel RGB, grayscale, or CMYK image.
  ///
  /// \details \copydetails tj3Decompress8()
  int tj3Decompress12(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Short> dstBuf,
    int pitch,
    int pixelFormat,
  ) {
    return _tj3Decompress12(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      pitch,
      pixelFormat,
    );
  }

  late final _tj3Decompress12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, ffi.Size,
              ffi.Pointer<ffi.Short>, ffi.Int, ffi.Int)>>('tj3Decompress12');
  late final _tj3Decompress12 = _tj3Decompress12Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.Short>, int, int)>();

  /// Decompress a 16-bit-per-sample lossless JPEG image into a 16-bit-per-sample
  /// packed-pixel RGB, grayscale, or CMYK image.
  ///
  /// \details \copydetails tj3Decompress8()
  int tj3Decompress16(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedShort> dstBuf,
    int pitch,
    int pixelFormat,
  ) {
    return _tj3Decompress16(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      pitch,
      pixelFormat,
    );
  }

  late final _tj3Decompress16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Int,
              ffi.Int)>>('tj3Decompress16');
  late final _tj3Decompress16 = _tj3Decompress16Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.UnsignedShort>, int, int)>();

  /// Decompress an 8-bit-per-sample JPEG image into an 8-bit-per-sample unified
  /// planar YUV image.  This function performs JPEG decompression but leaves out
  /// the color conversion step, so a planar YUV image is generated instead of a
  /// packed-pixel image.  The @ref TJPARAM "parameters" that describe the JPEG
  /// image will be set when this function returns.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param jpegBuf pointer to a byte buffer containing the JPEG image to
  /// decompress
  ///
  /// @param jpegSize size of the JPEG image (in bytes)
  ///
  /// @param dstBuf pointer to a buffer that will receive the unified planar YUV
  /// decompressed image.  Use #tj3YUVBufSize() to determine the appropriate size
  /// for this buffer based on the scaled JPEG width and height (see #TJSCALED(),
  /// #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()), row
  /// alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The
  /// Y, U (Cb), and V (Cr) image planes will be stored sequentially in the
  /// buffer.  (Refer to @ref YUVnotes "YUV Image Format Notes".)
  ///
  /// @param align row alignment (in bytes) of the YUV image (must be a power of
  /// 2.)  Setting this parameter to n will cause each row in each plane of the
  /// YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)
  /// To generate images suitable for X Video, `align` should be set to 4.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3DecompressToYUV8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int align,
  ) {
    return _tj3DecompressToYUV8(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      align,
    );
  }

  late final _tj3DecompressToYUV8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, ffi.Size,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('tj3DecompressToYUV8');
  late final _tj3DecompressToYUV8 = _tj3DecompressToYUV8Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Decompress an 8-bit-per-sample JPEG image into separate 8-bit-per-sample Y,
  /// U (Cb), and V (Cr) image planes.  This function performs JPEG decompression
  /// but leaves out the color conversion step, so a planar YUV image is generated
  /// instead of a packed-pixel image.  The @ref TJPARAM "parameters" that
  /// describe the JPEG image will be set when this function returns.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param jpegBuf pointer to a byte buffer containing the JPEG image to
  /// decompress
  ///
  /// @param jpegSize size of the JPEG image (in bytes)
  ///
  /// @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if decompressing a grayscale image) that will receive
  /// the decompressed image.  These planes can be contiguous or non-contiguous in
  /// memory.  Use #tj3YUVPlaneSize() to determine the appropriate size for each
  /// plane based on the scaled JPEG width and height (see #TJSCALED(),
  /// #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()),
  /// strides, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer
  /// to @ref YUVnotes "YUV Image Format Notes" for more details.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// row in the corresponding plane of the YUV image.  Setting the stride for any
  /// plane to 0 is the same as setting it to the scaled plane width (see
  /// @ref YUVnotes "YUV Image Format Notes".)  If `strides` is NULL, then the
  /// strides for all planes will be set to their respective scaled plane widths.
  /// You can adjust the strides in order to add an arbitrary amount of row
  /// padding to each plane or to decompress the JPEG image into a subregion of a
  /// larger planar YUV image.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3DecompressToYUVPlanes8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstPlanes,
    ffi.Pointer<ffi.Int> strides,
  ) {
    return _tj3DecompressToYUVPlanes8(
      handle,
      jpegBuf,
      jpegSize,
      dstPlanes,
      strides,
    );
  }

  late final _tj3DecompressToYUVPlanes8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Int>)>>('tj3DecompressToYUVPlanes8');
  late final _tj3DecompressToYUVPlanes8 =
      _tj3DecompressToYUVPlanes8Ptr.asFunction<
          int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Int>)>();

  /// Decode an 8-bit-per-sample unified planar YUV image into an 8-bit-per-sample
  /// packed-pixel RGB or grayscale image.  This function performs color
  /// conversion (which is accelerated in the libjpeg-turbo implementation) but
  /// does not execute any of the other steps in the JPEG decompression process.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param srcBuf pointer to a buffer containing a unified planar YUV source
  /// image to be decoded.  The size of this buffer should match the value
  /// returned by #tj3YUVBufSize() for the given image width, height, row
  /// alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The
  /// Y, U (Cb), and V (Cr) image planes should be stored sequentially in the
  /// source buffer.  (Refer to @ref YUVnotes "YUV Image Format Notes".)
  ///
  /// @param align row alignment (in bytes) of the YUV source image (must be a
  /// power of 2.)  Setting this parameter to n indicates that each row in each
  /// plane of the YUV source image is padded to the nearest multiple of n bytes
  /// (1 = unpadded.)
  ///
  /// @param dstBuf pointer to a buffer that will receive the packed-pixel decoded
  /// image.  This buffer should normally be `pitch * height` bytes in size.
  /// However, you can also use this parameter to decode into a specific region of
  /// a larger buffer.
  ///
  /// @param width width (in pixels) of the source and destination images
  ///
  /// @param pitch bytes per row in the destination image.  Normally this should
  /// be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination
  /// image should be unpadded.  (Setting this parameter to 0 is the equivalent of
  /// setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can
  /// also use this parameter to specify the row alignment/padding of the
  /// destination image, to skip rows, or to decode into a specific region of a
  /// larger buffer.
  ///
  /// @param height height (in pixels) of the source and destination images
  ///
  /// @param pixelFormat pixel format of the destination image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3DecodeYUV8(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int align,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
  ) {
    return _tj3DecodeYUV8(
      handle,
      srcBuf,
      align,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
    );
  }

  late final _tj3DecodeYUV8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tj3DecodeYUV8');
  late final _tj3DecodeYUV8 = _tj3DecodeYUV8Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.UnsignedChar>, int, int, int, int)>();

  /// Decode a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into an
  /// 8-bit-per-sample packed-pixel RGB or grayscale image.  This function
  /// performs color conversion (which is accelerated in the libjpeg-turbo
  /// implementation) but does not execute any of the other steps in the JPEG
  /// decompression process.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// decompression
  ///
  /// @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
  /// (or just a Y plane, if decoding a grayscale image) that contain a YUV image
  /// to be decoded.  These planes can be contiguous or non-contiguous in memory.
  /// The size of each plane should match the value returned by #tj3YUVPlaneSize()
  /// for the given image width, height, strides, and level of chrominance
  /// subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes
  /// "YUV Image Format Notes" for more details.
  ///
  /// @param strides an array of integers, each specifying the number of bytes per
  /// row in the corresponding plane of the YUV source image.  Setting the stride
  /// for any plane to 0 is the same as setting it to the plane width (see
  /// @ref YUVnotes "YUV Image Format Notes".)  If `strides` is NULL, then the
  /// strides for all planes will be set to their respective plane widths.  You
  /// can adjust the strides in order to specify an arbitrary amount of row
  /// padding in each plane or to decode a subregion of a larger planar YUV image.
  ///
  /// @param dstBuf pointer to a buffer that will receive the packed-pixel decoded
  /// image.  This buffer should normally be `pitch * height` bytes in size.
  /// However, you can also use this parameter to decode into a specific region of
  /// a larger buffer.
  ///
  /// @param width width (in pixels) of the source and destination images
  ///
  /// @param pitch bytes per row in the destination image.  Normally this should
  /// be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination
  /// image should be unpadded.  (Setting this parameter to 0 is the equivalent of
  /// setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can
  /// also use this parameter to specify the row alignment/padding of the
  /// destination image, to skip rows, or to decode into a specific region of a
  /// larger buffer.
  ///
  /// @param height height (in pixels) of the source and destination images
  ///
  /// @param pixelFormat pixel format of the destination image (see @ref TJPF
  /// "Pixel formats".)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3DecodeYUVPlanes8(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> srcPlanes,
    ffi.Pointer<ffi.Int> strides,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
  ) {
    return _tj3DecodeYUVPlanes8(
      handle,
      srcPlanes,
      strides,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
    );
  }

  late final _tj3DecodeYUVPlanes8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tj3DecodeYUVPlanes8');
  late final _tj3DecodeYUVPlanes8 = _tj3DecodeYUVPlanes8Ptr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int)>();

  /// Losslessly transform a JPEG image into another JPEG image.  Lossless
  /// transforms work by moving the raw DCT coefficients from one JPEG image
  /// structure to another without altering the values of the coefficients.  While
  /// this is typically faster than decompressing the image, transforming it, and
  /// re-compressing it, lossless transforms are not free.  Each lossless
  /// transform requires reading and performing entropy decoding on all of the
  /// coefficients in the source image, regardless of the size of the destination
  /// image.  Thus, this function provides a means of generating multiple
  /// transformed images from the same source or applying multiple transformations
  /// simultaneously, in order to eliminate the need to read the source
  /// coefficients multiple times.
  ///
  /// @param handle handle to a TurboJPEG instance that has been initialized for
  /// lossless transformation
  ///
  /// @param jpegBuf pointer to a byte buffer containing the JPEG source image to
  /// transform
  ///
  /// @param jpegSize size of the JPEG source image (in bytes)
  ///
  /// @param n the number of transformed JPEG images to generate
  ///
  /// @param dstBufs pointer to an array of n byte buffers.  `dstBufs[i]` will
  /// receive a JPEG image that has been transformed using the parameters in
  /// `transforms[i]`.  TurboJPEG has the ability to reallocate the JPEG
  /// destination buffer to accommodate the size of the transformed JPEG image.
  /// Thus, you can choose to:
  /// -# pre-allocate the JPEG destination buffer with an arbitrary size using
  /// #tj3Alloc() and let TurboJPEG grow the buffer as needed,
  /// -# set `dstBufs[i]` to NULL to tell TurboJPEG to allocate the buffer for
  /// you, or
  /// -# pre-allocate the buffer to a "worst case" size determined by calling
  /// #tj3JPEGBufSize() with the transformed or cropped width and height and the
  /// level of subsampling used in the source image.  Under normal circumstances,
  /// this should ensure that the buffer never has to be re-allocated.  (Setting
  /// #TJPARAM_NOREALLOC guarantees that it won't be.)  Note, however, that there
  /// are some rare cases (such as transforming images with a large amount of
  /// embedded EXIF or ICC profile data) in which the transformed JPEG image will
  /// be larger than the worst-case size, and #TJPARAM_NOREALLOC cannot be used in
  /// those cases.
  /// .
  /// If you choose option 1, then `dstSizes[i]` should be set to the size of your
  /// pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,
  /// you should always check `dstBufs[i]` upon return from this function, as it
  /// may have changed.
  ///
  /// @param dstSizes pointer to an array of n size_t variables that will receive
  /// the actual sizes (in bytes) of each transformed JPEG image.  If `dstBufs[i]`
  /// points to a pre-allocated buffer, then `dstSizes[i]` should be set to the
  /// size of the buffer.  Upon return, `dstSizes[i]` will contain the size of the
  /// transformed JPEG image (in bytes.)
  ///
  /// @param transforms pointer to an array of n #tjtransform structures, each of
  /// which specifies the transform parameters and/or cropping region for the
  /// corresponding transformed JPEG image.
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()
  /// and #tj3GetErrorCode().)
  int tj3Transform(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    int n,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstBufs,
    ffi.Pointer<ffi.Size> dstSizes,
    ffi.Pointer<tjtransform> transforms,
  ) {
    return _tj3Transform(
      handle,
      jpegBuf,
      jpegSize,
      n,
      dstBufs,
      dstSizes,
      transforms,
    );
  }

  late final _tj3TransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<tjtransform>)>>('tj3Transform');
  late final _tj3Transform = _tj3TransformPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<tjtransform>)>();

  /// Destroy a TurboJPEG instance.
  ///
  /// @param handle handle to a TurboJPEG instance.  If the handle is NULL, then
  /// this function has no effect.
  void tj3Destroy(
    tjhandle handle,
  ) {
    return _tj3Destroy(
      handle,
    );
  }

  late final _tj3DestroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(tjhandle)>>('tj3Destroy');
  late final _tj3Destroy = _tj3DestroyPtr.asFunction<void Function(tjhandle)>();

  /// Allocate a byte buffer for use with TurboJPEG.  You should always use this
  /// function to allocate the JPEG destination buffer(s) for the compression and
  /// transform functions unless you are disabling automatic buffer (re)allocation
  /// (by setting #TJPARAM_NOREALLOC.)
  ///
  /// @param bytes the number of bytes to allocate
  ///
  /// @return a pointer to a newly-allocated buffer with the specified number of
  /// bytes.
  ///
  /// @see tj3Free()
  ffi.Pointer<ffi.Void> tj3Alloc(
    int bytes,
  ) {
    return _tj3Alloc(
      bytes,
    );
  }

  late final _tj3AllocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'tj3Alloc');
  late final _tj3Alloc =
      _tj3AllocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Load an 8-bit-per-sample packed-pixel image from disk into memory.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param filename name of a file containing a packed-pixel image in Windows
  /// BMP or PBMPLUS (PPM/PGM) format.  Windows BMP files require 8-bit-per-sample
  /// data precision.  If the data precision of the PBMPLUS file does not match
  /// the target data precision, then upconverting or downconverting will be
  /// performed.
  ///
  /// @param width pointer to an integer variable that will receive the width (in
  /// pixels) of the packed-pixel image
  ///
  /// @param align row alignment (in samples) of the packed-pixel buffer to be
  /// returned (must be a power of 2.)  Setting this parameter to n will cause all
  /// rows in the buffer to be padded to the nearest multiple of n samples
  /// (1 = unpadded.)
  ///
  /// @param height pointer to an integer variable that will receive the height
  /// (in pixels) of the packed-pixel image
  ///
  /// @param pixelFormat pointer to an integer variable that specifies or will
  /// receive the pixel format of the packed-pixel buffer.  The behavior of this
  /// function will vary depending on the value of `*pixelFormat` passed to the
  /// function:
  /// - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will
  /// use the most optimal pixel format for the file type, and `*pixelFormat` will
  /// contain the ID of that pixel format upon successful return from this
  /// function.
  /// - @ref TJPF_GRAY : Only PGM files and 8-bit-per-pixel BMP files with a
  /// grayscale colormap can be loaded.
  /// - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be
  /// converted using a quick & dirty algorithm that is suitable only for testing
  /// purposes.  (Proper conversion between CMYK and other formats requires a
  /// color management system.)
  /// - Other @ref TJPF "pixel formats" : The packed-pixel buffer will use the
  /// specified pixel format, and pixel format conversion will be performed if
  /// necessary.
  ///
  /// @return a pointer to a newly-allocated buffer containing the packed-pixel
  /// image, converted to the chosen pixel format and with the chosen row
  /// alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This
  /// buffer should be freed using #tj3Free().
  ffi.Pointer<ffi.UnsignedChar> tj3LoadImage8(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Int> width,
    int align,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> pixelFormat,
  ) {
    return _tj3LoadImage8(
      handle,
      filename,
      width,
      align,
      height,
      pixelFormat,
    );
  }

  late final _tj3LoadImage8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              tjhandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('tj3LoadImage8');
  late final _tj3LoadImage8 = _tj3LoadImage8Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          tjhandle,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Load a 12-bit-per-sample packed-pixel image from disk into memory.
  ///
  /// \details \copydetails tj3LoadImage8()
  ffi.Pointer<ffi.Short> tj3LoadImage12(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Int> width,
    int align,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> pixelFormat,
  ) {
    return _tj3LoadImage12(
      handle,
      filename,
      width,
      align,
      height,
      pixelFormat,
    );
  }

  late final _tj3LoadImage12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Short> Function(
              tjhandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('tj3LoadImage12');
  late final _tj3LoadImage12 = _tj3LoadImage12Ptr.asFunction<
      ffi.Pointer<ffi.Short> Function(
          tjhandle,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Load a 16-bit-per-sample packed-pixel image from disk into memory.
  ///
  /// \details \copydetails tj3LoadImage8()
  ffi.Pointer<ffi.UnsignedShort> tj3LoadImage16(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Int> width,
    int align,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> pixelFormat,
  ) {
    return _tj3LoadImage16(
      handle,
      filename,
      width,
      align,
      height,
      pixelFormat,
    );
  }

  late final _tj3LoadImage16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              tjhandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('tj3LoadImage16');
  late final _tj3LoadImage16 = _tj3LoadImage16Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          tjhandle,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Save an 8-bit-per-sample packed-pixel image from memory to disk.
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @param filename name of a file to which to save the packed-pixel image.  The
  /// image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format, depending
  /// on the file extension.  Windows BMP files require 8-bit-per-sample data
  /// precision.
  ///
  /// @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,
  /// or CMYK image to be saved
  ///
  /// @param width width (in pixels) of the packed-pixel image
  ///
  /// @param pitch samples per row in the packed-pixel image.  Setting this
  /// parameter to 0 is the equivalent of setting it to
  /// <tt>width * #tjPixelSize[pixelFormat]</tt>.
  ///
  /// @param height height (in pixels) of the packed-pixel image
  ///
  /// @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF
  /// "Pixel formats".)  If this parameter is set to @ref TJPF_GRAY, then the
  /// image will be stored in PGM or 8-bit-per-pixel (indexed color) BMP format.
  /// Otherwise, the image will be stored in PPM or 24-bit-per-pixel BMP format.
  /// If this parameter is set to @ref TJPF_CMYK, then the CMYK pixels will be
  /// converted to RGB using a quick & dirty algorithm that is suitable only for
  /// testing purposes.  (Proper conversion between CMYK and other formats
  /// requires a color management system.)
  ///
  /// @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)
  int tj3SaveImage8(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.UnsignedChar> buffer,
    int width,
    int pitch,
    int height,
    int pixelFormat,
  ) {
    return _tj3SaveImage8(
      handle,
      filename,
      buffer,
      width,
      pitch,
      height,
      pixelFormat,
    );
  }

  late final _tj3SaveImage8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tj3SaveImage8');
  late final _tj3SaveImage8 = _tj3SaveImage8Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.UnsignedChar>, int, int, int, int)>();

  /// Save a 12-bit-per-sample packed-pixel image from memory to disk.
  ///
  /// \details \copydetails tj3SaveImage8()
  int tj3SaveImage12(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Short> buffer,
    int width,
    int pitch,
    int height,
    int pixelFormat,
  ) {
    return _tj3SaveImage12(
      handle,
      filename,
      buffer,
      width,
      pitch,
      height,
      pixelFormat,
    );
  }

  late final _tj3SaveImage12Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Short>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tj3SaveImage12');
  late final _tj3SaveImage12 = _tj3SaveImage12Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Short>, int,
          int, int, int)>();

  /// Save a 16-bit-per-sample packed-pixel image from memory to disk.
  ///
  /// \details \copydetails tj3SaveImage8()
  int tj3SaveImage16(
    tjhandle handle,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.UnsignedShort> buffer,
    int width,
    int pitch,
    int height,
    int pixelFormat,
  ) {
    return _tj3SaveImage16(
      handle,
      filename,
      buffer,
      width,
      pitch,
      height,
      pixelFormat,
    );
  }

  late final _tj3SaveImage16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tj3SaveImage16');
  late final _tj3SaveImage16 = _tj3SaveImage16Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.UnsignedShort>, int, int, int, int)>();

  /// Free a byte buffer previously allocated by TurboJPEG.  You should always use
  /// this function to free JPEG destination buffer(s) that were automatically
  /// (re)allocated by the compression and transform functions or that were
  /// manually allocated using #tj3Alloc().
  ///
  /// @param buffer address of the buffer to free.  If the address is NULL, then
  /// this function has no effect.
  ///
  /// @see tj3Alloc()
  void tj3Free(
    ffi.Pointer<ffi.Void> buffer,
  ) {
    return _tj3Free(
      buffer,
    );
  }

  late final _tj3FreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'tj3Free');
  late final _tj3Free =
      _tj3FreePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Returns a descriptive error message explaining why the last command failed.
  ///
  /// @param handle handle to a TurboJPEG instance, or NULL if the error was
  /// generated by a global function (but note that retrieving the error message
  /// for a global function is thread-safe only on platforms that support
  /// thread-local storage.)
  ///
  /// @return a descriptive error message explaining why the last command failed.
  ffi.Pointer<ffi.Char> tj3GetErrorStr(
    tjhandle handle,
  ) {
    return _tj3GetErrorStr(
      handle,
    );
  }

  late final _tj3GetErrorStrPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(tjhandle)>>(
          'tj3GetErrorStr');
  late final _tj3GetErrorStr =
      _tj3GetErrorStrPtr.asFunction<ffi.Pointer<ffi.Char> Function(tjhandle)>();

  /// Returns a code indicating the severity of the last error.  See
  /// @ref TJERR "Error codes".
  ///
  /// @param handle handle to a TurboJPEG instance
  ///
  /// @return a code indicating the severity of the last error.  See
  /// @ref TJERR "Error codes".
  int tj3GetErrorCode(
    tjhandle handle,
  ) {
    return _tj3GetErrorCode(
      handle,
    );
  }

  late final _tj3GetErrorCodePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle)>>(
          'tj3GetErrorCode');
  late final _tj3GetErrorCode =
      _tj3GetErrorCodePtr.asFunction<int Function(tjhandle)>();

  int TJBUFSIZE(
    int width,
    int height,
  ) {
    return _TJBUFSIZE(
      width,
      height,
    );
  }

  late final _TJBUFSIZEPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Int, ffi.Int)>>(
          'TJBUFSIZE');
  late final _TJBUFSIZE = _TJBUFSIZEPtr.asFunction<int Function(int, int)>();

  int tjCompress(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    ffi.Pointer<ffi.UnsignedLong> compressedSize,
    int jpegSubsamp,
    int jpegQual,
    int flags,
  ) {
    return _tjCompress(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelSize,
      dstBuf,
      compressedSize,
      jpegSubsamp,
      jpegQual,
      flags,
    );
  }

  late final _tjCompressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tjCompress');
  late final _tjCompress = _tjCompressPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          ffi.Pointer<ffi.UnsignedLong>,
          int,
          int,
          int)>();

  int tjDecompress(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelSize,
    int flags,
  ) {
    return _tjDecompress(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      width,
      pitch,
      height,
      pixelSize,
      flags,
    );
  }

  late final _tjDecompressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tjDecompress');
  late final _tjDecompress = _tjDecompressPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.UnsignedChar>, int, int, int, int, int)>();

  int tjDecompressHeader(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _tjDecompressHeader(
      handle,
      jpegBuf,
      jpegSize,
      width,
      height,
    );
  }

  late final _tjDecompressHeaderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('tjDecompressHeader');
  late final _tjDecompressHeader = _tjDecompressHeaderPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  int tjDestroy(
    tjhandle handle,
  ) {
    return _tjDestroy(
      handle,
    );
  }

  late final _tjDestroyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle)>>('tjDestroy');
  late final _tjDestroy = _tjDestroyPtr.asFunction<int Function(tjhandle)>();

  ffi.Pointer<ffi.Char> tjGetErrorStr() {
    return _tjGetErrorStr();
  }

  late final _tjGetErrorStrPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'tjGetErrorStr');
  late final _tjGetErrorStr =
      _tjGetErrorStrPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  tjhandle tjInitCompress() {
    return _tjInitCompress();
  }

  late final _tjInitCompressPtr =
      _lookup<ffi.NativeFunction<tjhandle Function()>>('tjInitCompress');
  late final _tjInitCompress =
      _tjInitCompressPtr.asFunction<tjhandle Function()>();

  tjhandle tjInitDecompress() {
    return _tjInitDecompress();
  }

  late final _tjInitDecompressPtr =
      _lookup<ffi.NativeFunction<tjhandle Function()>>('tjInitDecompress');
  late final _tjInitDecompress =
      _tjInitDecompressPtr.asFunction<tjhandle Function()>();

  int TJBUFSIZEYUV(
    int width,
    int height,
    int jpegSubsamp,
  ) {
    return _TJBUFSIZEYUV(
      width,
      height,
      jpegSubsamp,
    );
  }

  late final _TJBUFSIZEYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Int, ffi.Int, ffi.Int)>>('TJBUFSIZEYUV');
  late final _TJBUFSIZEYUV =
      _TJBUFSIZEYUVPtr.asFunction<int Function(int, int, int)>();

  int tjDecompressHeader2(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> jpegSubsamp,
  ) {
    return _tjDecompressHeader2(
      handle,
      jpegBuf,
      jpegSize,
      width,
      height,
      jpegSubsamp,
    );
  }

  late final _tjDecompressHeader2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('tjDecompressHeader2');
  late final _tjDecompressHeader2 = _tjDecompressHeader2Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  int tjDecompressToYUV(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int flags,
  ) {
    return _tjDecompressToYUV(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      flags,
    );
  }

  late final _tjDecompressToYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int)>>('tjDecompressToYUV');
  late final _tjDecompressToYUV = _tjDecompressToYUVPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  int tjEncodeYUV(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUV(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelSize,
      dstBuf,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int)>>('tjEncodeYUV');
  late final _tjEncodeYUV = _tjEncodeYUVPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int, int, int, int,
          ffi.Pointer<ffi.UnsignedChar>, int, int)>();

  ffi.Pointer<ffi.UnsignedChar> tjAlloc(
    int bytes,
  ) {
    return _tjAlloc(
      bytes,
    );
  }

  late final _tjAllocPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.UnsignedChar> Function(ffi.Int)>>(
      'tjAlloc');
  late final _tjAlloc =
      _tjAllocPtr.asFunction<ffi.Pointer<ffi.UnsignedChar> Function(int)>();

  int tjBufSize(
    int width,
    int height,
    int jpegSubsamp,
  ) {
    return _tjBufSize(
      width,
      height,
      jpegSubsamp,
    );
  }

  late final _tjBufSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Int, ffi.Int, ffi.Int)>>('tjBufSize');
  late final _tjBufSize =
      _tjBufSizePtr.asFunction<int Function(int, int, int)>();

  int tjBufSizeYUV(
    int width,
    int height,
    int subsamp,
  ) {
    return _tjBufSizeYUV(
      width,
      height,
      subsamp,
    );
  }

  late final _tjBufSizeYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Int, ffi.Int, ffi.Int)>>('tjBufSizeYUV');
  late final _tjBufSizeYUV =
      _tjBufSizeYUVPtr.asFunction<int Function(int, int, int)>();

  int tjCompress2(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.UnsignedLong> jpegSize,
    int jpegSubsamp,
    int jpegQual,
    int flags,
  ) {
    return _tjCompress2(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      jpegBuf,
      jpegSize,
      jpegSubsamp,
      jpegQual,
      flags,
    );
  }

  late final _tjCompress2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tjCompress2');
  late final _tjCompress2 = _tjCompress2Ptr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedLong>,
          int,
          int,
          int)>();

  int tjDecompress2(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjDecompress2(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjDecompress2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tjDecompress2');
  late final _tjDecompress2 = _tjDecompress2Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.UnsignedChar>, int, int, int, int, int)>();

  int tjEncodeYUV2(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUV2(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstBuf,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUV2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int)>>('tjEncodeYUV2');
  late final _tjEncodeYUV2 = _tjEncodeYUV2Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int, int, int, int,
          ffi.Pointer<ffi.UnsignedChar>, int, int)>();

  void tjFree(
    ffi.Pointer<ffi.UnsignedChar> buffer,
  ) {
    return _tjFree(
      buffer,
    );
  }

  late final _tjFreePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.UnsignedChar>)>>(
      'tjFree');
  late final _tjFree =
      _tjFreePtr.asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>)>();

  ffi.Pointer<tjscalingfactor> tjGetScalingFactors(
    ffi.Pointer<ffi.Int> numscalingfactors,
  ) {
    return _tjGetScalingFactors(
      numscalingfactors,
    );
  }

  late final _tjGetScalingFactorsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tjscalingfactor> Function(
              ffi.Pointer<ffi.Int>)>>('tjGetScalingFactors');
  late final _tjGetScalingFactors = _tjGetScalingFactorsPtr.asFunction<
      ffi.Pointer<tjscalingfactor> Function(ffi.Pointer<ffi.Int>)>();

  tjhandle tjInitTransform() {
    return _tjInitTransform();
  }

  late final _tjInitTransformPtr =
      _lookup<ffi.NativeFunction<tjhandle Function()>>('tjInitTransform');
  late final _tjInitTransform =
      _tjInitTransformPtr.asFunction<tjhandle Function()>();

  int tjTransform(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    int n,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstBufs,
    ffi.Pointer<ffi.UnsignedLong> dstSizes,
    ffi.Pointer<tjtransform> transforms,
    int flags,
  ) {
    return _tjTransform(
      handle,
      jpegBuf,
      jpegSize,
      n,
      dstBufs,
      dstSizes,
      transforms,
      flags,
    );
  }

  late final _tjTransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Pointer<tjtransform>,
              ffi.Int)>>('tjTransform');
  late final _tjTransform = _tjTransformPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedLong>,
          ffi.Pointer<tjtransform>,
          int)>();

  /// TurboJPEG 1.4+
  int tjBufSizeYUV2(
    int width,
    int align,
    int height,
    int subsamp,
  ) {
    return _tjBufSizeYUV2(
      width,
      align,
      height,
      subsamp,
    );
  }

  late final _tjBufSizeYUV2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('tjBufSizeYUV2');
  late final _tjBufSizeYUV2 =
      _tjBufSizeYUV2Ptr.asFunction<int Function(int, int, int, int)>();

  int tjCompressFromYUV(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int align,
    int height,
    int subsamp,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.UnsignedLong> jpegSize,
    int jpegQual,
    int flags,
  ) {
    return _tjCompressFromYUV(
      handle,
      srcBuf,
      width,
      align,
      height,
      subsamp,
      jpegBuf,
      jpegSize,
      jpegQual,
      flags,
    );
  }

  late final _tjCompressFromYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Int,
              ffi.Int)>>('tjCompressFromYUV');
  late final _tjCompressFromYUV = _tjCompressFromYUVPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedLong>,
          int,
          int)>();

  int tjCompressFromYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> srcPlanes,
    int width,
    ffi.Pointer<ffi.Int> strides,
    int height,
    int subsamp,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> jpegBuf,
    ffi.Pointer<ffi.UnsignedLong> jpegSize,
    int jpegQual,
    int flags,
  ) {
    return _tjCompressFromYUVPlanes(
      handle,
      srcPlanes,
      width,
      strides,
      height,
      subsamp,
      jpegBuf,
      jpegSize,
      jpegQual,
      flags,
    );
  }

  late final _tjCompressFromYUVPlanesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.UnsignedLong>,
              ffi.Int,
              ffi.Int)>>('tjCompressFromYUVPlanes');
  late final _tjCompressFromYUVPlanes = _tjCompressFromYUVPlanesPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          int,
          ffi.Pointer<ffi.Int>,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedLong>,
          int,
          int)>();

  int tjDecodeYUV(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int align,
    int subsamp,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjDecodeYUV(
      handle,
      srcBuf,
      align,
      subsamp,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjDecodeYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tjDecodeYUV');
  late final _tjDecodeYUV = _tjDecodeYUVPtr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int, int,
          ffi.Pointer<ffi.UnsignedChar>, int, int, int, int, int)>();

  int tjDecodeYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> srcPlanes,
    ffi.Pointer<ffi.Int> strides,
    int subsamp,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjDecodeYUVPlanes(
      handle,
      srcPlanes,
      strides,
      subsamp,
      dstBuf,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjDecodeYUVPlanesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tjDecodeYUVPlanes');
  late final _tjDecodeYUVPlanes = _tjDecodeYUVPlanesPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          int)>();

  int tjDecompressHeader3(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> jpegSubsamp,
    ffi.Pointer<ffi.Int> jpegColorspace,
  ) {
    return _tjDecompressHeader3(
      handle,
      jpegBuf,
      jpegSize,
      width,
      height,
      jpegSubsamp,
      jpegColorspace,
    );
  }

  late final _tjDecompressHeader3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('tjDecompressHeader3');
  late final _tjDecompressHeader3 = _tjDecompressHeader3Ptr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  int tjDecompressToYUV2(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int width,
    int align,
    int height,
    int flags,
  ) {
    return _tjDecompressToYUV2(
      handle,
      jpegBuf,
      jpegSize,
      dstBuf,
      width,
      align,
      height,
      flags,
    );
  }

  late final _tjDecompressToYUV2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tjDecompressToYUV2');
  late final _tjDecompressToYUV2 = _tjDecompressToYUV2Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int,
          ffi.Pointer<ffi.UnsignedChar>, int, int, int, int)>();

  int tjDecompressToYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> jpegBuf,
    int jpegSize,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstPlanes,
    int width,
    ffi.Pointer<ffi.Int> strides,
    int height,
    int flags,
  ) {
    return _tjDecompressToYUVPlanes(
      handle,
      jpegBuf,
      jpegSize,
      dstPlanes,
      width,
      strides,
      height,
      flags,
    );
  }

  late final _tjDecompressToYUVPlanesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int)>>('tjDecompressToYUVPlanes');
  late final _tjDecompressToYUVPlanes = _tjDecompressToYUVPlanesPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          int,
          ffi.Pointer<ffi.Int>,
          int,
          int)>();

  int tjEncodeYUV3(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.UnsignedChar> dstBuf,
    int align,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUV3(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstBuf,
      align,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUV3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('tjEncodeYUV3');
  late final _tjEncodeYUV3 = _tjEncodeYUV3Ptr.asFunction<
      int Function(tjhandle, ffi.Pointer<ffi.UnsignedChar>, int, int, int, int,
          ffi.Pointer<ffi.UnsignedChar>, int, int, int)>();

  int tjEncodeYUVPlanes(
    tjhandle handle,
    ffi.Pointer<ffi.UnsignedChar> srcBuf,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> dstPlanes,
    ffi.Pointer<ffi.Int> strides,
    int subsamp,
    int flags,
  ) {
    return _tjEncodeYUVPlanes(
      handle,
      srcBuf,
      width,
      pitch,
      height,
      pixelFormat,
      dstPlanes,
      strides,
      subsamp,
      flags,
    );
  }

  late final _tjEncodeYUVPlanesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              tjhandle,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int)>>('tjEncodeYUVPlanes');
  late final _tjEncodeYUVPlanes = _tjEncodeYUVPlanesPtr.asFunction<
      int Function(
          tjhandle,
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.Int>,
          int,
          int)>();

  int tjPlaneHeight(
    int componentID,
    int height,
    int subsamp,
  ) {
    return _tjPlaneHeight(
      componentID,
      height,
      subsamp,
    );
  }

  late final _tjPlaneHeightPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'tjPlaneHeight');
  late final _tjPlaneHeight =
      _tjPlaneHeightPtr.asFunction<int Function(int, int, int)>();

  int tjPlaneSizeYUV(
    int componentID,
    int width,
    int stride,
    int height,
    int subsamp,
  ) {
    return _tjPlaneSizeYUV(
      componentID,
      width,
      stride,
      height,
      subsamp,
    );
  }

  late final _tjPlaneSizeYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('tjPlaneSizeYUV');
  late final _tjPlaneSizeYUV =
      _tjPlaneSizeYUVPtr.asFunction<int Function(int, int, int, int, int)>();

  int tjPlaneWidth(
    int componentID,
    int width,
    int subsamp,
  ) {
    return _tjPlaneWidth(
      componentID,
      width,
      subsamp,
    );
  }

  late final _tjPlaneWidthPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'tjPlaneWidth');
  late final _tjPlaneWidth =
      _tjPlaneWidthPtr.asFunction<int Function(int, int, int)>();

  int tjGetErrorCode(
    tjhandle handle,
  ) {
    return _tjGetErrorCode(
      handle,
    );
  }

  late final _tjGetErrorCodePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(tjhandle)>>('tjGetErrorCode');
  late final _tjGetErrorCode =
      _tjGetErrorCodePtr.asFunction<int Function(tjhandle)>();

  ffi.Pointer<ffi.Char> tjGetErrorStr2(
    tjhandle handle,
  ) {
    return _tjGetErrorStr2(
      handle,
    );
  }

  late final _tjGetErrorStr2Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(tjhandle)>>(
          'tjGetErrorStr2');
  late final _tjGetErrorStr2 =
      _tjGetErrorStr2Ptr.asFunction<ffi.Pointer<ffi.Char> Function(tjhandle)>();

  ffi.Pointer<ffi.UnsignedChar> tjLoadImage(
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Int> width,
    int align,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> pixelFormat,
    int flags,
  ) {
    return _tjLoadImage(
      filename,
      width,
      align,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjLoadImagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedChar> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('tjLoadImage');
  late final _tjLoadImage = _tjLoadImagePtr.asFunction<
      ffi.Pointer<ffi.UnsignedChar> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          int)>();

  int tjSaveImage(
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.UnsignedChar> buffer,
    int width,
    int pitch,
    int height,
    int pixelFormat,
    int flags,
  ) {
    return _tjSaveImage(
      filename,
      buffer,
      width,
      pitch,
      height,
      pixelFormat,
      flags,
    );
  }

  late final _tjSaveImagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int, ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('tjSaveImage');
  late final _tjSaveImage = _tjSaveImagePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedChar>, int,
          int, int, int, int)>();
}

/// DCT coefficient quantization tables.
final class JQUANT_TBL extends ffi.Struct {
  /// quantization step for each coefficient
  @ffi.Array.multi([64])
  external ffi.Array<UINT16> quantval;

  /// TRUE when table has been output
  @boolean()
  external int sent_table;
}

/// UINT16 must hold at least the values 0..65535.
typedef UINT16 = ffi.UnsignedShort;
typedef DartUINT16 = int;
typedef boolean = ffi.Int;
typedef Dartboolean = int;

/// Huffman coding tables.
final class JHUFF_TBL extends ffi.Struct {
  /// bits[k] = # of symbols with codes of */
  /// /* length k bits; bits[0] is unused
  @ffi.Array.multi([17])
  external ffi.Array<UINT8> bits;

  /// The symbols, in order of incr code length
  @ffi.Array.multi([256])
  external ffi.Array<UINT8> huffval;

  /// TRUE when table has been output
  @boolean()
  external int sent_table;
}

/// UINT8 must hold at least the values 0..255.
typedef UINT8 = ffi.UnsignedChar;
typedef DartUINT8 = int;

/// Basic info about one component (color channel).
final class jpeg_component_info extends ffi.Struct {
  /// identifier for this component (0..255)
  @ffi.Int()
  external int component_id;

  /// its index in SOF or cinfo->comp_info[]
  @ffi.Int()
  external int component_index;

  /// horizontal sampling factor (1..4)
  @ffi.Int()
  external int h_samp_factor;

  /// vertical sampling factor (1..4)
  @ffi.Int()
  external int v_samp_factor;

  /// quantization table selector (0..3)
  @ffi.Int()
  external int quant_tbl_no;

  /// DC entropy table selector (0..3)
  @ffi.Int()
  external int dc_tbl_no;

  /// AC entropy table selector (0..3)
  @ffi.Int()
  external int ac_tbl_no;

  /// These values are computed during compression or decompression startup: */
  /// /* Component's size in data units.
  /// In lossy mode, any dummy blocks added to complete an MCU are not counted;
  /// therefore these values do not depend on whether a scan is interleaved or
  /// not.  In lossless mode, these are always equal to the image width and
  /// height.
  @JDIMENSION()
  external int width_in_blocks;

  @JDIMENSION()
  external int height_in_blocks;

  @ffi.Int()
  external int DCT_scaled_size;

  /// actual width in samples
  @JDIMENSION()
  external int downsampled_width;

  /// actual height in samples
  @JDIMENSION()
  external int downsampled_height;

  /// do we need the value of this component?
  @boolean()
  external int component_needed;

  /// number of data units per MCU, horizontally
  @ffi.Int()
  external int MCU_width;

  /// number of data units per MCU, vertically
  @ffi.Int()
  external int MCU_height;

  /// MCU_width * MCU_height
  @ffi.Int()
  external int MCU_blocks;

  /// MCU width in samples, MCU_width*DCT_[h_]scaled_size
  @ffi.Int()
  external int MCU_sample_width;

  /// # of non-dummy data units across in last MCU
  @ffi.Int()
  external int last_col_width;

  /// # of non-dummy data units down in last MCU
  @ffi.Int()
  external int last_row_height;

  /// Saved quantization table for component; NULL if none yet saved.
  /// See jdinput.c comments about the need for this information.
  /// This field is currently used only for decompression.
  external ffi.Pointer<JQUANT_TBL> quant_table;

  /// Private per-component storage for DCT or IDCT subsystem.
  external ffi.Pointer<ffi.Void> dct_table;
}

/// Datatype used for image dimensions.  The JPEG standard only supports
/// images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore
/// "unsigned int" is sufficient on all machines.  However, if you need to
/// handle larger images and you don't mind deviating from the spec, you
/// can change this datatype.  (Note that changing this datatype will
/// potentially require modifying the SIMD code.  The x86-64 SIMD extensions,
/// in particular, assume a 32-bit JDIMENSION.)
typedef JDIMENSION = ffi.UnsignedInt;
typedef DartJDIMENSION = int;

/// The script for encoding a multiple-scan file is an array of these:
final class jpeg_scan_info extends ffi.Struct {
  /// number of components encoded in this scan
  @ffi.Int()
  external int comps_in_scan;

  /// their SOF/comp_info[] indexes
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int> component_index;

  /// progressive JPEG spectral selection parms
  /// (Ss is the predictor selection value in
  /// lossless mode)
  @ffi.Int()
  external int Ss;

  @ffi.Int()
  external int Se;

  /// progressive JPEG successive approx. parms
  /// (Al is the point transform value in lossless
  /// mode)
  @ffi.Int()
  external int Ah;

  @ffi.Int()
  external int Al;
}

final class jpeg_marker_struct extends ffi.Struct {
  /// next in list, or NULL
  external jpeg_saved_marker_ptr next;

  /// marker code: JPEG_COM, or JPEG_APP0+n
  @UINT8()
  external int marker;

  /// # bytes of data in the file
  @ffi.UnsignedInt()
  external int original_length;

  /// # bytes of data saved at data[]
  @ffi.UnsignedInt()
  external int data_length;

  /// the data contained in the marker
  external ffi.Pointer<JOCTET> data;
}

/// The decompressor can save APPn and COM markers in a list of these:
typedef jpeg_saved_marker_ptr = ffi.Pointer<jpeg_marker_struct>;

/// Compressed datastreams are represented as arrays of JOCTET.
/// These must be EXACTLY 8 bits wide, at least once they are written to
/// external storage.  Note that when using the stdio data source/destination
/// managers, this is also the data type passed to fread/fwrite.
typedef JOCTET = ffi.UnsignedChar;
typedef DartJOCTET = int;

enum J_COLOR_SPACE {
  /// error/unspecified
  JCS_UNKNOWN(0),

  /// monochrome
  JCS_GRAYSCALE(1),

  /// red/green/blue as specified by the RGB_RED,
  /// RGB_GREEN, RGB_BLUE, and RGB_PIXELSIZE macros
  JCS_RGB(2),

  /// Y/Cb/Cr (also known as YUV)
  JCS_YCbCr(3),

  /// C/M/Y/K
  JCS_CMYK(4),

  /// Y/Cb/Cr/K
  JCS_YCCK(5),

  /// red/green/blue
  JCS_EXT_RGB(6),

  /// red/green/blue/x
  JCS_EXT_RGBX(7),

  /// blue/green/red
  JCS_EXT_BGR(8),

  /// blue/green/red/x
  JCS_EXT_BGRX(9),

  /// x/blue/green/red
  JCS_EXT_XBGR(10),

  /// x/red/green/blue
  JCS_EXT_XRGB(11),

  /// red/green/blue/alpha
  JCS_EXT_RGBA(12),

  /// blue/green/red/alpha
  JCS_EXT_BGRA(13),

  /// alpha/blue/green/red
  JCS_EXT_ABGR(14),

  /// alpha/red/green/blue
  JCS_EXT_ARGB(15),

  /// 5-bit red/6-bit green/5-bit blue
  /// [decompression only]
  JCS_RGB565(16);

  final int value;
  const J_COLOR_SPACE(this.value);

  static J_COLOR_SPACE fromValue(int value) => switch (value) {
        0 => JCS_UNKNOWN,
        1 => JCS_GRAYSCALE,
        2 => JCS_RGB,
        3 => JCS_YCbCr,
        4 => JCS_CMYK,
        5 => JCS_YCCK,
        6 => JCS_EXT_RGB,
        7 => JCS_EXT_RGBX,
        8 => JCS_EXT_BGR,
        9 => JCS_EXT_BGRX,
        10 => JCS_EXT_XBGR,
        11 => JCS_EXT_XRGB,
        12 => JCS_EXT_RGBA,
        13 => JCS_EXT_BGRA,
        14 => JCS_EXT_ABGR,
        15 => JCS_EXT_ARGB,
        16 => JCS_RGB565,
        _ => throw ArgumentError("Unknown value for J_COLOR_SPACE: $value"),
      };
}

/// DCT/IDCT algorithm options.
enum J_DCT_METHOD {
  /// accurate integer method
  JDCT_ISLOW(0),

  /// less accurate integer method [legacy feature]
  JDCT_IFAST(1),

  /// floating-point method [legacy feature]
  JDCT_FLOAT(2);

  final int value;
  const J_DCT_METHOD(this.value);

  static J_DCT_METHOD fromValue(int value) => switch (value) {
        0 => JDCT_ISLOW,
        1 => JDCT_IFAST,
        2 => JDCT_FLOAT,
        _ => throw ArgumentError("Unknown value for J_DCT_METHOD: $value"),
      };
}

/// Dithering options for decompression.
enum J_DITHER_MODE {
  /// no dithering
  JDITHER_NONE(0),

  /// simple ordered dither
  JDITHER_ORDERED(1),

  /// Floyd-Steinberg error diffusion dither
  JDITHER_FS(2);

  final int value;
  const J_DITHER_MODE(this.value);

  static J_DITHER_MODE fromValue(int value) => switch (value) {
        0 => JDITHER_NONE,
        1 => JDITHER_ORDERED,
        2 => JDITHER_FS,
        _ => throw ArgumentError("Unknown value for J_DITHER_MODE: $value"),
      };
}

/// Routines that are to be used by both halves of the library are declared
/// to receive a pointer to this structure.  There are no actual instances of
/// jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
final class jpeg_common_struct extends ffi.Struct {
  external ffi.Pointer<jpeg_error_mgr> err;

  external ffi.Pointer<jpeg_memory_mgr> mem;

  external ffi.Pointer<jpeg_progress_mgr> progress;

  external ffi.Pointer<ffi.Void> client_data;

  @boolean()
  external int is_decompressor;

  @ffi.Int()
  external int global_state;
}

/// Error handler object
final class jpeg_error_mgr extends ffi.Struct {
  /// Error exit handler: does not return to caller
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(j_common_ptr cinfo)>>
      error_exit;

  /// Conditionally emit a trace or warning message
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(j_common_ptr cinfo, ffi.Int msg_level)>>
      emit_message;

  /// Routine that actually outputs a trace or error message
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(j_common_ptr cinfo)>>
      output_message;

  /// Format a message string for the most recent JPEG error or message
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  j_common_ptr cinfo, ffi.Pointer<ffi.Char> buffer)>>
      format_message;

  /// Reset error state variables at start of a new image
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(j_common_ptr cinfo)>>
      reset_error_mgr;

  /// The message ID code and any parameters are saved here.
  /// A message can have one string parameter or up to 8 int parameters.
  @ffi.Int()
  external int msg_code;

  external UnnamedUnion1 msg_parm;

  /// max msg_level that will be displayed
  @ffi.Int()
  external int trace_level;

  /// number of corrupt-data warnings
  @ffi.Long()
  external int num_warnings;

  /// Library errors
  external ffi.Pointer<ffi.Pointer<ffi.Char>> jpeg_message_table;

  /// Table contains strings 0..last_jpeg_message
  @ffi.Int()
  external int last_jpeg_message;

  /// Non-library errors
  external ffi.Pointer<ffi.Pointer<ffi.Char>> addon_message_table;

  /// code for first string in addon table
  @ffi.Int()
  external int first_addon_message;

  /// code for last string in addon table
  @ffi.Int()
  external int last_addon_message;
}

typedef j_common_ptr = ffi.Pointer<jpeg_common_struct>;

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int> i;

  @ffi.Array.multi([80])
  external ffi.Array<ffi.Char> s;
}

final class jpeg_memory_mgr extends ffi.Struct {
  /// Method pointers
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  j_common_ptr cinfo, ffi.Int pool_id, ffi.Size sizeofobject)>>
      alloc_small;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  j_common_ptr cinfo, ffi.Int pool_id, ffi.Size sizeofobject)>>
      alloc_large;

  /// If cinfo->data_precision is 12 or 16, then this method and the
  /// access_virt_sarray method actually return a J12SAMPARRAY or a
  /// J16SAMPARRAY, so callers must type-cast the return value in order to
  /// read/write 12-bit or 16-bit samples from/to the array.
  external ffi.Pointer<
      ffi.NativeFunction<
          JSAMPARRAY Function(j_common_ptr cinfo, ffi.Int pool_id,
              JDIMENSION samplesperrow, JDIMENSION numrows)>> alloc_sarray;

  external ffi.Pointer<
      ffi.NativeFunction<
          JBLOCKARRAY Function(j_common_ptr cinfo, ffi.Int pool_id,
              JDIMENSION blocksperrow, JDIMENSION numrows)>> alloc_barray;

  external ffi.Pointer<
      ffi.NativeFunction<
          jvirt_sarray_ptr Function(
              j_common_ptr cinfo,
              ffi.Int pool_id,
              boolean pre_zero,
              JDIMENSION samplesperrow,
              JDIMENSION numrows,
              JDIMENSION maxaccess)>> request_virt_sarray;

  external ffi.Pointer<
      ffi.NativeFunction<
          jvirt_barray_ptr Function(
              j_common_ptr cinfo,
              ffi.Int pool_id,
              boolean pre_zero,
              JDIMENSION blocksperrow,
              JDIMENSION numrows,
              JDIMENSION maxaccess)>> request_virt_barray;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(j_common_ptr cinfo)>>
      realize_virt_arrays;

  external ffi.Pointer<
      ffi.NativeFunction<
          JSAMPARRAY Function(
              j_common_ptr cinfo,
              jvirt_sarray_ptr ptr,
              JDIMENSION start_row,
              JDIMENSION num_rows,
              boolean writable)>> access_virt_sarray;

  external ffi.Pointer<
      ffi.NativeFunction<
          JBLOCKARRAY Function(
              j_common_ptr cinfo,
              jvirt_barray_ptr ptr,
              JDIMENSION start_row,
              JDIMENSION num_rows,
              boolean writable)>> access_virt_barray;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(j_common_ptr cinfo, ffi.Int pool_id)>> free_pool;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(j_common_ptr cinfo)>>
      self_destruct;

  /// Limit on memory allocation for this JPEG object.  (Note that this is
  /// merely advisory, not a guaranteed maximum; it only affects the space
  /// used for virtual-array buffers.)  May be changed by outer application
  /// after creating the JPEG object.
  @ffi.Long()
  external int max_memory_to_use;

  /// Maximum allocation request accepted by alloc_large.
  @ffi.Long()
  external int max_alloc_chunk;
}

typedef JSAMPARRAY = ffi.Pointer<JSAMPROW>;

/// Data structures for images (arrays of samples and of DCT coefficients).
typedef JSAMPROW = ffi.Pointer<JSAMPLE>;

/// JSAMPLE should be the smallest type that will hold the values 0..255.
typedef JSAMPLE = ffi.UnsignedChar;
typedef DartJSAMPLE = int;
typedef JBLOCKARRAY = ffi.Pointer<JBLOCKROW>;
typedef JBLOCKROW = ffi.Pointer<ffi.Pointer<JCOEF>>;

/// Representation of a DCT frequency coefficient.
/// This should be a signed value of at least 16 bits; "short" is usually OK.
/// Again, we allocate large arrays of these, but you can change to int
/// if you have memory to burn and "short" is really slow.
typedef JCOEF = ffi.Short;
typedef DartJCOEF = int;
typedef jvirt_sarray_ptr = ffi.Pointer<jvirt_sarray_control>;

final class jvirt_sarray_control extends ffi.Opaque {}

typedef jvirt_barray_ptr = ffi.Pointer<jvirt_barray_control>;

final class jvirt_barray_control extends ffi.Opaque {}

/// Progress monitor object
final class jpeg_progress_mgr extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(j_common_ptr cinfo)>>
      progress_monitor;

  /// work units completed in this pass
  @ffi.Long()
  external int pass_counter;

  /// total number of work units in this pass
  @ffi.Long()
  external int pass_limit;

  /// passes completed so far
  @ffi.Int()
  external int completed_passes;

  /// total number of passes expected
  @ffi.Int()
  external int total_passes;
}

/// Master record for a compression instance
final class jpeg_compress_struct extends ffi.Struct {
  external ffi.Pointer<jpeg_error_mgr> err;

  external ffi.Pointer<jpeg_memory_mgr> mem;

  external ffi.Pointer<jpeg_progress_mgr> progress;

  external ffi.Pointer<ffi.Void> client_data;

  @boolean()
  external int is_decompressor;

  @ffi.Int()
  external int global_state;

  /// Destination for compressed data
  external ffi.Pointer<jpeg_destination_mgr> dest;

  /// input image width
  @JDIMENSION()
  external int image_width;

  /// input image height
  @JDIMENSION()
  external int image_height;

  /// # of color components in input image
  @ffi.Int()
  external int input_components;

  /// colorspace of input image
  @ffi.UnsignedInt()
  external int in_color_space;

  /// image gamma of input image
  @ffi.Double()
  external double input_gamma;

  /// bits of precision in image data
  @ffi.Int()
  external int data_precision;

  /// # of color components in JPEG image
  @ffi.Int()
  external int num_components;

  /// colorspace of JPEG image
  @ffi.UnsignedInt()
  external int jpeg_color_space;

  external ffi.Pointer<jpeg_component_info> comp_info;

  /// comp_info[i] describes component that appears i'th in SOF
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<JQUANT_TBL>> quant_tbl_ptrs;

  /// ptrs to coefficient quantization tables, or NULL if not defined,
  /// and corresponding scale factors (percentage, initialized 100).
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<JHUFF_TBL>> dc_huff_tbl_ptrs;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<JHUFF_TBL>> ac_huff_tbl_ptrs;

  /// L values for DC arith-coding tables
  @ffi.Array.multi([16])
  external ffi.Array<UINT8> arith_dc_L;

  /// U values for DC arith-coding tables
  @ffi.Array.multi([16])
  external ffi.Array<UINT8> arith_dc_U;

  /// Kx values for AC arith-coding tables
  @ffi.Array.multi([16])
  external ffi.Array<UINT8> arith_ac_K;

  /// # of entries in scan_info array
  @ffi.Int()
  external int num_scans;

  /// script for multi-scan file, or NULL
  external ffi.Pointer<jpeg_scan_info> scan_info;

  /// TRUE=caller supplies downsampled data
  @boolean()
  external int raw_data_in;

  /// TRUE=arithmetic coding, FALSE=Huffman
  @boolean()
  external int arith_code;

  /// TRUE=optimize entropy encoding parms
  @boolean()
  external int optimize_coding;

  /// TRUE=first samples are cosited
  @boolean()
  external int CCIR601_sampling;

  /// 1..100, or 0 for no input smoothing
  @ffi.Int()
  external int smoothing_factor;

  /// DCT algorithm selector
  @ffi.UnsignedInt()
  external int dct_method;

  /// MCUs per restart, or 0 for no restart
  @ffi.UnsignedInt()
  external int restart_interval;

  /// if > 0, MCU rows per restart interval
  @ffi.Int()
  external int restart_in_rows;

  /// should a JFIF marker be written?
  @boolean()
  external int write_JFIF_header;

  /// What to write for the JFIF version number
  @UINT8()
  external int JFIF_major_version;

  @UINT8()
  external int JFIF_minor_version;

  /// JFIF code for pixel size units
  @UINT8()
  external int density_unit;

  /// Horizontal pixel density
  @UINT16()
  external int X_density;

  /// Vertical pixel density
  @UINT16()
  external int Y_density;

  /// should an Adobe marker be written?
  @boolean()
  external int write_Adobe_marker;

  /// 0 .. image_height-1
  @JDIMENSION()
  external int next_scanline;

  /// TRUE if scan script uses progressive mode
  @boolean()
  external int progressive_mode;

  /// largest h_samp_factor
  @ffi.Int()
  external int max_h_samp_factor;

  /// largest v_samp_factor
  @ffi.Int()
  external int max_v_samp_factor;

  /// # of iMCU rows to be input to coefficient or
  /// difference controller
  @JDIMENSION()
  external int total_iMCU_rows;

  /// # of JPEG components in this scan
  @ffi.Int()
  external int comps_in_scan;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<jpeg_component_info>> cur_comp_info;

  /// # of MCUs across the image
  @JDIMENSION()
  external int MCUs_per_row;

  /// # of MCU rows in the image
  @JDIMENSION()
  external int MCU_rows_in_scan;

  /// # of data units per MCU
  @ffi.Int()
  external int blocks_in_MCU;

  @ffi.Array.multi([10])
  external ffi.Array<ffi.Int> MCU_membership;

  /// progressive/lossless JPEG parameters for
  /// scan
  @ffi.Int()
  external int Ss;

  @ffi.Int()
  external int Se;

  @ffi.Int()
  external int Ah;

  @ffi.Int()
  external int Al;

  /// Links to compression subobjects (methods and private variables of modules)
  external ffi.Pointer<jpeg_comp_master> master;

  external ffi.Pointer<jpeg_c_main_controller> main;

  external ffi.Pointer<jpeg_c_prep_controller> prep;

  external ffi.Pointer<jpeg_c_coef_controller> coef;

  external ffi.Pointer<jpeg_marker_writer> marker;

  external ffi.Pointer<jpeg_color_converter> cconvert;

  external ffi.Pointer<jpeg_downsampler> downsample;

  external ffi.Pointer<jpeg_forward_dct> fdct;

  external ffi.Pointer<jpeg_entropy_encoder> entropy;

  /// workspace for jpeg_simple_progression
  external ffi.Pointer<jpeg_scan_info> script_space;

  @ffi.Int()
  external int script_space_size;
}

/// Data destination object for compression
final class jpeg_destination_mgr extends ffi.Struct {
  /// => next byte to write in buffer
  external ffi.Pointer<JOCTET> next_output_byte;

  /// # of byte spaces remaining in buffer
  @ffi.Size()
  external int free_in_buffer;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(j_compress_ptr cinfo)>>
      init_destination;

  external ffi
      .Pointer<ffi.NativeFunction<boolean Function(j_compress_ptr cinfo)>>
      empty_output_buffer;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(j_compress_ptr cinfo)>>
      term_destination;
}

typedef j_compress_ptr = ffi.Pointer<jpeg_compress_struct>;

final class jpeg_comp_master extends ffi.Opaque {}

final class jpeg_c_main_controller extends ffi.Opaque {}

final class jpeg_c_prep_controller extends ffi.Opaque {}

final class jpeg_c_coef_controller extends ffi.Opaque {}

final class jpeg_marker_writer extends ffi.Opaque {}

final class jpeg_color_converter extends ffi.Opaque {}

final class jpeg_downsampler extends ffi.Opaque {}

final class jpeg_forward_dct extends ffi.Opaque {}

final class jpeg_entropy_encoder extends ffi.Opaque {}

/// Master record for a decompression instance
final class jpeg_decompress_struct extends ffi.Struct {
  external ffi.Pointer<jpeg_error_mgr> err;

  external ffi.Pointer<jpeg_memory_mgr> mem;

  external ffi.Pointer<jpeg_progress_mgr> progress;

  external ffi.Pointer<ffi.Void> client_data;

  @boolean()
  external int is_decompressor;

  @ffi.Int()
  external int global_state;

  /// Source of compressed data
  external ffi.Pointer<jpeg_source_mgr> src;

  /// nominal image width (from SOF marker)
  @JDIMENSION()
  external int image_width;

  /// nominal image height
  @JDIMENSION()
  external int image_height;

  /// # of color components in JPEG image
  @ffi.Int()
  external int num_components;

  /// colorspace of JPEG image
  @ffi.UnsignedInt()
  external int jpeg_color_space;

  /// colorspace for output
  @ffi.UnsignedInt()
  external int out_color_space;

  /// fraction by which to scale image
  @ffi.UnsignedInt()
  external int scale_num;

  @ffi.UnsignedInt()
  external int scale_denom;

  /// image gamma wanted in output
  @ffi.Double()
  external double output_gamma;

  /// TRUE=multiple output passes
  @boolean()
  external int buffered_image;

  /// TRUE=downsampled data wanted
  @boolean()
  external int raw_data_out;

  /// IDCT algorithm selector
  @ffi.UnsignedInt()
  external int dct_method;

  /// TRUE=apply fancy upsampling
  @boolean()
  external int do_fancy_upsampling;

  /// TRUE=apply interblock smoothing
  @boolean()
  external int do_block_smoothing;

  /// TRUE=colormapped output wanted
  @boolean()
  external int quantize_colors;

  /// type of color dithering to use
  @ffi.UnsignedInt()
  external int dither_mode;

  /// TRUE=use two-pass color quantization
  @boolean()
  external int two_pass_quantize;

  /// max # colors to use in created colormap
  @ffi.Int()
  external int desired_number_of_colors;

  /// enable future use of 1-pass quantizer
  @boolean()
  external int enable_1pass_quant;

  /// enable future use of external colormap
  @boolean()
  external int enable_external_quant;

  /// enable future use of 2-pass quantizer
  @boolean()
  external int enable_2pass_quant;

  /// scaled image width
  @JDIMENSION()
  external int output_width;

  /// scaled image height
  @JDIMENSION()
  external int output_height;

  /// # of color components in out_color_space
  @ffi.Int()
  external int out_color_components;

  /// # of color components returned
  @ffi.Int()
  external int output_components;

  /// min recommended height of scanline buffer
  @ffi.Int()
  external int rec_outbuf_height;

  /// number of entries in use
  @ffi.Int()
  external int actual_number_of_colors;

  /// The color map as a 2-D pixel array
  /// If data_precision is 12 or 16, then this is
  /// actually a J12SAMPARRAY or a J16SAMPARRAY,
  /// so callers must type-cast it in order to
  /// read/write 12-bit or 16-bit samples from/to
  /// the array.
  external JSAMPARRAY colormap;

  /// 0 .. output_height-1
  @JDIMENSION()
  external int output_scanline;

  /// Number of SOS markers seen so far
  @ffi.Int()
  external int input_scan_number;

  /// Number of iMCU rows completed
  @JDIMENSION()
  external int input_iMCU_row;

  /// Nominal scan number being displayed
  @ffi.Int()
  external int output_scan_number;

  /// Number of iMCU rows read
  @JDIMENSION()
  external int output_iMCU_row;

  /// -1 or current Al value for each coef
  external ffi.Pointer<ffi.Pointer<ffi.Int>> coef_bits;

  /// Quantization and Huffman tables are carried forward across input
  /// datastreams when processing abbreviated JPEG datastreams.
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<JQUANT_TBL>> quant_tbl_ptrs;

  /// ptrs to coefficient quantization tables, or NULL if not defined
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<JHUFF_TBL>> dc_huff_tbl_ptrs;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<JHUFF_TBL>> ac_huff_tbl_ptrs;

  /// bits of precision in image data
  @ffi.Int()
  external int data_precision;

  external ffi.Pointer<jpeg_component_info> comp_info;

  /// TRUE if SOFn specifies progressive mode
  @boolean()
  external int progressive_mode;

  /// TRUE=arithmetic coding, FALSE=Huffman
  @boolean()
  external int arith_code;

  /// L values for DC arith-coding tables
  @ffi.Array.multi([16])
  external ffi.Array<UINT8> arith_dc_L;

  /// U values for DC arith-coding tables
  @ffi.Array.multi([16])
  external ffi.Array<UINT8> arith_dc_U;

  /// Kx values for AC arith-coding tables
  @ffi.Array.multi([16])
  external ffi.Array<UINT8> arith_ac_K;

  /// MCUs per restart interval, or 0 for no restart
  @ffi.UnsignedInt()
  external int restart_interval;

  /// TRUE iff a JFIF APP0 marker was found
  @boolean()
  external int saw_JFIF_marker;

  /// JFIF version number
  @UINT8()
  external int JFIF_major_version;

  @UINT8()
  external int JFIF_minor_version;

  /// JFIF code for pixel size units
  @UINT8()
  external int density_unit;

  /// Horizontal pixel density
  @UINT16()
  external int X_density;

  /// Vertical pixel density
  @UINT16()
  external int Y_density;

  /// TRUE iff an Adobe APP14 marker was found
  @boolean()
  external int saw_Adobe_marker;

  /// Color transform code from Adobe marker
  @UINT8()
  external int Adobe_transform;

  /// TRUE=first samples are cosited
  @boolean()
  external int CCIR601_sampling;

  /// Head of list of saved markers
  external jpeg_saved_marker_ptr marker_list;

  /// largest h_samp_factor
  @ffi.Int()
  external int max_h_samp_factor;

  /// largest v_samp_factor
  @ffi.Int()
  external int max_v_samp_factor;

  /// smallest DCT_scaled_size of any component
  @ffi.Int()
  external int min_DCT_scaled_size;

  /// # of iMCU rows in image
  @JDIMENSION()
  external int total_iMCU_rows;

  /// table for fast range-limiting
  /// If data_precision is 12 or 16, then this is
  /// actually a J12SAMPLE pointer or a J16SAMPLE
  /// pointer, so callers must type-cast it in
  /// order to read 12-bit or 16-bit samples from
  /// the array.
  external ffi.Pointer<JSAMPLE> sample_range_limit;

  /// # of JPEG components in this scan
  @ffi.Int()
  external int comps_in_scan;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<jpeg_component_info>> cur_comp_info;

  /// # of MCUs across the image
  @JDIMENSION()
  external int MCUs_per_row;

  /// # of MCU rows in the image
  @JDIMENSION()
  external int MCU_rows_in_scan;

  /// # of data units per MCU
  @ffi.Int()
  external int blocks_in_MCU;

  @ffi.Array.multi([10])
  external ffi.Array<ffi.Int> MCU_membership;

  /// progressive/lossless JPEG parameters for
  /// scan
  @ffi.Int()
  external int Ss;

  @ffi.Int()
  external int Se;

  @ffi.Int()
  external int Ah;

  @ffi.Int()
  external int Al;

  /// This field is shared between entropy decoder and marker parser.
  /// It is either zero or the code of a JPEG marker that has been
  /// read from the data source, but has not yet been processed.
  @ffi.Int()
  external int unread_marker;

  /// Links to decompression subobjects (methods, private variables of modules)
  external ffi.Pointer<jpeg_decomp_master> master;

  external ffi.Pointer<jpeg_d_main_controller> main;

  external ffi.Pointer<jpeg_d_coef_controller> coef;

  external ffi.Pointer<jpeg_d_post_controller> post;

  external ffi.Pointer<jpeg_input_controller> inputctl;

  external ffi.Pointer<jpeg_marker_reader> marker;

  external ffi.Pointer<jpeg_entropy_decoder> entropy;

  external ffi.Pointer<jpeg_inverse_dct> idct;

  external ffi.Pointer<jpeg_upsampler> upsample;

  external ffi.Pointer<jpeg_color_deconverter> cconvert;

  external ffi.Pointer<jpeg_color_quantizer> cquantize;
}

/// Data source object for decompression
final class jpeg_source_mgr extends ffi.Struct {
  /// => next byte to read from buffer
  external ffi.Pointer<JOCTET> next_input_byte;

  /// # of bytes remaining in buffer
  @ffi.Size()
  external int bytes_in_buffer;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(j_decompress_ptr cinfo)>>
      init_source;

  external ffi
      .Pointer<ffi.NativeFunction<boolean Function(j_decompress_ptr cinfo)>>
      fill_input_buffer;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(j_decompress_ptr cinfo, ffi.Long num_bytes)>>
      skip_input_data;

  external ffi.Pointer<
          ffi.NativeFunction<
              boolean Function(j_decompress_ptr cinfo, ffi.Int desired)>>
      resync_to_restart;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(j_decompress_ptr cinfo)>>
      term_source;
}

typedef j_decompress_ptr = ffi.Pointer<jpeg_decompress_struct>;

final class jpeg_decomp_master extends ffi.Opaque {}

final class jpeg_d_main_controller extends ffi.Opaque {}

final class jpeg_d_coef_controller extends ffi.Opaque {}

final class jpeg_d_post_controller extends ffi.Opaque {}

final class jpeg_input_controller extends ffi.Opaque {}

final class jpeg_marker_reader extends ffi.Opaque {}

final class jpeg_entropy_decoder extends ffi.Opaque {}

final class jpeg_inverse_dct extends ffi.Opaque {}

final class jpeg_upsampler extends ffi.Opaque {}

final class jpeg_color_deconverter extends ffi.Opaque {}

final class jpeg_color_quantizer extends ffi.Opaque {}

typedef FILE = _IO_FILE;

final class _IO_FILE extends ffi.Struct {
  @ffi.Int()
  external int _flags;

  external ffi.Pointer<ffi.Char> _IO_read_ptr;

  external ffi.Pointer<ffi.Char> _IO_read_end;

  external ffi.Pointer<ffi.Char> _IO_read_base;

  external ffi.Pointer<ffi.Char> _IO_write_base;

  external ffi.Pointer<ffi.Char> _IO_write_ptr;

  external ffi.Pointer<ffi.Char> _IO_write_end;

  external ffi.Pointer<ffi.Char> _IO_buf_base;

  external ffi.Pointer<ffi.Char> _IO_buf_end;

  external ffi.Pointer<ffi.Char> _IO_save_base;

  external ffi.Pointer<ffi.Char> _IO_backup_base;

  external ffi.Pointer<ffi.Char> _IO_save_end;

  external ffi.Pointer<_IO_marker> _markers;

  external ffi.Pointer<_IO_FILE> _chain;

  @ffi.Int()
  external int _fileno;

  @ffi.Int()
  external int _flags2;

  @__off_t()
  external int _old_offset;

  @ffi.UnsignedShort()
  external int _cur_column;

  @ffi.SignedChar()
  external int _vtable_offset;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> _shortbuf;

  external ffi.Pointer<_IO_lock_t> _lock;

  @__off64_t()
  external int _offset;

  external ffi.Pointer<_IO_codecvt> _codecvt;

  external ffi.Pointer<_IO_wide_data> _wide_data;

  external ffi.Pointer<_IO_FILE> _freeres_list;

  external ffi.Pointer<ffi.Void> _freeres_buf;

  @ffi.Size()
  external int __pad5;

  @ffi.Int()
  external int _mode;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Char> _unused2;
}

final class _IO_marker extends ffi.Opaque {}

typedef __off_t = ffi.Long;
typedef Dart__off_t = int;
typedef _IO_lock_t = ffi.Void;
typedef Dart_IO_lock_t = void;
typedef __off64_t = ffi.Long;
typedef Dart__off64_t = int;

final class _IO_codecvt extends ffi.Opaque {}

final class _IO_wide_data extends ffi.Opaque {}

typedef J12SAMPARRAY = ffi.Pointer<J12SAMPROW>;
typedef J12SAMPROW = ffi.Pointer<J12SAMPLE>;

/// J12SAMPLE should be the smallest type that will hold the values 0..4095.
typedef J12SAMPLE = ffi.Short;
typedef DartJ12SAMPLE = int;
typedef J16SAMPARRAY = ffi.Pointer<J16SAMPROW>;
typedef J16SAMPROW = ffi.Pointer<J16SAMPLE>;

/// J16SAMPLE should be the smallest type that will hold the values 0..65535.
typedef J16SAMPLE = ffi.UnsignedShort;
typedef DartJ16SAMPLE = int;
typedef JSAMPIMAGE = ffi.Pointer<JSAMPARRAY>;
typedef J12SAMPIMAGE = ffi.Pointer<J12SAMPARRAY>;

/// Routine signature for application-supplied marker processing methods.
/// Need not pass marker code since it is stored in cinfo->unread_marker.
typedef jpeg_marker_parser_method
    = ffi.Pointer<ffi.NativeFunction<jpeg_marker_parser_methodFunction>>;
typedef jpeg_marker_parser_methodFunction = boolean Function(
    j_decompress_ptr cinfo);
typedef Dartjpeg_marker_parser_methodFunction = Dartboolean Function(
    j_decompress_ptr cinfo);

enum J_MESSAGE_CODE {
  JMSG_NOMESSAGE(0),
  JERR_ARITH_NOTIMPL(1),
  JERR_BAD_ALIGN_TYPE(2),
  JERR_BAD_ALLOC_CHUNK(3),
  JERR_BAD_BUFFER_MODE(4),
  JERR_BAD_COMPONENT_ID(5),
  JERR_BAD_DCT_COEF(6),
  JERR_BAD_DCTSIZE(7),
  JERR_BAD_HUFF_TABLE(8),
  JERR_BAD_IN_COLORSPACE(9),
  JERR_BAD_J_COLORSPACE(10),
  JERR_BAD_LENGTH(11),
  JERR_BAD_LIB_VERSION(12),
  JERR_BAD_MCU_SIZE(13),
  JERR_BAD_POOL_ID(14),
  JERR_BAD_PRECISION(15),
  JERR_BAD_PROGRESSION(16),
  JERR_BAD_PROG_SCRIPT(17),
  JERR_BAD_SAMPLING(18),
  JERR_BAD_SCAN_SCRIPT(19),
  JERR_BAD_STATE(20),
  JERR_BAD_STRUCT_SIZE(21),
  JERR_BAD_VIRTUAL_ACCESS(22),
  JERR_BUFFER_SIZE(23),
  JERR_CANT_SUSPEND(24),
  JERR_CCIR601_NOTIMPL(25),
  JERR_COMPONENT_COUNT(26),
  JERR_CONVERSION_NOTIMPL(27),
  JERR_DAC_INDEX(28),
  JERR_DAC_VALUE(29),
  JERR_DHT_INDEX(30),
  JERR_DQT_INDEX(31),
  JERR_EMPTY_IMAGE(32),
  JERR_EMS_READ(33),
  JERR_EMS_WRITE(34),
  JERR_EOI_EXPECTED(35),
  JERR_FILE_READ(36),
  JERR_FILE_WRITE(37),
  JERR_FRACT_SAMPLE_NOTIMPL(38),
  JERR_HUFF_CLEN_OVERFLOW(39),
  JERR_HUFF_MISSING_CODE(40),
  JERR_IMAGE_TOO_BIG(41),
  JERR_INPUT_EMPTY(42),
  JERR_INPUT_EOF(43),
  JERR_MISMATCHED_QUANT_TABLE(44),
  JERR_MISSING_DATA(45),
  JERR_MODE_CHANGE(46),
  JERR_NOTIMPL(47),
  JERR_NOT_COMPILED(48),
  JERR_NO_BACKING_STORE(49),
  JERR_NO_HUFF_TABLE(50),
  JERR_NO_IMAGE(51),
  JERR_NO_QUANT_TABLE(52),
  JERR_NO_SOI(53),
  JERR_OUT_OF_MEMORY(54),
  JERR_QUANT_COMPONENTS(55),
  JERR_QUANT_FEW_COLORS(56),
  JERR_QUANT_MANY_COLORS(57),
  JERR_SOF_DUPLICATE(58),
  JERR_SOF_NO_SOS(59),
  JERR_SOF_UNSUPPORTED(60),
  JERR_SOI_DUPLICATE(61),
  JERR_SOS_NO_SOF(62),
  JERR_TFILE_CREATE(63),
  JERR_TFILE_READ(64),
  JERR_TFILE_SEEK(65),
  JERR_TFILE_WRITE(66),
  JERR_TOO_LITTLE_DATA(67),
  JERR_UNKNOWN_MARKER(68),
  JERR_VIRTUAL_BUG(69),
  JERR_WIDTH_OVERFLOW(70),
  JERR_XMS_READ(71),
  JERR_XMS_WRITE(72),
  JMSG_COPYRIGHT(73),
  JMSG_VERSION(74),
  JTRC_16BIT_TABLES(75),
  JTRC_ADOBE(76),
  JTRC_APP0(77),
  JTRC_APP14(78),
  JTRC_DAC(79),
  JTRC_DHT(80),
  JTRC_DQT(81),
  JTRC_DRI(82),
  JTRC_EMS_CLOSE(83),
  JTRC_EMS_OPEN(84),
  JTRC_EOI(85),
  JTRC_HUFFBITS(86),
  JTRC_JFIF(87),
  JTRC_JFIF_BADTHUMBNAILSIZE(88),
  JTRC_JFIF_EXTENSION(89),
  JTRC_JFIF_THUMBNAIL(90),
  JTRC_MISC_MARKER(91),
  JTRC_PARMLESS_MARKER(92),
  JTRC_QUANTVALS(93),
  JTRC_QUANT_3_NCOLORS(94),
  JTRC_QUANT_NCOLORS(95),
  JTRC_QUANT_SELECTED(96),
  JTRC_RECOVERY_ACTION(97),
  JTRC_RST(98),
  JTRC_SMOOTH_NOTIMPL(99),
  JTRC_SOF(100),
  JTRC_SOF_COMPONENT(101),
  JTRC_SOI(102),
  JTRC_SOS(103),
  JTRC_SOS_COMPONENT(104),
  JTRC_SOS_PARAMS(105),
  JTRC_TFILE_CLOSE(106),
  JTRC_TFILE_OPEN(107),
  JTRC_THUMB_JPEG(108),
  JTRC_THUMB_PALETTE(109),
  JTRC_THUMB_RGB(110),
  JTRC_UNKNOWN_IDS(111),
  JTRC_XMS_CLOSE(112),
  JTRC_XMS_OPEN(113),
  JWRN_ADOBE_XFORM(114),
  JWRN_BOGUS_PROGRESSION(115),
  JWRN_EXTRANEOUS_DATA(116),
  JWRN_HIT_MARKER(117),
  JWRN_HUFF_BAD_CODE(118),
  JWRN_JFIF_MAJOR(119),
  JWRN_JPEG_EOF(120),
  JWRN_MUST_RESYNC(121),
  JWRN_NOT_SEQUENTIAL(122),
  JWRN_TOO_MUCH_DATA(123),
  JERR_BAD_CROP_SPEC(124),
  JWRN_BOGUS_ICC(125),
  JERR_BAD_DROP_SAMPLING(126),
  JERR_BAD_RESTART(127),
  JMSG_LASTMSGCODE(128);

  final int value;
  const J_MESSAGE_CODE(this.value);

  static J_MESSAGE_CODE fromValue(int value) => switch (value) {
        0 => JMSG_NOMESSAGE,
        1 => JERR_ARITH_NOTIMPL,
        2 => JERR_BAD_ALIGN_TYPE,
        3 => JERR_BAD_ALLOC_CHUNK,
        4 => JERR_BAD_BUFFER_MODE,
        5 => JERR_BAD_COMPONENT_ID,
        6 => JERR_BAD_DCT_COEF,
        7 => JERR_BAD_DCTSIZE,
        8 => JERR_BAD_HUFF_TABLE,
        9 => JERR_BAD_IN_COLORSPACE,
        10 => JERR_BAD_J_COLORSPACE,
        11 => JERR_BAD_LENGTH,
        12 => JERR_BAD_LIB_VERSION,
        13 => JERR_BAD_MCU_SIZE,
        14 => JERR_BAD_POOL_ID,
        15 => JERR_BAD_PRECISION,
        16 => JERR_BAD_PROGRESSION,
        17 => JERR_BAD_PROG_SCRIPT,
        18 => JERR_BAD_SAMPLING,
        19 => JERR_BAD_SCAN_SCRIPT,
        20 => JERR_BAD_STATE,
        21 => JERR_BAD_STRUCT_SIZE,
        22 => JERR_BAD_VIRTUAL_ACCESS,
        23 => JERR_BUFFER_SIZE,
        24 => JERR_CANT_SUSPEND,
        25 => JERR_CCIR601_NOTIMPL,
        26 => JERR_COMPONENT_COUNT,
        27 => JERR_CONVERSION_NOTIMPL,
        28 => JERR_DAC_INDEX,
        29 => JERR_DAC_VALUE,
        30 => JERR_DHT_INDEX,
        31 => JERR_DQT_INDEX,
        32 => JERR_EMPTY_IMAGE,
        33 => JERR_EMS_READ,
        34 => JERR_EMS_WRITE,
        35 => JERR_EOI_EXPECTED,
        36 => JERR_FILE_READ,
        37 => JERR_FILE_WRITE,
        38 => JERR_FRACT_SAMPLE_NOTIMPL,
        39 => JERR_HUFF_CLEN_OVERFLOW,
        40 => JERR_HUFF_MISSING_CODE,
        41 => JERR_IMAGE_TOO_BIG,
        42 => JERR_INPUT_EMPTY,
        43 => JERR_INPUT_EOF,
        44 => JERR_MISMATCHED_QUANT_TABLE,
        45 => JERR_MISSING_DATA,
        46 => JERR_MODE_CHANGE,
        47 => JERR_NOTIMPL,
        48 => JERR_NOT_COMPILED,
        49 => JERR_NO_BACKING_STORE,
        50 => JERR_NO_HUFF_TABLE,
        51 => JERR_NO_IMAGE,
        52 => JERR_NO_QUANT_TABLE,
        53 => JERR_NO_SOI,
        54 => JERR_OUT_OF_MEMORY,
        55 => JERR_QUANT_COMPONENTS,
        56 => JERR_QUANT_FEW_COLORS,
        57 => JERR_QUANT_MANY_COLORS,
        58 => JERR_SOF_DUPLICATE,
        59 => JERR_SOF_NO_SOS,
        60 => JERR_SOF_UNSUPPORTED,
        61 => JERR_SOI_DUPLICATE,
        62 => JERR_SOS_NO_SOF,
        63 => JERR_TFILE_CREATE,
        64 => JERR_TFILE_READ,
        65 => JERR_TFILE_SEEK,
        66 => JERR_TFILE_WRITE,
        67 => JERR_TOO_LITTLE_DATA,
        68 => JERR_UNKNOWN_MARKER,
        69 => JERR_VIRTUAL_BUG,
        70 => JERR_WIDTH_OVERFLOW,
        71 => JERR_XMS_READ,
        72 => JERR_XMS_WRITE,
        73 => JMSG_COPYRIGHT,
        74 => JMSG_VERSION,
        75 => JTRC_16BIT_TABLES,
        76 => JTRC_ADOBE,
        77 => JTRC_APP0,
        78 => JTRC_APP14,
        79 => JTRC_DAC,
        80 => JTRC_DHT,
        81 => JTRC_DQT,
        82 => JTRC_DRI,
        83 => JTRC_EMS_CLOSE,
        84 => JTRC_EMS_OPEN,
        85 => JTRC_EOI,
        86 => JTRC_HUFFBITS,
        87 => JTRC_JFIF,
        88 => JTRC_JFIF_BADTHUMBNAILSIZE,
        89 => JTRC_JFIF_EXTENSION,
        90 => JTRC_JFIF_THUMBNAIL,
        91 => JTRC_MISC_MARKER,
        92 => JTRC_PARMLESS_MARKER,
        93 => JTRC_QUANTVALS,
        94 => JTRC_QUANT_3_NCOLORS,
        95 => JTRC_QUANT_NCOLORS,
        96 => JTRC_QUANT_SELECTED,
        97 => JTRC_RECOVERY_ACTION,
        98 => JTRC_RST,
        99 => JTRC_SMOOTH_NOTIMPL,
        100 => JTRC_SOF,
        101 => JTRC_SOF_COMPONENT,
        102 => JTRC_SOI,
        103 => JTRC_SOS,
        104 => JTRC_SOS_COMPONENT,
        105 => JTRC_SOS_PARAMS,
        106 => JTRC_TFILE_CLOSE,
        107 => JTRC_TFILE_OPEN,
        108 => JTRC_THUMB_JPEG,
        109 => JTRC_THUMB_PALETTE,
        110 => JTRC_THUMB_RGB,
        111 => JTRC_UNKNOWN_IDS,
        112 => JTRC_XMS_CLOSE,
        113 => JTRC_XMS_OPEN,
        114 => JWRN_ADOBE_XFORM,
        115 => JWRN_BOGUS_PROGRESSION,
        116 => JWRN_EXTRANEOUS_DATA,
        117 => JWRN_HIT_MARKER,
        118 => JWRN_HUFF_BAD_CODE,
        119 => JWRN_JFIF_MAJOR,
        120 => JWRN_JPEG_EOF,
        121 => JWRN_MUST_RESYNC,
        122 => JWRN_NOT_SEQUENTIAL,
        123 => JWRN_TOO_MUCH_DATA,
        124 => JERR_BAD_CROP_SPEC,
        125 => JWRN_BOGUS_ICC,
        126 => JERR_BAD_DROP_SAMPLING,
        127 => JERR_BAD_RESTART,
        128 => JMSG_LASTMSGCODE,
        _ => throw ArgumentError("Unknown value for J_MESSAGE_CODE: $value"),
      };
}

/// Initialization options.
enum TJINIT {
  /// Initialize the TurboJPEG instance for compression.
  TJINIT_COMPRESS(0),

  /// Initialize the TurboJPEG instance for decompression.
  TJINIT_DECOMPRESS(1),

  /// Initialize the TurboJPEG instance for lossless transformation (both
  /// compression and decompression.)
  TJINIT_TRANSFORM(2);

  final int value;
  const TJINIT(this.value);

  static TJINIT fromValue(int value) => switch (value) {
        0 => TJINIT_COMPRESS,
        1 => TJINIT_DECOMPRESS,
        2 => TJINIT_TRANSFORM,
        _ => throw ArgumentError("Unknown value for TJINIT: $value"),
      };
}

/// Chrominance subsampling options.
/// When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK
/// to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of
/// the Cb and Cr (chrominance) components can be discarded or averaged together
/// to produce a smaller image with little perceptible loss of image clarity.
/// (The human eye is more sensitive to small changes in brightness than to
/// small changes in color.)  This is called "chrominance subsampling".
enum TJSAMP {
  /// 4:4:4 chrominance subsampling (no chrominance subsampling).  The JPEG or
  /// YUV image will contain one chrominance component for every pixel in the
  /// source image.
  TJSAMP_444(0),

  /// 4:2:2 chrominance subsampling.  The JPEG or YUV image will contain one
  /// chrominance component for every 2x1 block of pixels in the source image.
  TJSAMP_422(1),

  /// 4:2:0 chrominance subsampling.  The JPEG or YUV image will contain one
  /// chrominance component for every 2x2 block of pixels in the source image.
  TJSAMP_420(2),

  /// Grayscale.  The JPEG or YUV image will contain no chrominance components.
  TJSAMP_GRAY(3),

  /// 4:4:0 chrominance subsampling.  The JPEG or YUV image will contain one
  /// chrominance component for every 1x2 block of pixels in the source image.
  ///
  /// @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo.
  TJSAMP_440(4),

  /// 4:1:1 chrominance subsampling.  The JPEG or YUV image will contain one
  /// chrominance component for every 4x1 block of pixels in the source image.
  /// JPEG images compressed with 4:1:1 subsampling will be almost exactly the
  /// same size as those compressed with 4:2:0 subsampling, and in the
  /// aggregate, both subsampling methods produce approximately the same
  /// perceptual quality.  However, 4:1:1 is better able to reproduce sharp
  /// horizontal features.
  ///
  /// @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo.
  TJSAMP_411(5),

  /// 4:4:1 chrominance subsampling.  The JPEG or YUV image will contain one
  /// chrominance component for every 1x4 block of pixels in the source image.
  /// JPEG images compressed with 4:4:1 subsampling will be almost exactly the
  /// same size as those compressed with 4:2:0 subsampling, and in the
  /// aggregate, both subsampling methods produce approximately the same
  /// perceptual quality.  However, 4:4:1 is better able to reproduce sharp
  /// vertical features.
  ///
  /// @note 4:4:1 subsampling is not fully accelerated in libjpeg-turbo.
  TJSAMP_441(6),

  /// Unknown subsampling.  The JPEG image uses an unusual type of chrominance
  /// subsampling.  Such images can be decompressed into packed-pixel images,
  /// but they cannot be
  /// - decompressed into planar YUV images,
  /// - losslessly transformed if #TJXOPT_CROP is specified, or
  /// - partially decompressed using a cropping region.
  TJSAMP_UNKNOWN(-1);

  final int value;
  const TJSAMP(this.value);

  static TJSAMP fromValue(int value) => switch (value) {
        0 => TJSAMP_444,
        1 => TJSAMP_422,
        2 => TJSAMP_420,
        3 => TJSAMP_GRAY,
        4 => TJSAMP_440,
        5 => TJSAMP_411,
        6 => TJSAMP_441,
        -1 => TJSAMP_UNKNOWN,
        _ => throw ArgumentError("Unknown value for TJSAMP: $value"),
      };
}

/// Pixel formats
enum TJPF {
  /// RGB pixel format.  The red, green, and blue components in the image are
  /// stored in 3-sample pixels in the order R, G, B from lowest to highest
  /// memory address within each pixel.
  TJPF_RGB(0),

  /// BGR pixel format.  The red, green, and blue components in the image are
  /// stored in 3-sample pixels in the order B, G, R from lowest to highest
  /// memory address within each pixel.
  TJPF_BGR(1),

  /// RGBX pixel format.  The red, green, and blue components in the image are
  /// stored in 4-sample pixels in the order R, G, B from lowest to highest
  /// memory address within each pixel.  The X component is ignored when
  /// compressing and undefined when decompressing.
  TJPF_RGBX(2),

  /// BGRX pixel format.  The red, green, and blue components in the image are
  /// stored in 4-sample pixels in the order B, G, R from lowest to highest
  /// memory address within each pixel.  The X component is ignored when
  /// compressing and undefined when decompressing.
  TJPF_BGRX(3),

  /// XBGR pixel format.  The red, green, and blue components in the image are
  /// stored in 4-sample pixels in the order R, G, B from highest to lowest
  /// memory address within each pixel.  The X component is ignored when
  /// compressing and undefined when decompressing.
  TJPF_XBGR(4),

  /// XRGB pixel format.  The red, green, and blue components in the image are
  /// stored in 4-sample pixels in the order B, G, R from highest to lowest
  /// memory address within each pixel.  The X component is ignored when
  /// compressing and undefined when decompressing.
  TJPF_XRGB(5),

  /// Grayscale pixel format.  Each 1-sample pixel represents a luminance
  /// (brightness) level from 0 to the maximum sample value (255 for 8-bit
  /// samples, 4095 for 12-bit samples, and 65535 for 16-bit samples.)
  TJPF_GRAY(6),

  /// RGBA pixel format.  This is the same as @ref TJPF_RGBX, except that when
  /// decompressing, the X component is guaranteed to be equal to the maximum
  /// sample value, which can be interpreted as an opaque alpha channel.
  TJPF_RGBA(7),

  /// BGRA pixel format.  This is the same as @ref TJPF_BGRX, except that when
  /// decompressing, the X component is guaranteed to be equal to the maximum
  /// sample value, which can be interpreted as an opaque alpha channel.
  TJPF_BGRA(8),

  /// ABGR pixel format.  This is the same as @ref TJPF_XBGR, except that when
  /// decompressing, the X component is guaranteed to be equal to the maximum
  /// sample value, which can be interpreted as an opaque alpha channel.
  TJPF_ABGR(9),

  /// ARGB pixel format.  This is the same as @ref TJPF_XRGB, except that when
  /// decompressing, the X component is guaranteed to be equal to the maximum
  /// sample value, which can be interpreted as an opaque alpha channel.
  TJPF_ARGB(10),

  /// CMYK pixel format.  Unlike RGB, which is an additive color model used
  /// primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive
  /// color model used primarily for printing.  In the CMYK color model, the
  /// value of each color component typically corresponds to an amount of cyan,
  /// magenta, yellow, or black ink that is applied to a white background.  In
  /// order to convert between CMYK and RGB, it is necessary to use a color
  /// management system (CMS.)  A CMS will attempt to map colors within the
  /// printer's gamut to perceptually similar colors in the display's gamut and
  /// vice versa, but the mapping is typically not 1:1 or reversible, nor can it
  /// be defined with a simple formula.  Thus, such a conversion is out of scope
  /// for a codec library.  However, the TurboJPEG API allows for compressing
  /// packed-pixel CMYK images into YCCK JPEG images (see #TJCS_YCCK) and
  /// decompressing YCCK JPEG images into packed-pixel CMYK images.
  TJPF_CMYK(11),

  /// Unknown pixel format.  Currently this is only used by #tj3LoadImage8(),
  /// #tj3LoadImage12(), and #tj3LoadImage16().
  TJPF_UNKNOWN(-1);

  final int value;
  const TJPF(this.value);

  static TJPF fromValue(int value) => switch (value) {
        0 => TJPF_RGB,
        1 => TJPF_BGR,
        2 => TJPF_RGBX,
        3 => TJPF_BGRX,
        4 => TJPF_XBGR,
        5 => TJPF_XRGB,
        6 => TJPF_GRAY,
        7 => TJPF_RGBA,
        8 => TJPF_BGRA,
        9 => TJPF_ABGR,
        10 => TJPF_ARGB,
        11 => TJPF_CMYK,
        -1 => TJPF_UNKNOWN,
        _ => throw ArgumentError("Unknown value for TJPF: $value"),
      };
}

/// JPEG colorspaces
enum TJCS {
  /// RGB colorspace.  When compressing the JPEG image, the R, G, and B
  /// components in the source image are reordered into image planes, but no
  /// colorspace conversion or subsampling is performed.  RGB JPEG images can be
  /// compressed from and decompressed to packed-pixel images with any of the
  /// extended RGB or grayscale pixel formats, but they cannot be compressed
  /// from or decompressed to planar YUV images.
  TJCS_RGB(0),

  /// YCbCr colorspace.  YCbCr is not an absolute colorspace but rather a
  /// mathematical transformation of RGB designed solely for storage and
  /// transmission.  YCbCr images must be converted to RGB before they can
  /// actually be displayed.  In the YCbCr colorspace, the Y (luminance)
  /// component represents the black & white portion of the original image, and
  /// the Cb and Cr (chrominance) components represent the color portion of the
  /// original image.  Originally, the analog equivalent of this transformation
  /// allowed the same signal to drive both black & white and color televisions,
  /// but JPEG images use YCbCr primarily because it allows the color data to be
  /// optionally subsampled for the purposes of reducing network or disk usage.
  /// YCbCr is the most common JPEG colorspace, and YCbCr JPEG images can be
  /// compressed from and decompressed to packed-pixel images with any of the
  /// extended RGB or grayscale pixel formats.  YCbCr JPEG images can also be
  /// compressed from and decompressed to planar YUV images.
  TJCS_YCbCr(1),

  /// Grayscale colorspace.  The JPEG image retains only the luminance data (Y
  /// component), and any color data from the source image is discarded.
  /// Grayscale JPEG images can be compressed from and decompressed to
  /// packed-pixel images with any of the extended RGB or grayscale pixel
  /// formats, or they can be compressed from and decompressed to planar YUV
  /// images.
  TJCS_GRAY(2),

  /// CMYK colorspace.  When compressing the JPEG image, the C, M, Y, and K
  /// components in the source image are reordered into image planes, but no
  /// colorspace conversion or subsampling is performed.  CMYK JPEG images can
  /// only be compressed from and decompressed to packed-pixel images with the
  /// CMYK pixel format.
  TJCS_CMYK(3),

  /// YCCK colorspace.  YCCK (AKA "YCbCrK") is not an absolute colorspace but
  /// rather a mathematical transformation of CMYK designed solely for storage
  /// and transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be
  /// reversibly transformed into YCCK, and as with YCbCr, the chrominance
  /// components in the YCCK pixels can be subsampled without incurring major
  /// perceptual loss.  YCCK JPEG images can only be compressed from and
  /// decompressed to packed-pixel images with the CMYK pixel format.
  TJCS_YCCK(4);

  final int value;
  const TJCS(this.value);

  static TJCS fromValue(int value) => switch (value) {
        0 => TJCS_RGB,
        1 => TJCS_YCbCr,
        2 => TJCS_GRAY,
        3 => TJCS_CMYK,
        4 => TJCS_YCCK,
        _ => throw ArgumentError("Unknown value for TJCS: $value"),
      };
}

/// Parameters
enum TJPARAM {
  /// Error handling behavior
  ///
  /// **Value**
  /// - `0` *[default]* Allow the current compression/decompression/transform
  /// operation to complete unless a fatal error is encountered.
  /// - `1` Immediately discontinue the current
  /// compression/decompression/transform operation if a warning (non-fatal
  /// error) occurs.
  TJPARAM_STOPONWARNING(0),

  /// Row order in packed-pixel source/destination images
  ///
  /// **Value**
  /// - `0` *[default]* top-down (X11) order
  /// - `1` bottom-up (Windows, OpenGL) order
  TJPARAM_BOTTOMUP(1),

  /// JPEG destination buffer (re)allocation [compression, lossless
  /// transformation]
  ///
  /// **Value**
  /// - `0` *[default]* Attempt to allocate or reallocate the JPEG destination
  /// buffer as needed.
  /// - `1` Generate an error if the JPEG destination buffer is invalid or too
  /// small.
  TJPARAM_NOREALLOC(2),

  /// Perceptual quality of lossy JPEG images [compression only]
  ///
  /// **Value**
  /// - `1`-`100` (`1` = worst quality but best compression, `100` = best
  /// quality but worst compression) *[no default; must be explicitly
  /// specified]*
  TJPARAM_QUALITY(3),

  /// Chrominance subsampling level
  ///
  /// The JPEG or YUV image uses (decompression, decoding) or will use (lossy
  /// compression, encoding) the specified level of chrominance subsampling.
  ///
  /// **Value**
  /// - One of the @ref TJSAMP "chrominance subsampling options" *[no default;
  /// must be explicitly specified for lossy compression, encoding, and
  /// decoding]*
  TJPARAM_SUBSAMP(4),

  /// JPEG width (in pixels) [decompression only, read-only]
  TJPARAM_JPEGWIDTH(5),

  /// JPEG height (in pixels) [decompression only, read-only]
  TJPARAM_JPEGHEIGHT(6),

  /// JPEG data precision (bits per sample) [decompression only, read-only]
  ///
  /// The JPEG image uses the specified number of bits per sample.
  ///
  /// **Value**
  /// - `8`, `12`, or `16`
  ///
  /// 12-bit data precision implies #TJPARAM_OPTIMIZE unless #TJPARAM_ARITHMETIC
  /// is set.
  TJPARAM_PRECISION(7),

  /// JPEG colorspace
  ///
  /// The JPEG image uses (decompression) or will use (lossy compression) the
  /// specified colorspace.
  ///
  /// **Value**
  /// - One of the @ref TJCS "JPEG colorspaces" *[default for lossy compression:
  /// automatically selected based on the subsampling level and pixel format]*
  TJPARAM_COLORSPACE(8),

  /// Chrominance upsampling algorithm [lossy decompression only]
  ///
  /// **Value**
  /// - `0` *[default]* Use smooth upsampling when decompressing a JPEG image
  /// that was compressed using chrominance subsampling.  This creates a smooth
  /// transition between neighboring chrominance components in order to reduce
  /// upsampling artifacts in the decompressed image.
  /// - `1` Use the fastest chrominance upsampling algorithm available, which
  /// may combine upsampling with color conversion.
  TJPARAM_FASTUPSAMPLE(9),

  /// DCT/IDCT algorithm [lossy compression and decompression]
  ///
  /// **Value**
  /// - `0` *[default]* Use the most accurate DCT/IDCT algorithm available.
  /// - `1` Use the fastest DCT/IDCT algorithm available.
  ///
  /// This parameter is provided mainly for backward compatibility with libjpeg,
  /// which historically implemented several different DCT/IDCT algorithms
  /// because of performance limitations with 1990s CPUs.  In the libjpeg-turbo
  /// implementation of the TurboJPEG API:
  /// - The "fast" and "accurate" DCT/IDCT algorithms perform similarly on
  /// modern x86/x86-64 CPUs that support AVX2 instructions.
  /// - The "fast" algorithm is generally only about 5-15% faster than the
  /// "accurate" algorithm on other types of CPUs.
  /// - The difference in accuracy between the "fast" and "accurate" algorithms
  /// is the most pronounced at JPEG quality levels above 90 and tends to be
  /// more pronounced with decompression than with compression.
  /// - The "fast" algorithm degrades and is not fully accelerated for JPEG
  /// quality levels above 97, so it will be slower than the "accurate"
  /// algorithm.
  TJPARAM_FASTDCT(10),

  /// Optimized baseline entropy coding [lossy compression only]
  ///
  /// **Value**
  /// - `0` *[default]* The JPEG image will use the default Huffman tables.
  /// - `1` Optimal Huffman tables will be computed for the JPEG image.  For
  /// lossless transformation, this can also be specified using
  /// #TJXOPT_OPTIMIZE.
  ///
  /// Optimized baseline entropy coding will improve compression slightly
  /// (generally 5% or less), but it will reduce compression performance
  /// considerably.
  TJPARAM_OPTIMIZE(11),

  /// Progressive entropy coding
  ///
  /// **Value**
  /// - `0` *[default for compression, lossless transformation]* The lossy JPEG
  /// image uses (decompression) or will use (compression, lossless
  /// transformation) baseline entropy coding.
  /// - `1` The lossy JPEG image uses (decompression) or will use (compression,
  /// lossless transformation) progressive entropy coding.  For lossless
  /// transformation, this can also be specified using #TJXOPT_PROGRESSIVE.
  ///
  /// Progressive entropy coding will generally improve compression relative to
  /// baseline entropy coding, but it will reduce compression and decompression
  /// performance considerably.  Can be combined with #TJPARAM_ARITHMETIC.
  /// Implies #TJPARAM_OPTIMIZE unless #TJPARAM_ARITHMETIC is also set.
  TJPARAM_PROGRESSIVE(12),

  /// Progressive JPEG scan limit for lossy JPEG images [decompression, lossless
  /// transformation]
  ///
  /// Setting this parameter will cause the decompression and transform
  /// functions to return an error if the number of scans in a progressive JPEG
  /// image exceeds the specified limit.  The primary purpose of this is to
  /// allow security-critical applications to guard against an exploit of the
  /// progressive JPEG format described in
  /// <a href="https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf" target="_blank">this report</a>.
  ///
  /// **Value**
  /// - maximum number of progressive JPEG scans that the decompression and
  /// transform functions will process *[default: `0` (no limit)]*
  ///
  /// @see #TJPARAM_PROGRESSIVE
  TJPARAM_SCANLIMIT(13),

  /// Arithmetic entropy coding
  ///
  /// **Value**
  /// - `0` *[default for compression, lossless transformation]* The lossy JPEG
  /// image uses (decompression) or will use (compression, lossless
  /// transformation) Huffman entropy coding.
  /// - `1` The lossy JPEG image uses (decompression) or will use (compression,
  /// lossless transformation) arithmetic entropy coding.  For lossless
  /// transformation, this can also be specified using #TJXOPT_ARITHMETIC.
  ///
  /// Arithmetic entropy coding will generally improve compression relative to
  /// Huffman entropy coding, but it will reduce compression and decompression
  /// performance considerably.  Can be combined with #TJPARAM_PROGRESSIVE.
  TJPARAM_ARITHMETIC(14),

  /// Lossless JPEG
  ///
  /// **Value**
  /// - `0` *[default for compression]* The JPEG image is (decompression) or
  /// will be (compression) lossy/DCT-based.
  /// - `1` The JPEG image is (decompression) or will be (compression)
  /// lossless/predictive.
  ///
  /// In most cases, compressing and decompressing lossless JPEG images is
  /// considerably slower than compressing and decompressing lossy JPEG images,
  /// and lossless JPEG images are much larger than lossy JPEG images.  Thus,
  /// lossless JPEG images are typically used only for applications that require
  /// mathematically lossless compression.  Also note that the following
  /// features are not available with lossless JPEG images:
  /// - Colorspace conversion (lossless JPEG images always use #TJCS_RGB,
  /// #TJCS_GRAY, or #TJCS_CMYK, depending on the pixel format of the source
  /// image)
  /// - Chrominance subsampling (lossless JPEG images always use #TJSAMP_444)
  /// - JPEG quality selection
  /// - DCT/IDCT algorithm selection
  /// - Progressive entropy coding
  /// - Arithmetic entropy coding
  /// - Compression from/decompression to planar YUV images
  /// - Decompression scaling
  /// - Lossless transformation
  ///
  /// @see #TJPARAM_LOSSLESSPSV, #TJPARAM_LOSSLESSPT
  TJPARAM_LOSSLESS(15),

  /// Lossless JPEG predictor selection value (PSV)
  ///
  /// **Value**
  /// - `1`-`7` *[default for compression: `1`]*
  ///
  /// Lossless JPEG compression shares no algorithms with lossy JPEG
  /// compression.  Instead, it uses differential pulse-code modulation (DPCM),
  /// an algorithm whereby each sample is encoded as the difference between the
  /// sample's value and a "predictor", which is based on the values of
  /// neighboring samples.  If Ra is the sample immediately to the left of the
  /// current sample, Rb is the sample immediately above the current sample, and
  /// Rc is the sample diagonally to the left and above the current sample, then
  /// the relationship between the predictor selection value and the predictor
  /// is as follows:
  ///
  /// PSV | Predictor
  /// ----|----------
  /// 1   | Ra
  /// 2   | Rb
  /// 3   | Rc
  /// 4   | Ra + Rb – Rc
  /// 5   | Ra + (Rb – Rc) / 2
  /// 6   | Rb + (Ra – Rc) / 2
  /// 7   | (Ra + Rb) / 2
  ///
  /// Predictors 1-3 are 1-dimensional predictors, whereas Predictors 4-7 are
  /// 2-dimensional predictors.  The best predictor for a particular image
  /// depends on the image.
  ///
  /// @see #TJPARAM_LOSSLESS
  TJPARAM_LOSSLESSPSV(16),

  /// Lossless JPEG point transform (Pt)
  ///
  /// **Value**
  /// - `0` through ***precision*** *- 1*, where ***precision*** is the JPEG
  /// data precision in bits *[default for compression: `0`]*
  ///
  /// A point transform value of `0` is necessary in order to generate a fully
  /// lossless JPEG image.  (A non-zero point transform value right-shifts the
  /// input samples by the specified number of bits, which is effectively a form
  /// of lossy color quantization.)
  ///
  /// @see #TJPARAM_LOSSLESS, #TJPARAM_PRECISION
  TJPARAM_LOSSLESSPT(17),

  /// JPEG restart marker interval in MCU blocks (lossy) or samples (lossless)
  /// [compression only]
  ///
  /// The nature of entropy coding is such that a corrupt JPEG image cannot
  /// be decompressed beyond the point of corruption unless it contains restart
  /// markers.  A restart marker stops and restarts the entropy coding algorithm
  /// so that, if a JPEG image is corrupted, decompression can resume at the
  /// next marker.  Thus, adding more restart markers improves the fault
  /// tolerance of the JPEG image, but adding too many restart markers can
  /// adversely affect the compression ratio and performance.
  ///
  /// **Value**
  /// - the number of MCU blocks or samples between each restart marker
  /// *[default: `0` (no restart markers)]*
  ///
  /// Setting this parameter to a non-zero value sets #TJPARAM_RESTARTROWS to 0.
  TJPARAM_RESTARTBLOCKS(18),

  /// JPEG restart marker interval in MCU rows (lossy) or sample rows (lossless)
  /// [compression only]
  ///
  /// See #TJPARAM_RESTARTBLOCKS for a description of restart markers.
  ///
  /// **Value**
  /// - the number of MCU rows or sample rows between each restart marker
  /// *[default: `0` (no restart markers)]*
  ///
  /// Setting this parameter to a non-zero value sets #TJPARAM_RESTARTBLOCKS to
  /// 0.
  TJPARAM_RESTARTROWS(19),

  /// JPEG horizontal pixel density
  ///
  /// **Value**
  /// - The JPEG image has (decompression) or will have (compression) the
  /// specified horizontal pixel density *[default for compression: `1`]*.
  ///
  /// This value is stored in or read from the JPEG header.  It does not affect
  /// the contents of the JPEG image.  Note that this parameter is set by
  /// #tj3LoadImage8() when loading a Windows BMP file that contains pixel
  /// density information, and the value of this parameter is stored to a
  /// Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNITS
  /// is `2`.
  ///
  /// @see TJPARAM_DENSITYUNITS
  TJPARAM_XDENSITY(20),

  /// JPEG vertical pixel density
  ///
  /// **Value**
  /// - The JPEG image has (decompression) or will have (compression) the
  /// specified vertical pixel density *[default for compression: `1`]*.
  ///
  /// This value is stored in or read from the JPEG header.  It does not affect
  /// the contents of the JPEG image.  Note that this parameter is set by
  /// #tj3LoadImage8() when loading a Windows BMP file that contains pixel
  /// density information, and the value of this parameter is stored to a
  /// Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNITS
  /// is `2`.
  ///
  /// @see TJPARAM_DENSITYUNITS
  TJPARAM_YDENSITY(21),

  /// JPEG pixel density units
  ///
  /// **Value**
  /// - `0` *[default for compression]* The pixel density of the JPEG image is
  /// expressed (decompression) or will be expressed (compression) in unknown
  /// units.
  /// - `1` The pixel density of the JPEG image is expressed (decompression) or
  /// will be expressed (compression) in units of pixels/inch.
  /// - `2` The pixel density of the JPEG image is expressed (decompression) or
  /// will be expressed (compression) in units of pixels/cm.
  ///
  /// This value is stored in or read from the JPEG header.  It does not affect
  /// the contents of the JPEG image.  Note that this parameter is set by
  /// #tj3LoadImage8() when loading a Windows BMP file that contains pixel
  /// density information, and the value of this parameter is stored to a
  /// Windows BMP file by #tj3SaveImage8() if the value is `2`.
  ///
  /// @see TJPARAM_XDENSITY, TJPARAM_YDENSITY
  TJPARAM_DENSITYUNITS(22),

  /// Memory limit for intermediate buffers
  ///
  /// **Value**
  /// - the maximum amount of memory (in megabytes) that will be allocated for
  /// intermediate buffers, which are used with progressive JPEG compression and
  /// decompression, optimized baseline entropy coding, lossless JPEG
  /// compression, and lossless transformation *[default: `0` (no limit)]*
  TJPARAM_MAXMEMORY(23),

  /// Image size limit [decompression, lossless transformation, packed-pixel
  /// image loading]
  ///
  /// Setting this parameter will cause the decompression, transform, and image
  /// loading functions to return an error if the number of pixels in the source
  /// image exceeds the specified limit.  This allows security-critical
  /// applications to guard against excessive memory consumption.
  ///
  /// **Value**
  /// - maximum number of pixels that the decompression, transform, and image
  /// loading functions will process *[default: `0` (no limit)]*
  TJPARAM_MAXPIXELS(24);

  final int value;
  const TJPARAM(this.value);

  static TJPARAM fromValue(int value) => switch (value) {
        0 => TJPARAM_STOPONWARNING,
        1 => TJPARAM_BOTTOMUP,
        2 => TJPARAM_NOREALLOC,
        3 => TJPARAM_QUALITY,
        4 => TJPARAM_SUBSAMP,
        5 => TJPARAM_JPEGWIDTH,
        6 => TJPARAM_JPEGHEIGHT,
        7 => TJPARAM_PRECISION,
        8 => TJPARAM_COLORSPACE,
        9 => TJPARAM_FASTUPSAMPLE,
        10 => TJPARAM_FASTDCT,
        11 => TJPARAM_OPTIMIZE,
        12 => TJPARAM_PROGRESSIVE,
        13 => TJPARAM_SCANLIMIT,
        14 => TJPARAM_ARITHMETIC,
        15 => TJPARAM_LOSSLESS,
        16 => TJPARAM_LOSSLESSPSV,
        17 => TJPARAM_LOSSLESSPT,
        18 => TJPARAM_RESTARTBLOCKS,
        19 => TJPARAM_RESTARTROWS,
        20 => TJPARAM_XDENSITY,
        21 => TJPARAM_YDENSITY,
        22 => TJPARAM_DENSITYUNITS,
        23 => TJPARAM_MAXMEMORY,
        24 => TJPARAM_MAXPIXELS,
        _ => throw ArgumentError("Unknown value for TJPARAM: $value"),
      };
}

/// Error codes
enum TJERR {
  /// The error was non-fatal and recoverable, but the destination image may
  /// still be corrupt.
  TJERR_WARNING(0),

  /// The error was fatal and non-recoverable.
  TJERR_FATAL(1);

  final int value;
  const TJERR(this.value);

  static TJERR fromValue(int value) => switch (value) {
        0 => TJERR_WARNING,
        1 => TJERR_FATAL,
        _ => throw ArgumentError("Unknown value for TJERR: $value"),
      };
}

/// Transform operations for #tj3Transform()
enum TJXOP {
  /// Do not transform the position of the image pixels
  TJXOP_NONE(0),

  /// Flip (mirror) image horizontally.  This transform is imperfect if there
  /// are any partial MCU blocks on the right edge (see #TJXOPT_PERFECT.)
  TJXOP_HFLIP(1),

  /// Flip (mirror) image vertically.  This transform is imperfect if there are
  /// any partial MCU blocks on the bottom edge (see #TJXOPT_PERFECT.)
  TJXOP_VFLIP(2),

  /// Transpose image (flip/mirror along upper left to lower right axis.)  This
  /// transform is always perfect.
  TJXOP_TRANSPOSE(3),

  /// Transverse transpose image (flip/mirror along upper right to lower left
  /// axis.)  This transform is imperfect if there are any partial MCU blocks in
  /// the image (see #TJXOPT_PERFECT.)
  TJXOP_TRANSVERSE(4),

  /// Rotate image clockwise by 90 degrees.  This transform is imperfect if
  /// there are any partial MCU blocks on the bottom edge (see
  /// #TJXOPT_PERFECT.)
  TJXOP_ROT90(5),

  /// Rotate image 180 degrees.  This transform is imperfect if there are any
  /// partial MCU blocks in the image (see #TJXOPT_PERFECT.)
  TJXOP_ROT180(6),

  /// Rotate image counter-clockwise by 90 degrees.  This transform is imperfect
  /// if there are any partial MCU blocks on the right edge (see
  /// #TJXOPT_PERFECT.)
  TJXOP_ROT270(7);

  final int value;
  const TJXOP(this.value);

  static TJXOP fromValue(int value) => switch (value) {
        0 => TJXOP_NONE,
        1 => TJXOP_HFLIP,
        2 => TJXOP_VFLIP,
        3 => TJXOP_TRANSPOSE,
        4 => TJXOP_TRANSVERSE,
        5 => TJXOP_ROT90,
        6 => TJXOP_ROT180,
        7 => TJXOP_ROT270,
        _ => throw ArgumentError("Unknown value for TJXOP: $value"),
      };
}

/// Scaling factor
final class tjscalingfactor extends ffi.Struct {
  /// Numerator
  @ffi.Int()
  external int num;

  /// Denominator
  @ffi.Int()
  external int denom;
}

/// Cropping region
final class tjregion extends ffi.Struct {
  /// The left boundary of the cropping region.  This must be evenly divisible
  /// by the MCU block width (see #tjMCUWidth.)
  @ffi.Int()
  external int x;

  /// The upper boundary of the cropping region.  For lossless transformation,
  /// this must be evenly divisible by the MCU block height (see #tjMCUHeight.)
  @ffi.Int()
  external int y;

  /// The width of the cropping region.  Setting this to 0 is the equivalent of
  /// setting it to the width of the source JPEG image - x.
  @ffi.Int()
  external int w;

  /// The height of the cropping region.  Setting this to 0 is the equivalent of
  /// setting it to the height of the source JPEG image - y.
  @ffi.Int()
  external int h;
}

/// Lossless transform
final class tjtransform extends ffi.Struct {
  /// Cropping region
  external tjregion r;

  /// One of the @ref TJXOP "transform operations"
  @ffi.Int()
  external int op;

  /// The bitwise OR of one of more of the @ref TJXOPT_ARITHMETIC
  /// "transform options"
  @ffi.Int()
  external int options;

  /// Arbitrary data that can be accessed within the body of the callback
  /// function
  external ffi.Pointer<ffi.Void> data;

  /// A callback function that can be used to modify the DCT coefficients after
  /// they are losslessly transformed but before they are transcoded to a new
  /// JPEG image.  This allows for custom filters or other transformations to be
  /// applied in the frequency domain.
  ///
  /// @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:
  /// this pointer is not guaranteed to be valid once the callback returns, so
  /// applications wishing to hand off the DCT coefficients to another function
  /// or library should make a copy of them within the body of the callback.)
  ///
  /// @param arrayRegion #tjregion structure containing the width and height of
  /// the array pointed to by `coeffs` as well as its offset relative to the
  /// component plane.  TurboJPEG implementations may choose to split each
  /// component plane into multiple DCT coefficient arrays and call the callback
  /// function once for each array.
  ///
  /// @param planeRegion #tjregion structure containing the width and height of
  /// the component plane to which `coeffs` belongs
  ///
  /// @param componentID ID number of the component plane to which `coeffs`
  /// belongs.  (Y, Cb, and Cr have, respectively, ID's of 0, 1, and 2 in
  /// typical JPEG images.)
  ///
  /// @param transformID ID number of the transformed image to which `coeffs`
  /// belongs.  This is the same as the index of the transform in the
  /// `transforms` array that was passed to #tj3Transform().
  ///
  /// @param transform a pointer to a #tjtransform structure that specifies the
  /// parameters and/or cropping region for this transform
  ///
  /// @return 0 if the callback was successful, or -1 if an error occurred.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Short> coeffs,
              tjregion arrayRegion,
              tjregion planeRegion,
              ffi.Int componentID,
              ffi.Int transformID,
              ffi.Pointer<tjtransform> transform)>> customFilter;
}

/// TurboJPEG instance handle
typedef tjhandle = ffi.Pointer<ffi.Void>;

const int JPEG_LIB_VERSION = 62;

const int LIBJPEG_TURBO_VERSION_NUMBER = 3000003;

const int C_ARITH_CODING_SUPPORTED = 1;

const int D_ARITH_CODING_SUPPORTED = 1;

const int MEM_SRCDST_SUPPORTED = 1;

const int BITS_IN_JSAMPLE = 8;

const int MAX_COMPONENTS = 10;

const int MAXJSAMPLE = 255;

const int CENTERJSAMPLE = 128;

const int MAXJ12SAMPLE = 4095;

const int CENTERJ12SAMPLE = 2048;

const int MAXJ16SAMPLE = 65535;

const int CENTERJ16SAMPLE = 32768;

const int JPEG_MAX_DIMENSION = 65500;

const int FALSE = 0;

const int TRUE = 1;

const int DCTSIZE = 8;

const int DCTSIZE2 = 64;

const int NUM_QUANT_TBLS = 4;

const int NUM_HUFF_TBLS = 4;

const int NUM_ARITH_TBLS = 16;

const int MAX_COMPS_IN_SCAN = 4;

const int MAX_SAMP_FACTOR = 4;

const int C_MAX_BLOCKS_IN_MCU = 10;

const int D_MAX_BLOCKS_IN_MCU = 10;

const int JCS_EXTENSIONS = 1;

const int JCS_ALPHA_EXTENSIONS = 1;

const int JDCT_DEFAULT = 0;

const int JDCT_FASTEST = 1;

const int JMSG_LENGTH_MAX = 200;

const int JMSG_STR_PARM_MAX = 80;

const int JPOOL_PERMANENT = 0;

const int JPOOL_IMAGE = 1;

const int JPOOL_NUMPOOLS = 2;

const int JPEG_SUSPENDED = 0;

const int JPEG_HEADER_OK = 1;

const int JPEG_HEADER_TABLES_ONLY = 2;

const int JPEG_REACHED_SOS = 1;

const int JPEG_REACHED_EOI = 2;

const int JPEG_ROW_COMPLETED = 3;

const int JPEG_SCAN_COMPLETED = 4;

const int JPEG_RST0 = 208;

const int JPEG_EOI = 217;

const int JPEG_APP0 = 224;

const int JPEG_COM = 254;

const int TJ_NUMINIT = 3;

const int TJ_NUMSAMP = 7;

const int TJ_NUMPF = 12;

const int TJ_NUMCS = 5;

const int TJ_NUMERR = 2;

const int TJ_NUMXOP = 8;

const int TJXOPT_PERFECT = 1;

const int TJXOPT_TRIM = 2;

const int TJXOPT_CROP = 4;

const int TJXOPT_GRAY = 8;

const int TJXOPT_NOOUTPUT = 16;

const int TJXOPT_PROGRESSIVE = 32;

const int TJXOPT_COPYNONE = 64;

const int TJXOPT_ARITHMETIC = 128;

const int TJXOPT_OPTIMIZE = 256;

const int NUMSUBOPT = 7;

const int TJ_444 = 0;

const int TJ_422 = 1;

const int TJ_420 = 2;

const int TJ_411 = 2;

const int TJ_GRAYSCALE = 3;

const int TJ_BGR = 1;

const int TJ_BOTTOMUP = 2;

const int TJ_FORCEMMX = 8;

const int TJ_FORCESSE = 16;

const int TJ_FORCESSE2 = 32;

const int TJ_ALPHAFIRST = 64;

const int TJ_FORCESSE3 = 128;

const int TJ_FASTUPSAMPLE = 256;

const int TJ_YUV = 512;

const int TJFLAG_BOTTOMUP = 2;

const int TJFLAG_FORCEMMX = 8;

const int TJFLAG_FORCESSE = 16;

const int TJFLAG_FORCESSE2 = 32;

const int TJFLAG_FORCESSE3 = 128;

const int TJFLAG_FASTUPSAMPLE = 256;

const int TJFLAG_NOREALLOC = 1024;

const int TJFLAG_FASTDCT = 2048;

const int TJFLAG_ACCURATEDCT = 4096;

const int TJFLAG_STOPONWARNING = 8192;

const int TJFLAG_PROGRESSIVE = 16384;

const int TJFLAG_LIMITSCANS = 32768;
