// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:ffi' as ffi;
import 'dart:isolate' show ReceivePort;

import 'package:jni/internal_helpers_for_jnigen.dart';
import 'package:jni/jni.dart' as jni;

/// from: `android.view.Display$HdrCapabilities`
class Display_HdrCapabilities extends jni.JObject {
  @override
  late final jni.JObjType<Display_HdrCapabilities> $type = type;

  Display_HdrCapabilities.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class =
      jni.JClass.forName(r'android/view/Display$HdrCapabilities');

  /// The type which includes information such as the signature of this class.
  static const type = $Display_HdrCapabilitiesType();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni.JObjectType());

  /// from: `static public final int HDR_TYPE_DOLBY_VISION`
  static const HDR_TYPE_DOLBY_VISION = 1;

  /// from: `static public final int HDR_TYPE_HDR10`
  static const HDR_TYPE_HDR10 = 2;

  /// from: `static public final int HDR_TYPE_HDR10_PLUS`
  static const HDR_TYPE_HDR10_PLUS = 4;

  /// from: `static public final int HDR_TYPE_HLG`
  static const HDR_TYPE_HLG = 3;

  /// from: `static public final int HDR_TYPE_INVALID`
  static const HDR_TYPE_INVALID = -1;

  /// from: `static public final float INVALID_LUMINANCE`
  static const INVALID_LUMINANCE = -1.0;
  static final _id_getSupportedHdrTypes = _class.instanceMethodId(
    r'getSupportedHdrTypes',
    r'()[I',
  );

  static final _getSupportedHdrTypes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int[] getSupportedHdrTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> getSupportedHdrTypes() {
    return _getSupportedHdrTypes(
            reference.pointer, _id_getSupportedHdrTypes as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_getDesiredMaxLuminance = _class.instanceMethodId(
    r'getDesiredMaxLuminance',
    r'()F',
  );

  static final _getDesiredMaxLuminance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getDesiredMaxLuminance()`
  double getDesiredMaxLuminance() {
    return _getDesiredMaxLuminance(
            reference.pointer, _id_getDesiredMaxLuminance as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getDesiredMaxAverageLuminance = _class.instanceMethodId(
    r'getDesiredMaxAverageLuminance',
    r'()F',
  );

  static final _getDesiredMaxAverageLuminance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getDesiredMaxAverageLuminance()`
  double getDesiredMaxAverageLuminance() {
    return _getDesiredMaxAverageLuminance(reference.pointer,
            _id_getDesiredMaxAverageLuminance as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getDesiredMinLuminance = _class.instanceMethodId(
    r'getDesiredMinLuminance',
    r'()F',
  );

  static final _getDesiredMinLuminance = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getDesiredMinLuminance()`
  double getDesiredMinLuminance() {
    return _getDesiredMinLuminance(
            reference.pointer, _id_getDesiredMinLuminance as jni.JMethodIDPtr)
        .float;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _writeToParcel(reference.pointer, _id_writeToParcel as jni.JMethodIDPtr,
            parcel.reference.pointer, i)
        .check();
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $Display_HdrCapabilitiesType
    extends jni.JObjType<Display_HdrCapabilities> {
  const $Display_HdrCapabilitiesType();

  @override
  String get signature => r'Landroid/view/Display$HdrCapabilities;';

  @override
  Display_HdrCapabilities fromReference(jni.JReference reference) =>
      Display_HdrCapabilities.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Display_HdrCapabilitiesType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Display_HdrCapabilitiesType) &&
        other is $Display_HdrCapabilitiesType;
  }
}

/// from: `android.view.Display$Mode`
class Display_Mode extends jni.JObject {
  @override
  late final jni.JObjType<Display_Mode> $type = type;

  Display_Mode.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/view/Display$Mode');

  /// The type which includes information such as the signature of this class.
  static const type = $Display_ModeType();
  static final _id_CREATOR = _class.staticFieldId(
    r'CREATOR',
    r'Landroid/os/Parcelable$Creator;',
  );

  /// from: `static public final android.os.Parcelable$Creator CREATOR`
  /// The returned object must be released after use, by calling the [release] method.
  static jni.JObject get CREATOR =>
      _id_CREATOR.get(_class, const jni.JObjectType());

  static final _id_getModeId = _class.instanceMethodId(
    r'getModeId',
    r'()I',
  );

  static final _getModeId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getModeId()`
  int getModeId() {
    return _getModeId(reference.pointer, _id_getModeId as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPhysicalWidth = _class.instanceMethodId(
    r'getPhysicalWidth',
    r'()I',
  );

  static final _getPhysicalWidth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getPhysicalWidth()`
  int getPhysicalWidth() {
    return _getPhysicalWidth(
            reference.pointer, _id_getPhysicalWidth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getPhysicalHeight = _class.instanceMethodId(
    r'getPhysicalHeight',
    r'()I',
  );

  static final _getPhysicalHeight = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getPhysicalHeight()`
  int getPhysicalHeight() {
    return _getPhysicalHeight(
            reference.pointer, _id_getPhysicalHeight as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getRefreshRate = _class.instanceMethodId(
    r'getRefreshRate',
    r'()F',
  );

  static final _getRefreshRate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getRefreshRate()`
  double getRefreshRate() {
    return _getRefreshRate(
            reference.pointer, _id_getRefreshRate as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getAlternativeRefreshRates = _class.instanceMethodId(
    r'getAlternativeRefreshRates',
    r'()[F',
  );

  static final _getAlternativeRefreshRates = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float[] getAlternativeRefreshRates()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jfloat> getAlternativeRefreshRates() {
    return _getAlternativeRefreshRates(reference.pointer,
            _id_getAlternativeRefreshRates as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jfloatType()));
  }

  static final _id_getSupportedHdrTypes = _class.instanceMethodId(
    r'getSupportedHdrTypes',
    r'()[I',
  );

  static final _getSupportedHdrTypes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int[] getSupportedHdrTypes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jint> getSupportedHdrTypes() {
    return _getSupportedHdrTypes(
            reference.pointer, _id_getSupportedHdrTypes as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jintType()));
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public boolean equals(java.lang.Object object)`
  bool equals(
    jni.JObject object,
  ) {
    return _equals(reference.pointer, _id_equals as jni.JMethodIDPtr,
            object.reference.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_describeContents = _class.instanceMethodId(
    r'describeContents',
    r'()I',
  );

  static final _describeContents = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int describeContents()`
  int describeContents() {
    return _describeContents(
            reference.pointer, _id_describeContents as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_writeToParcel = _class.instanceMethodId(
    r'writeToParcel',
    r'(Landroid/os/Parcel;I)V',
  );

  static final _writeToParcel = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>, $Int32)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, int)>();

  /// from: `public void writeToParcel(android.os.Parcel parcel, int i)`
  void writeToParcel(
    jni.JObject parcel,
    int i,
  ) {
    _writeToParcel(reference.pointer, _id_writeToParcel as jni.JMethodIDPtr,
            parcel.reference.pointer, i)
        .check();
  }
}

final class $Display_ModeType extends jni.JObjType<Display_Mode> {
  const $Display_ModeType();

  @override
  String get signature => r'Landroid/view/Display$Mode;';

  @override
  Display_Mode fromReference(jni.JReference reference) =>
      Display_Mode.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($Display_ModeType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($Display_ModeType) &&
        other is $Display_ModeType;
  }
}

/// from: `android.view.Display`
class Display extends jni.JObject {
  @override
  late final jni.JObjType<Display> $type = type;

  Display.fromReference(
    jni.JReference reference,
  ) : super.fromReference(reference);

  static final _class = jni.JClass.forName(r'android/view/Display');

  /// The type which includes information such as the signature of this class.
  static const type = $DisplayType();

  /// from: `static public final int DEFAULT_DISPLAY`
  static const DEFAULT_DISPLAY = 0;

  /// from: `static public final int FLAG_PRESENTATION`
  static const FLAG_PRESENTATION = 8;

  /// from: `static public final int FLAG_PRIVATE`
  static const FLAG_PRIVATE = 4;

  /// from: `static public final int FLAG_ROUND`
  static const FLAG_ROUND = 16;

  /// from: `static public final int FLAG_SECURE`
  static const FLAG_SECURE = 2;

  /// from: `static public final int FLAG_SUPPORTS_PROTECTED_BUFFERS`
  static const FLAG_SUPPORTS_PROTECTED_BUFFERS = 1;

  /// from: `static public final int INVALID_DISPLAY`
  static const INVALID_DISPLAY = -1;

  /// from: `static public final int STATE_DOZE`
  static const STATE_DOZE = 3;

  /// from: `static public final int STATE_DOZE_SUSPEND`
  static const STATE_DOZE_SUSPEND = 4;

  /// from: `static public final int STATE_OFF`
  static const STATE_OFF = 1;

  /// from: `static public final int STATE_ON`
  static const STATE_ON = 2;

  /// from: `static public final int STATE_ON_SUSPEND`
  static const STATE_ON_SUSPEND = 6;

  /// from: `static public final int STATE_UNKNOWN`
  static const STATE_UNKNOWN = 0;

  /// from: `static public final int STATE_VR`
  static const STATE_VR = 5;
  static final _id_getDisplayId = _class.instanceMethodId(
    r'getDisplayId',
    r'()I',
  );

  static final _getDisplayId = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getDisplayId()`
  int getDisplayId() {
    return _getDisplayId(
            reference.pointer, _id_getDisplayId as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_isValid = _class.instanceMethodId(
    r'isValid',
    r'()Z',
  );

  static final _isValid = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isValid()`
  bool isValid() {
    return _isValid(reference.pointer, _id_isValid as jni.JMethodIDPtr).boolean;
  }

  static final _id_getFlags = _class.instanceMethodId(
    r'getFlags',
    r'()I',
  );

  static final _getFlags = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getFlags()`
  int getFlags() {
    return _getFlags(reference.pointer, _id_getFlags as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getName = _class.instanceMethodId(
    r'getName',
    r'()Ljava/lang/String;',
  );

  static final _getName = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString getName() {
    return _getName(reference.pointer, _id_getName as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }

  static final _id_getSize = _class.instanceMethodId(
    r'getSize',
    r'(Landroid/graphics/Point;)V',
  );

  static final _getSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void getSize(android.graphics.Point point)`
  void getSize(
    jni.JObject point,
  ) {
    _getSize(reference.pointer, _id_getSize as jni.JMethodIDPtr,
            point.reference.pointer)
        .check();
  }

  static final _id_getRectSize = _class.instanceMethodId(
    r'getRectSize',
    r'(Landroid/graphics/Rect;)V',
  );

  static final _getRectSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void getRectSize(android.graphics.Rect rect)`
  void getRectSize(
    jni.JObject rect,
  ) {
    _getRectSize(reference.pointer, _id_getRectSize as jni.JMethodIDPtr,
            rect.reference.pointer)
        .check();
  }

  static final _id_getCurrentSizeRange = _class.instanceMethodId(
    r'getCurrentSizeRange',
    r'(Landroid/graphics/Point;Landroid/graphics/Point;)V',
  );

  static final _getCurrentSizeRange = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.VarArgs<
                      (
                        ffi.Pointer<ffi.Void>,
                        ffi.Pointer<ffi.Void>
                      )>)>>('globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// from: `public void getCurrentSizeRange(android.graphics.Point point, android.graphics.Point point1)`
  void getCurrentSizeRange(
    jni.JObject point,
    jni.JObject point1,
  ) {
    _getCurrentSizeRange(
            reference.pointer,
            _id_getCurrentSizeRange as jni.JMethodIDPtr,
            point.reference.pointer,
            point1.reference.pointer)
        .check();
  }

  static final _id_getWidth = _class.instanceMethodId(
    r'getWidth',
    r'()I',
  );

  static final _getWidth = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getWidth()`
  int getWidth() {
    return _getWidth(reference.pointer, _id_getWidth as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getHeight = _class.instanceMethodId(
    r'getHeight',
    r'()I',
  );

  static final _getHeight = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getHeight()`
  int getHeight() {
    return _getHeight(reference.pointer, _id_getHeight as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getRotation = _class.instanceMethodId(
    r'getRotation',
    r'()I',
  );

  static final _getRotation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getRotation()`
  int getRotation() {
    return _getRotation(reference.pointer, _id_getRotation as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getOrientation = _class.instanceMethodId(
    r'getOrientation',
    r'()I',
  );

  static final _getOrientation = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getOrientation()`
  int getOrientation() {
    return _getOrientation(
            reference.pointer, _id_getOrientation as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getCutout = _class.instanceMethodId(
    r'getCutout',
    r'()Landroid/view/DisplayCutout;',
  );

  static final _getCutout = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public android.view.DisplayCutout getCutout()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getCutout() {
    return _getCutout(reference.pointer, _id_getCutout as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getRoundedCorner = _class.instanceMethodId(
    r'getRoundedCorner',
    r'(I)Landroid/view/RoundedCorner;',
  );

  static final _getRoundedCorner = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
                  ffi.VarArgs<($Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
              ffi.Pointer<ffi.Void>, jni.JMethodIDPtr, int)>();

  /// from: `public android.view.RoundedCorner getRoundedCorner(int i)`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getRoundedCorner(
    int i,
  ) {
    return _getRoundedCorner(
            reference.pointer, _id_getRoundedCorner as jni.JMethodIDPtr, i)
        .object(const jni.JObjectType());
  }

  static final _id_getShape = _class.instanceMethodId(
    r'getShape',
    r'()Landroid/view/DisplayShape;',
  );

  static final _getShape = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public android.view.DisplayShape getShape()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getShape() {
    return _getShape(reference.pointer, _id_getShape as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getPixelFormat = _class.instanceMethodId(
    r'getPixelFormat',
    r'()I',
  );

  static final _getPixelFormat = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getPixelFormat()`
  int getPixelFormat() {
    return _getPixelFormat(
            reference.pointer, _id_getPixelFormat as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_getRefreshRate = _class.instanceMethodId(
    r'getRefreshRate',
    r'()F',
  );

  static final _getRefreshRate = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getRefreshRate()`
  double getRefreshRate() {
    return _getRefreshRate(
            reference.pointer, _id_getRefreshRate as jni.JMethodIDPtr)
        .float;
  }

  static final _id_getSupportedRefreshRates = _class.instanceMethodId(
    r'getSupportedRefreshRates',
    r'()[F',
  );

  static final _getSupportedRefreshRates = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float[] getSupportedRefreshRates()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<jni.jfloat> getSupportedRefreshRates() {
    return _getSupportedRefreshRates(
            reference.pointer, _id_getSupportedRefreshRates as jni.JMethodIDPtr)
        .object(const jni.JArrayType(jni.jfloatType()));
  }

  static final _id_getMode = _class.instanceMethodId(
    r'getMode',
    r'()Landroid/view/Display$Mode;',
  );

  static final _getMode = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public android.view.Display$Mode getMode()`
  /// The returned object must be released after use, by calling the [release] method.
  Display_Mode getMode() {
    return _getMode(reference.pointer, _id_getMode as jni.JMethodIDPtr)
        .object(const $Display_ModeType());
  }

  static final _id_getSupportedModes = _class.instanceMethodId(
    r'getSupportedModes',
    r'()[Landroid/view/Display$Mode;',
  );

  static final _getSupportedModes = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public android.view.Display$Mode[] getSupportedModes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JArray<Display_Mode> getSupportedModes() {
    return _getSupportedModes(
            reference.pointer, _id_getSupportedModes as jni.JMethodIDPtr)
        .object(const jni.JArrayType($Display_ModeType()));
  }

  static final _id_isMinimalPostProcessingSupported = _class.instanceMethodId(
    r'isMinimalPostProcessingSupported',
    r'()Z',
  );

  static final _isMinimalPostProcessingSupported =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JniResult Function(
                    ffi.Pointer<ffi.Void>,
                    jni.JMethodIDPtr,
                  )>>('globalEnv_CallBooleanMethod')
          .asFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>();

  /// from: `public boolean isMinimalPostProcessingSupported()`
  bool isMinimalPostProcessingSupported() {
    return _isMinimalPostProcessingSupported(reference.pointer,
            _id_isMinimalPostProcessingSupported as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getHdrCapabilities = _class.instanceMethodId(
    r'getHdrCapabilities',
    r'()Landroid/view/Display$HdrCapabilities;',
  );

  static final _getHdrCapabilities = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public android.view.Display$HdrCapabilities getHdrCapabilities()`
  /// The returned object must be released after use, by calling the [release] method.
  Display_HdrCapabilities getHdrCapabilities() {
    return _getHdrCapabilities(
            reference.pointer, _id_getHdrCapabilities as jni.JMethodIDPtr)
        .object(const $Display_HdrCapabilitiesType());
  }

  static final _id_isHdr = _class.instanceMethodId(
    r'isHdr',
    r'()Z',
  );

  static final _isHdr = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isHdr()`
  bool isHdr() {
    return _isHdr(reference.pointer, _id_isHdr as jni.JMethodIDPtr).boolean;
  }

  static final _id_isHdrSdrRatioAvailable = _class.instanceMethodId(
    r'isHdrSdrRatioAvailable',
    r'()Z',
  );

  static final _isHdrSdrRatioAvailable = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isHdrSdrRatioAvailable()`
  bool isHdrSdrRatioAvailable() {
    return _isHdrSdrRatioAvailable(
            reference.pointer, _id_isHdrSdrRatioAvailable as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getHdrSdrRatio = _class.instanceMethodId(
    r'getHdrSdrRatio',
    r'()F',
  );

  static final _getHdrSdrRatio = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallFloatMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public float getHdrSdrRatio()`
  double getHdrSdrRatio() {
    return _getHdrSdrRatio(
            reference.pointer, _id_getHdrSdrRatio as jni.JMethodIDPtr)
        .float;
  }

  static final _id_registerHdrSdrRatioChangedListener = _class.instanceMethodId(
    r'registerHdrSdrRatioChangedListener',
    r'(Ljava/util/concurrent/Executor;Ljava/util/function/Consumer;)V',
  );

  static final _registerHdrSdrRatioChangedListener =
      ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<
                          (
                            ffi.Pointer<ffi.Void>,
                            ffi.Pointer<ffi.Void>
                          )>)>>('globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(
                  ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<ffi.Void>)>();

  /// from: `public void registerHdrSdrRatioChangedListener(java.util.concurrent.Executor executor, java.util.function.Consumer consumer)`
  void registerHdrSdrRatioChangedListener(
    jni.JObject executor,
    jni.JObject consumer,
  ) {
    _registerHdrSdrRatioChangedListener(
            reference.pointer,
            _id_registerHdrSdrRatioChangedListener as jni.JMethodIDPtr,
            executor.reference.pointer,
            consumer.reference.pointer)
        .check();
  }

  static final _id_unregisterHdrSdrRatioChangedListener =
      _class.instanceMethodId(
    r'unregisterHdrSdrRatioChangedListener',
    r'(Ljava/util/function/Consumer;)V',
  );

  static final _unregisterHdrSdrRatioChangedListener =
      ProtectedJniExtensions.lookup<
                  ffi.NativeFunction<
                      jni.JThrowablePtr Function(
                          ffi.Pointer<ffi.Void>,
                          jni.JMethodIDPtr,
                          ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
              'globalEnv_CallVoidMethod')
          .asFunction<
              jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>,
                  jni.JMethodIDPtr, ffi.Pointer<ffi.Void>)>();

  /// from: `public void unregisterHdrSdrRatioChangedListener(java.util.function.Consumer consumer)`
  void unregisterHdrSdrRatioChangedListener(
    jni.JObject consumer,
  ) {
    _unregisterHdrSdrRatioChangedListener(
            reference.pointer,
            _id_unregisterHdrSdrRatioChangedListener as jni.JMethodIDPtr,
            consumer.reference.pointer)
        .check();
  }

  static final _id_isWideColorGamut = _class.instanceMethodId(
    r'isWideColorGamut',
    r'()Z',
  );

  static final _isWideColorGamut = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallBooleanMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public boolean isWideColorGamut()`
  bool isWideColorGamut() {
    return _isWideColorGamut(
            reference.pointer, _id_isWideColorGamut as jni.JMethodIDPtr)
        .boolean;
  }

  static final _id_getPreferredWideGamutColorSpace = _class.instanceMethodId(
    r'getPreferredWideGamutColorSpace',
    r'()Landroid/graphics/ColorSpace;',
  );

  static final _getPreferredWideGamutColorSpace = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public android.graphics.ColorSpace getPreferredWideGamutColorSpace()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getPreferredWideGamutColorSpace() {
    return _getPreferredWideGamutColorSpace(reference.pointer,
            _id_getPreferredWideGamutColorSpace as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getAppVsyncOffsetNanos = _class.instanceMethodId(
    r'getAppVsyncOffsetNanos',
    r'()J',
  );

  static final _getAppVsyncOffsetNanos = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public long getAppVsyncOffsetNanos()`
  int getAppVsyncOffsetNanos() {
    return _getAppVsyncOffsetNanos(
            reference.pointer, _id_getAppVsyncOffsetNanos as jni.JMethodIDPtr)
        .long;
  }

  static final _id_getPresentationDeadlineNanos = _class.instanceMethodId(
    r'getPresentationDeadlineNanos',
    r'()J',
  );

  static final _getPresentationDeadlineNanos = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public long getPresentationDeadlineNanos()`
  int getPresentationDeadlineNanos() {
    return _getPresentationDeadlineNanos(reference.pointer,
            _id_getPresentationDeadlineNanos as jni.JMethodIDPtr)
        .long;
  }

  static final _id_getDeviceProductInfo = _class.instanceMethodId(
    r'getDeviceProductInfo',
    r'()Landroid/hardware/display/DeviceProductInfo;',
  );

  static final _getDeviceProductInfo = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public android.hardware.display.DeviceProductInfo getDeviceProductInfo()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JObject getDeviceProductInfo() {
    return _getDeviceProductInfo(
            reference.pointer, _id_getDeviceProductInfo as jni.JMethodIDPtr)
        .object(const jni.JObjectType());
  }

  static final _id_getMetrics = _class.instanceMethodId(
    r'getMetrics',
    r'(Landroid/util/DisplayMetrics;)V',
  );

  static final _getMetrics = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void getMetrics(android.util.DisplayMetrics displayMetrics)`
  void getMetrics(
    jni.JObject displayMetrics,
  ) {
    _getMetrics(reference.pointer, _id_getMetrics as jni.JMethodIDPtr,
            displayMetrics.reference.pointer)
        .check();
  }

  static final _id_getRealSize = _class.instanceMethodId(
    r'getRealSize',
    r'(Landroid/graphics/Point;)V',
  );

  static final _getRealSize = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void getRealSize(android.graphics.Point point)`
  void getRealSize(
    jni.JObject point,
  ) {
    _getRealSize(reference.pointer, _id_getRealSize as jni.JMethodIDPtr,
            point.reference.pointer)
        .check();
  }

  static final _id_getRealMetrics = _class.instanceMethodId(
    r'getRealMetrics',
    r'(Landroid/util/DisplayMetrics;)V',
  );

  static final _getRealMetrics = ProtectedJniExtensions.lookup<
              ffi.NativeFunction<
                  jni.JThrowablePtr Function(
                      ffi.Pointer<ffi.Void>,
                      jni.JMethodIDPtr,
                      ffi.VarArgs<(ffi.Pointer<ffi.Void>,)>)>>(
          'globalEnv_CallVoidMethod')
      .asFunction<
          jni.JThrowablePtr Function(ffi.Pointer<ffi.Void>, jni.JMethodIDPtr,
              ffi.Pointer<ffi.Void>)>();

  /// from: `public void getRealMetrics(android.util.DisplayMetrics displayMetrics)`
  void getRealMetrics(
    jni.JObject displayMetrics,
  ) {
    _getRealMetrics(reference.pointer, _id_getRealMetrics as jni.JMethodIDPtr,
            displayMetrics.reference.pointer)
        .check();
  }

  static final _id_getState = _class.instanceMethodId(
    r'getState',
    r'()I',
  );

  static final _getState = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public int getState()`
  int getState() {
    return _getState(reference.pointer, _id_getState as jni.JMethodIDPtr)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = ProtectedJniExtensions.lookup<
          ffi.NativeFunction<
              jni.JniResult Function(
                ffi.Pointer<ffi.Void>,
                jni.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni.JniResult Function(
            ffi.Pointer<ffi.Void>,
            jni.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni.JString toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni.JMethodIDPtr)
        .object(const jni.JStringType());
  }
}

final class $DisplayType extends jni.JObjType<Display> {
  const $DisplayType();

  @override
  String get signature => r'Landroid/view/Display;';

  @override
  Display fromReference(jni.JReference reference) =>
      Display.fromReference(reference);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($DisplayType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($DisplayType) && other is $DisplayType;
  }
}
